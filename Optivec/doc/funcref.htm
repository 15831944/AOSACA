<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <title>OptiVec: VectorLib Function Reference</title>
   <link rel="stylesheet" media="screen" type="text/css" href="stylesheet.css">
</head> 
<body>
<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR><TD><IMG SRC="optivec.gif" BORDER=0 WIDTH=260 alt="OptiVec logo">&nbsp;
</TD><TD><h1><I><b><font size="+4">OptiVec</font></b></I><BR>&nbsp;<BR>Version 7</h1>
<BR><h2>for C/C++ and for Pascal / Delphi</h2>
</td></tr><tr><TD>
<I>OptiCode</I>
<BR>Dr. Martin Sander Software Development
<BR>Brahmsstr. 6
<BR>D-32756 Detmold
<BR>Germany
<BR><a href="http://www.optivec.com">http://www.optivec.com</a>
<BR>e-mail: <A HREF="mailto:optivec@gmx.de">optivec@gmx.de</A>
</TD><TD><h1>Part I. B: Function Reference<BR>for <I>VectorLib</I></h1>
</TD></TR></TABLE>

<BR>A general description of <I>OptiVec</I> is given in <a href="HANDBOOK.HTM">HANDBOOK.HTM</a>.
<BR>For <I>MatrixLib</I> functions, see <a href="MATRIX.HTM">MATRIX.HTM</a>, for <I>CMATH</I> functions, see <a href="CMATH.HTM">CMATH.HTM</a>.

<BR><a href="HANDBOOK.HTM#chap1_2">Chapter 1.2</a> of HANDBOOK.HTM contains the licence terms for the Shareware version, <a href="HANDBOOK.HTM#chap1_3">Chapter 1.3</a> for the Registered version.

<P><a name="chap8"></a>
<HR width="100%"><H1>8. Alphabetical Reference of Vector&nbsp;Functions</H1>

The functions are alphabetically ordered, with the prefixes being neglected for the ordering. The heading of each entry lists all the versions available for a specific function:
<P><a name="example"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_example</b></font></td><td width="33%"><font size="+1"><b>VD_example</b></font></td><td><font size="+1"><b>VE_example</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_example</b></font></td><td width="33%"><font size="+1"><b>VCD_example</b></font></td><td><font size="+1"><b>VCE_example</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Consider, e.g., the &quot;abs&quot; family of functions. It exists in vectorized versions for
<UL><LI>the three real-number data types float, double, and extended (long double) with the prefixes <I>VF_,&nbsp;&nbsp; VD_</I>, and <I>VE_</I>,
<LI>for the three cartesian complex-number data types (prefixes <I>VCF_,&nbsp;&nbsp; VCD_</I>, and <I>VCE_</I>),
<LI>for the three polar complex-number data types (prefixes <I>VPF_,&nbsp;&nbsp; VPD_</I>, and <I>VPE_</I>),
<LI>and for the signed integer data types int, byte, short int, long int, and quad (prefixes <I>VI_,&nbsp;&nbsp; VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_</I>, and <I>VQI_</I>);
</UL>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td>In most cases, only the <I>VF_</I> version is described. All other versions are exactly analogous; one has only to replace the data types float and fVector&nbsp;by the appropriate ones and replace the <i>VF...</i> include file by the one belonging to the desired data type.</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td>Here, the syntax of the object-oriented interface is described</td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>Similarly to the description of the C/C++ syntax, again only the <I>VF_</I> version is described. Replace the data types float and fVector&nbsp;by the appropriate ones and include the unit belonging to the desired data type into the &quot;uses&quot; clause.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><TD>Often, for the sake of simplicity, the brackets around vector element indices are left away. If not stated otherwise, all vector elements from the zero'th up to the last one (with the index size-1) are subjected to the respective operation described. Thus, a formula like
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yi = | Xi |
<BR>is to be understood as an abbreviation for
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y[i] = | X[i] |, i=0,...,size-1
<BR>or, written as a loop:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( i=0; i&lt;size; i++&nbsp;) Y[i] = fabs( X[i]&nbsp;);</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>All types of errors are listed which are detected and handled. The default result is given in each case.
<BR><u>32-bit C/C++ only:</u>
<BR>In case of any detected floating-point errors, <I>_matherr</I> or <I>_matherrl</I> are called (see <a href="HANDBOOK.HTM#chap5_3">chapter&nbsp;5.3</a>). Although we do not recommend that, the user may modify <I>_matherr</I> and <I>_matherrl</I> such as to specify other results than those suggested.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The return value of the respective function is mentioned here.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td>References to functions without a prefix &quot;V...&quot; refer to the documentation of your C/C++ or Pascal/Delphi compiler. References to chapters 1. to 7. refer to the file <a href="HANDBOOK.HTM">HANDBOOK.HTM</a>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="abs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_abs</b></font></td><td width="33%"><font size="+1"><b>VD_abs</b></font></td><td><font size="+1"><b>VE_abs</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_abs</b></font></td><td width="33%"><font size="+1"><b>VCD_abs</b></font></td><td><font size="+1"><b>VCE_abs</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_abs</b></font></td><td width="33%"><font size="+1"><b>VPD_abs</b></font></td><td><font size="+1"><b>VPE_abs</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_abs</b></font></td><td width="20%"><font size="+1"><b>VBI_abs</b></font></td><td width="20%"><font size="+1"><b>VSI_abs</b></font></td><td width="20%"><font size="+1"><b>VLI_abs</b></font></td><td><font size="+1"><b>VQI_abs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Absolute value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_abs( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VQI_</I>)
<BR><font face="courier new">int VCF_abs( fVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::abs( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::abs( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_abs( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VQI_</I>)
<BR><font face="courier new">function VCF_abs( Y:fVector; X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">

<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_abs( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_abs( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_abs( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_abs( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">

<td width="15%">Description</td><td>Real and integer versions: Y<sub>i</sub> = | X<sub>i</sub> |
<BR><I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VI_</I>, and <I>VLI_</I> versions only: due to the implicit modulo-2<sup>n</sup> arithmetics, the absolute value of the most negative numbers possible ( -32768 for short/SmallInt, -2147483648 for long/LongInt) is stored as the same negative (!) number (-32768 or -2147483648, resp.).<BR>Complex versions: Y<sub>i</sub> = sqrt( X<sub>i</sub>.Re<sup>2</sup> + X<sub>i</sub>.Im<sup>2</sup>&nbsp;)
<BR>For the complex versions, note that the result is real-valued. For the cartesian complex functions (<I>VC?_abs</I>), the same result may also be obtained slightly faster, but without error handling, using <I><a href="#CtoAbs">VF_CtoAbs</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real and integer versions: no errors should occur;
<BR>Complex versions: OVERFLOW errors lead to the default result +HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Floating-point versions: FALSE (0), if error-free, otherwise TRUE (!= 0).
<BR>The integer versions have no return value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#neg">VF_neg</a>,&nbsp;&nbsp; <a href="#conj">VCF_conj</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absmax"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_absmax</b></font></td><td width="33%"><font size="+1"><b>VD_absmax</b></font></td><td><font size="+1"><b>VE_absmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absmax</b></font></td><td width="33%"><font size="+1"><b>VCD_absmax</b></font></td><td><font size="+1"><b>VCE_absmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_absmax</b></font></td><td width="33%"><font size="+1"><b>VPD_absmax</b></font></td><td><font size="+1"><b>VPE_absmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Largest absolute value within one vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_absmax( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">float VCF_absmax( cfVector&nbsp;X, ui&nbsp;size);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::absmax();
<BR>T vector&lt;complex&lt;T&gt;&gt;::absmax();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_absmax( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">function VCF_absmax( X:cfVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_absmax( float *h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_absmax( float *d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_absmax( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_absmax( var h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_absmax( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_absmax( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a vector are compared and the largest returned.
<BR>For complex numbers, the magnitudes of the elements are compared and the largest magnitude is returned. If you need the complex number itself rather than only its magnitude, use <I><a href="#cabsmax">VCF_cabsmax</a></I>. In order to find the greatest real and imaginary parts of cartesian complex vectors separately, call <I><a href="#absmaxReIm">VCF_absmaxReIm</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>maximum absolute value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#absminmax">VF_absminmax</a>,&nbsp;&nbsp; <a href="#maxexp">VF_maxexp</a>,&nbsp;&nbsp; <a href="#runmax">VF_runmax</a>,&nbsp;&nbsp; <a href="#absmaxind">VF_absmaxind</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a>,&nbsp;&nbsp; <a href="#cabsmax">VCF_cabsmax</a>,&nbsp;&nbsp; <a href="#sabsmax">VCF_sabsmax</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absmaxind"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_absmaxind</b></font></td><td width="33%"><font size="+1"><b>VD_absmaxind</b></font></td><td><font size="+1"><b>VE_absmaxind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absmaxind</b></font></td><td width="33%"><font size="+1"><b>VCD_absmaxind</b></font></td><td><font size="+1"><b>VCE_absmaxind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_absmaxind</b></font></td><td width="33%"><font size="+1"><b>VPD_absmaxind</b></font></td><td><font size="+1"><b>VPE_absmaxind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Largest absolute value and its index</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_absmaxind( ui&nbsp;*Ind, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">float VCF_absmaxind( ui&nbsp;*Ind, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::absmaxind( ui&nbsp;*Ind&nbsp;);
<BR>T vector&lt;complex&lt;T&gt;&gt;::absmaxind( ui&nbsp;*Ind&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_absmaxind( var Ind:UIntSize; X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">function VCF_absmaxind( var Ind:UIntSize; X:cfVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_absmaxind( float *h_RetVal, ui&nbsp;*h_Ind, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_absmaxind( float *d_RetVal, ui&nbsp;*h_Ind, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_absmaxind( ui&nbsp;*h_Ind, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_absmaxind( var h_RetVal:Single; var h_Ind:UIntSize; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_absmaxind( d_RetVal:PSingle; var h_Ind:UIntSize; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_absmaxind( var h_Ind:UIntSize; h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a vector are compared and the largest returned. For complex numbers, the magnitudes of the elements are compared and the largest returned. The index of this maximum is stored at the address given by Ind. In case of more than one element with the same maximum value, the lowest index is chosen.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>maximum absolute value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxind">VF_maxind</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#runmax">VF_runmax</a>,&nbsp;&nbsp; <a href="#maxind">VF_maxind</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absmaxReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absmaxReIm</b></font></td><td width="33%"><font size="+1"><b>VCD_absmaxReIm</b></font></td><td><font size="+1"><b>VCE_absmaxReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the largest absolute values of the real and imaginary parts occurring in a cartesian complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_absmaxReIm( cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex&lt;T&gt; vector&lt;complex&lt;T&gt;&gt;::absmaxReIm();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function VCF_absmaxReIm( X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
<BR>Alternative syntax (obsolete, but still supported):<font face="courier new">
<BR>procedure VCF_absmaxReIm( var RetVal:fComplex; X:cfVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_absmaxReIm( fComplex *h_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVCF_absmaxReIm( fComplex *d_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>fComplex VCFcu_absmaxReIm( cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_absmaxReIm( var h_RetVal:fComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVCF_absmaxReIm( d_RetVal:PfComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VCFcu_absmaxReIm( h_X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of the real parts of all vector elements are compared with each other and the largest one is returned as the real part of the result. Similarly, the absolute values of all the imaginary parts are compared with each other and the largest one is returned as the imaginary part of the result. Generally, the result is made up from different elements of the vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Largest absolute real and imaginary parts, combined into one complex number.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxReIm">VCF_maxReIm</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absmin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_absmin</b></font></td><td width="33%"><font size="+1"><b>VD_absmin</b></font></td><td><font size="+1"><b>VE_absmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absmin</b></font></td><td width="33%"><font size="+1"><b>VCD_absmin</b></font></td><td><font size="+1"><b>VCE_absmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_absmin</b></font></td><td width="33%"><font size="+1"><b>VPD_absmin</b></font></td><td><font size="+1"><b>VPE_absmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Smallest absolute value within one vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_absmin( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">float VCF_absmin( cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::absmin();
<BR>T vector&lt;complex&lt;T&gt;&gt;::absmin();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_absmin( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">function VCF_absmin( X:cfVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_absmin( float *h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_absmin( float *d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_absmin( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_absmin( var h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_absmin( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_absmin( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a vector are compared and the smallest returned.
<BR>For complex numbers, the magnitudes of the elements are compared and the smallest magnitude is returned. If you need the complex number itself rather than only its magnitude, call <I><a href="#cabsmin">VCF_cabsmin</a></I>. In order to find the smallest real and imaginary parts of cartesian complex vectors separately, please use <I><a href="#absminReIm">VCF_absminReIm</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>minimum absolute value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#absminmax">VF_absminmax</a>,&nbsp;&nbsp; <a href="#minexp">VF_minexp</a>,&nbsp;&nbsp; <a href="#runmin">VF_runmin</a>,&nbsp;&nbsp; <a href="#minind">VF_minind</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a>,&nbsp;&nbsp; <a href="#cabsmin">VCF_cabsmin</a>,&nbsp;&nbsp; <a href="#sabsmin">VCF_sabsmin</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absminind"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_absminind</b></font></td><td width="33%"><font size="+1"><b>VD_absminind</b></font></td><td><font size="+1"><b>VE_absminind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absminind</b></font></td><td width="33%"><font size="+1"><b>VCD_absminind</b></font></td><td><font size="+1"><b>VCE_absminind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_absminind</b></font></td><td width="33%"><font size="+1"><b>VPD_absminind</b></font></td><td><font size="+1"><b>VPE_absminind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Smallest absolute value and the index of its first occurrence.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_absminind( ui&nbsp;*Ind, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">float VCF_absminind( ui&nbsp;*Ind, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::absminind( ui&nbsp;*Ind&nbsp;);
<BR>T vector&lt;complex&lt;T&gt;&gt;::absminind( ui&nbsp;*Ind&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_absminind( var Ind:UIntSize; X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">function VCF_absminind( var Ind:UIntSize; X:cfVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_absminind( float *h_RetVal, ui&nbsp;*h_Ind, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_absminind( float *d_RetVal, ui&nbsp;*h_Ind, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_absminind( ui&nbsp;*h_Ind, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_absminind( var h_RetVal:Single; var h_Ind:UIntSize; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_absminind( d_RetVal:PSingle; var h_Ind:UIntSize; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_absminind( var h_Ind:UIntSize; h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a vector are compared and the smallest returned. For complex numbers, the magnitudes of the elements are compared and the smallest returned. The index of this minimum is stored at the address given by Ind. In case of more than one element with the same minimum value, the lowest index is chosen.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>minimum absolute value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minind">VF_minind</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#runmin">VF_runmin</a>,&nbsp;&nbsp; <a href="#maxind">VF_maxind</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absminmax"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_absminmax</b></font></td><td width="34%"><font size="+1"><b>VD_absminmax</b></font></td><td><font size="+1"><b>VE_absminmax</b></font></td></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Finds the smallest and the largest absolute value of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_absminmax( float&nbsp;*xmax, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::absminmax(T&nbsp;*xmax);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_absminmax( var&nbsp;xmax:Single; X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_absminmax( float&nbsp;*h_xmin, float&nbsp;*h_xmax, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_absminmax( float&nbsp;*d_xmin, float&nbsp;*d_xmax, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_absminmax( float&nbsp;*xmax, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_absminmax( var&nbsp;h_xmin, h_xmax:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_absminmax( d_xmin, d_xmax:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_absminmax( var&nbsp;h_xmax:Single; h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is searched for its minimum and maximum in absolute terms. The maximum is stored as <i>xmax</i>, while the minimum is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Minimum absolute value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minmax">VF_minmax</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#stats">VF_min_max_mean_stddev</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absminReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absminReIm</b></font></td><td width="33%"><font size="+1"><b>VCD_absminReIm</b></font></td><td><font size="+1"><b>VCE_absminReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the smallest absolute values of the real and imaginary parts occurring in a cartesian complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_absminReIm( cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex&lt;T&gt; vector&lt;complex&lt;T&gt;&gt;::absminReIm();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function VCF_absminReIm( X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
<BR>Alternative syntax (obsolete, but still supported):<font face="courier new">
<BR>procedure VCF_absminReIm( var Min:fComplex; X:cfVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_absminReIm( fComplex *h_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVCF_absminReIm( fComplex *d_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>fComplex VCFcu_absminReIm( cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_absminReIm( var h_RetVal:fComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVCF_absminReIm( d_RetVal:PfComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VCFcu_absminReIm( h_X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of the real parts of all vector elements are compared with each other and the smallest one is returned as the real part of the result. Similarly, the absolute values of all the imaginary parts are compared with each other and the smallest one is returned as the imaginary part of the result. Generally, the result is made up from different elements of the vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Smallest absolute real and imaginary parts, combined into one complex number.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minReIm">VCF_minReIm</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="accV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_accV</b></font></td><td width="34%"><font size="+1"><b>VD_accV</b></font></td><td><font size="+1"><b>VE_accV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_accV</b></font></td><td width="34%"><font size="+1"><b>VCD_accV</b></font></td><td><font size="+1"><b>VCE_accV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_accV</b></font></td><td width="17%"><font size="+1"><b>VBI_accV</b></font></td><td width="17%"><font size="+1"><b>VSI_accV</b></font></td><td width="17%"><font size="+1"><b>VLI_accV</b></font></td><td width="17%"><font size="+1"><b>VQI_accV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_accV</b></font></td><td width="17%"><font size="+1"><b>VUB_accV</b></font></td><td width="17%"><font size="+1"><b>VUS_accV</b></font></td><td width="17%"><font size="+1"><b>VUL_accV</b></font></td><td width="17%"><font size="+1"><b>VUQ_accV</b></font></td><td><font size="+1"><b>VUI_accV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>mixed-type versions:</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VD_accVF</b></font></td><td width="33%"><font size="+1"><b>VE_accVF</b></font></td><td><font size="+1"><b>VE_accVD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCD_accVCF</b></font></td><td width="33%"><font size="+1"><b>VCE_accVCF</b></font></td><td><font size="+1"><b>VCE_accVCD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td><font size="+1"><b>VSI_accVBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_accVBI</b></font></td><td width="20%"><font size="+1"><b>VI_accVSI</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VLI_accVBI</b></font></td><td width="20%"><font size="+1"><b>VLI_accVSI</b></font></td><td width="20%"><font size="+1"><b>VLI_accVI</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td><font size="+1"><b>VUS_accVUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_accVUB</b></font></td><td width="20%"><font size="+1"><b>VU_accVUS</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VUL_accVUB</b></font></td><td width="20%"><font size="+1"><b>VUL_accVUS</b></font></td><td width="20%"><font size="+1"><b>VUL_accVU</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VUQ_accVUB</b></font></td><td width="20%"><font size="+1"><b>VUQ_accVUS</b></font></td><td width="20%"><font size="+1"><b>VUQ_accVU</b></font></td><td width="20%"><font size="+1"><b>VUQ_accVUL</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VUI_accVUB</b></font></td><td width="20%"><font size="+1"><b>VUI_accVUS</b></font></td><td width="20%"><font size="+1"><b>VUI_accVU</b></font></td><td width="20%"><font size="+1"><b>VUI_accVUL</b></font></td><td><font size="+1"><b>VUI_accVUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VQI_accVBI</b></font></td><td width="20%"><font size="+1"><b>VQI_accVSI</b></font></td><td width="20%"><font size="+1"><b>VQI_accVI</b></font></td><td width="20%"><font size="+1"><b>VQI_accVLI</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VQI_accVUB</b></font></td><td width="20%"><font size="+1"><b>VQI_accVUS</b></font></td><td width="20%"><font size="+1"><b>VQI_accVU</b></font></td><td width="20%"><font size="+1"><b>VQI_accVUL</b></font></td><td><font size="+1"><b>VQI_accVUI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_...</b></font></td><td width="33%"><font size="+1"><b>VD_...</b></font></td><td><font size="+1"><b>VE_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="17%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVI</b></font></td><td width="17%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVBI</b></font></td><td width="17%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVSI</b></font></td><td width="17%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVLI</b></font></td><td width="17%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVQI</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="17%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVU</b></font></td><td width="17%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVUB</b></font></td><td width="17%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVUS</b></font></td><td width="17%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVUL</b></font></td><td width="17%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVUQ</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Accumulation (corresponds to the += operator)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_accV( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>void VD_accVF( dVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::accV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>void vector&lt;double&gt;::accVF( const&nbsp;vector&lt;float&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_accV( Y,&nbsp;X:fVector; size:UIntSize&nbsp;);
<BR>procedure VD_accVF( Y:dVector; X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVDmath.h&gt;
<BR>int cudaVF_accV( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVD_accVF( dVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_accV( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>void VDcu_accVF( dVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VDmath;
<BR>function cudaVF_accV( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVD_accVF( d_Y:dVector; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_accV( h_Y, h_X:fVector; size:UIntSize&nbsp;);
<BR>procedure VDcu_accVF( h_Y:dVector; h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> += X<sub>i</sub>
<BR>This family of functions consists of two groups. The first group is made up of the normal, same-type versions, like <I>VF_accV</I>.
<BR>The much larger second group allows to add a lower-accuracy type vector to a higher-accuracy type vector, like <I>VD_accVF</I>. For the integer types, only the highest one, quad, is used to accumulate both signed and unsigned types. The 16-bit and 32-bit integer types can accumulate only the lower types of the same sort, signed or unsigned. All integer types can be accumulated in any of the three floating-point types.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#acc2V">VF_acc2V</a>, &nbsp;&nbsp;<a href="#addV">VF_addV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="acc2V"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_acc2V</b></font></td><td width="33%"><font size="+1"><b>VD_acc2V</b></font></td><td><font size="+1"><b>VE_acc2V</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>mixed-type versions:</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VD_acc2VF</b></font></td><td width="33%"><font size="+1"><b>VE_acc2VF</b></font></td><td><font size="+1"><b>VE_acc2VD</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Accumulation (corresponds to the += operator) of two vectors at once</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_acc2V( fVector&nbsp;Y, fVector&nbsp;X1, fVector&nbsp;X2, ui&nbsp;size&nbsp;);
<BR>void VD_accVF( dVector&nbsp;Y, fVector&nbsp;X1, fVector&nbsp;X2, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::acc2V( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X1, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X2&nbsp;);
<BR>void vector&lt;double&gt;::acc2VF( const&nbsp;vector&lt;float&gt;&amp;&nbsp;X1, const&nbsp;vector&lt;float&gt;&amp;&nbsp;X2&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_acc2V( Y, X1, X2:fVector; size:UIntSize&nbsp;);
<BR>procedure VD_acc2VF( Y:dVector; X1, X2:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVDmath.h&gt;
<BR>int cudaVF_acc2V( fVector&nbsp;d_Y, fVector&nbsp;d_X1, fVector&nbsp;d_X2, ui&nbsp;size&nbsp;);
<BR>int cudaVD_acc2VF( dVector&nbsp;d_Y, fVector&nbsp;d_X1, fVector&nbsp;d_X2, ui&nbsp;size&nbsp;);
<BR>void VFcu_acc2V( fVector&nbsp;h_Y, fVector&nbsp;h_X1, fVector&nbsp;h_X2, ui&nbsp;size&nbsp;);
<BR>void VDcu_acc2VF( dVector&nbsp;h_Y, fVector&nbsp;h_X1, fVector&nbsp;h_X2, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VDmath;
<BR>function cudaVF_acc2V( d_Y, d_X1, d_X2:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVD_acc2VF( d_Y:dVector; d_X1, d_X2:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_acc2V( h_Y, h_X1, h_X2:fVector; size:UIntSize&nbsp;);
<BR>procedure VDcu_acc2VF( h_Y:dVector; h_X1, h_X2:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> += X1<sub>i</sub> + X2<sub>i</sub>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#accV">VF_accV</a>, &nbsp;&nbsp;<a href="#add2V">VF_add2V</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="acos"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_acos</b></font></td><td width="33%"><font size="+1"><b>VD_acos</b></font></td><td><font size="+1"><b>VE_acos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_acos</b></font></td><td width="33%"><font size="+1"><b>VCD_acos</b></font></td><td><font size="+1"><b>VCE_acos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_acos</b></font></td><td width="33%"><font size="+1"><b>VDx_acos</b></font></td><td><font size="+1"><b>VEx_acos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_acos</b></font></td><td width="33%"><font size="+1"><b>VCDx_acos</b></font></td><td><font size="+1"><b>VCEx_acos</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>arcus cosinus function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_acos( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_acos( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::acos( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_acos( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_acos( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_acos( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_acos( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_acos( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_acos( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_acos( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_acos( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_acos( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_acos( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_acos( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_acos( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_acos( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = arccos ( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;arccos (A*X<sub>i</sub> + B&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real versions: DOMAIN errors occur for arguments outside the range -1 &lt;= X<sub>i</sub> &lt;= +1; the default result is NAN (&quot;not-a-number&quot;).
<BR>The complex versions should be error-proof as long as the parameter C in the expanded versions is not already near the OVERFLOW limit; this very rare error is neither detected nor handled.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cos">VF_cos</a>,&nbsp;&nbsp; <a href="#asin">VF_asin</a>,&nbsp;&nbsp; <a href="#atan">VF_atan</a>,&nbsp;&nbsp; acos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="addC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addC</b></font></td><td width="34%"><font size="+1"><b>VD_addC</b></font></td><td><font size="+1"><b>VE_addC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_addC</b></font></td><td width="34%"><font size="+1"><b>VCD_addC</b></font></td><td><font size="+1"><b>VCE_addC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_addReC</b></font></td><td width="34%"><font size="+1"><b>VCD_addReC</b></font></td><td><font size="+1"><b>VCE_addReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_addC</b></font></td><td width="17%"><font size="+1"><b>VBI_addC</b></font></td><td width="17%"><font size="+1"><b>VSI_addC</b></font></td><td width="17%"><font size="+1"><b>VLI_addC</b></font></td><td width="17%"><font size="+1"><b>VQI_addC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_addC</b></font></td><td width="17%"><font size="+1"><b>VUB_addC</b></font></td><td width="17%"><font size="+1"><b>VUS_addC</b></font></td><td width="17%"><font size="+1"><b>VUL_addC</b></font></td><td width="17%"><font size="+1"><b>VUQ_addC</b></font></td><td><font size="+1"><b>VUI_addC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Add a constant to a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_addC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">#include &lt;VCFmath.h&gt;
<BR>void VCF_addC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>void VCF_addReC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::addC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C);&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::addC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::addReC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;CRe&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_addC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">procedure VCF_addC( Y,&nbsp;X:cfVector; size:UIntSize; C:fComplex&nbsp;);
<BR>procedure VCF_addReC( Y,&nbsp;X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_addC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_addC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_addC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVCF_addReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);
<BR>int cusdVCF_addReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_CRe&nbsp;);
<BR>void VCFcu_addReC( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_addC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_addC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_addC( h_Y, h_X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>function cudaVCF_addReC( d_Y, d_X:cfVector; size:UIntSize; CRe:Single&nbsp;);
<BR>function cusdVCF_addReC( d_Y, d_X:cfVector; size:UIntSize; d_CRe:PSingle&nbsp;);
<BR>procedure VCFcu_addReC( h_Y, h_X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> + C
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe added to the complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="addV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addV</b></font></td><td width="34%"><font size="+1"><b>VD_addV</b></font></td><td><font size="+1"><b>VE_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_addV</b></font></td><td width="34%"><font size="+1"><b>VCD_addV</b></font></td><td><font size="+1"><b>VCE_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_addReV</b></font></td><td width="34%"><font size="+1"><b>VCD_addReV</b></font></td><td><font size="+1"><b>VCE_addReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFs_addV</b></font></td><td width="34%"><font size="+1"><b>VDs_addV</b></font></td><td><font size="+1"><b>VEs_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_addV</b></font></td><td width="34%"><font size="+1"><b>VDx_addV</b></font></td><td><font size="+1"><b>VEx_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_addV</b></font></td><td width="34%"><font size="+1"><b>VCDx_addV</b></font></td><td><font size="+1"><b>VCEx_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_addReV</b></font></td><td width="34%"><font size="+1"><b>VCDx_addReV</b></font></td><td><font size="+1"><b>VCEx_addReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_addV</b></font></td><td width="17%"><font size="+1"><b>VBI_addV</b></font></td><td width="17%"><font size="+1"><b>VSI_addV</b></font></td><td width="17%"><font size="+1"><b>VLI_addV</b></font></td><td width="17%"><font size="+1"><b>VQI_addV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_addV</b></font></td><td width="17%"><font size="+1"><b>VUB_addV</b></font></td><td width="17%"><font size="+1"><b>VUS_addV</b></font></td><td width="17%"><font size="+1"><b>VUL_addV</b></font></td><td width="17%"><font size="+1"><b>VUQ_addV</b></font></td><td><font size="+1"><b>VUI_addV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Add two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_addV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y,ui&nbsp;size&nbsp;);
<BR>void VFs_addV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFx_addV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VDx_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VEx_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">void VCF_addV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCF_addReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCFx_addV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFx_addReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCDx_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VCEx_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::addV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::s_addV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;T&gt;::x_addV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::addV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::addReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_addV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_addReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_addV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFs_addV( Z, X,&nbsp;Y:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VFx_addV( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VDx_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VEx_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">procedure VCF_addV( Z, X,&nbsp;Y:cfVector; size:UIntSize&nbsp;);
<BR>procedure VCF_addReV( Z, X:cfVector; Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCFx_addV( Z, X,&nbsp;Y:cfVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);
<BR>procedure VCFx_addReV( Z, X:cfVector; Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_</I>, VCDx_, <I>VCE_,&nbsp;&nbsp; VCEx_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVF_addV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVFs_addV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVFs_addV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>int cudaVFx_addV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_addV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int cudaVCF_addReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>int cudaVCFx_addReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>int cusdVCFx_addReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;*d_A, fComplex&nbsp;*d_B&nbsp;);
<BR>void VFcu_addV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFscu_addV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFxcu_addV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>void VCFcu_addReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);
<BR>void VCFxcu_addV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, cfVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFxcu_addReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_addV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFs_addV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFs_addV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_addV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_addV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVCF_addReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVCFx_addReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;):&nbsp;IntBool;
<BR>function cusdVCFx_addReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PfComplex&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_addV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFscu_addV( h_Z, h_X, h_Y:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VFxcu_addV( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);
<BR>procedure VCFcu_addReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCFxcu_addReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = X<sub>i</sub> + Y<sub>i</sub>
<BR>scaled versions: Z<sub>i</sub> = C *&nbsp;(X<sub>i</sub> + Y<sub>i</sub>)
<BR>expanded versions: Z<sub>i</sub> = (A *&nbsp;X<sub>i</sub> + B) + Y<sub>i</sub>
<BR>The complex floating-point versions exist in two variants. In the first variant (e.g.<I>VCF_addV,&nbsp;&nbsp; VCFx_addV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g., <I>VCF_addReV</I> - &quot;add a real vector&quot;).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#add2V">VF_add2V</a>,&nbsp;&nbsp; <a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#accV">VF_accV</a>,&nbsp;&nbsp; <a href="#addVI">VF_addVI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="addVI"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addVI</b></font></td><td width="33%"><font size="+1"><b>VD_addVI</b></font></td><td><font size="+1"><b>VE_addVI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addVBI</b></font></td><td width="33%"><font size="+1"><b>VD_addVBI</b></font></td><td><font size="+1"><b>VE_addVBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addVSI</b></font></td><td width="33%"><font size="+1"><b>VD_addVSI</b></font></td><td><font size="+1"><b>VE_addVSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addVLI</b></font></td><td width="33%"><font size="+1"><b>VD_addVLI</b></font></td><td><font size="+1"><b>VE_addVLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addVQI</b></font></td><td width="33%"><font size="+1"><b>VD_addVQI</b></font></td><td><font size="+1"><b>VE_addVQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addVU</b></font></td><td width="33%"><font size="+1"><b>VD_addVU</b></font></td><td><font size="+1"><b>VE_addVU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addVUB</b></font></td><td width="33%"><font size="+1"><b>VD_addVUB</b></font></td><td><font size="+1"><b>VE_addVUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addVUS</b></font></td><td width="33%"><font size="+1"><b>VD_addVUS</b></font></td><td><font size="+1"><b>VE_addVUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addVUL</b></font></td><td width="33%"><font size="+1"><b>VD_addVUL</b></font></td><td><font size="+1"><b>VE_addVUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addVUQ</b></font></td><td width="33%"><font size="+1"><b>VD_addVUQ</b></font></td><td><font size="+1"><b>VE_addVUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addVUI</b></font></td><td width="33%"><font size="+1"><b>VD_addVUI</b></font></td><td><font size="+1"><b>VE_addVUI</b></font></td></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Add an integer vector to a floating-point vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_addVI( fVector&nbsp;Z, fVector&nbsp;X, iVector&nbsp;Y,ui&nbsp;size&nbsp;);
<BR>void VF_addVUB( fVector&nbsp;Z, fVector&nbsp;X, ubVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::addVI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;int&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::addVUS( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;unsigned short&gt;&amp;&nbsp;Y,&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_addVI( Z, X:fVector; Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VF_addVUL( Z, X:fVector; Y:ulVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_addVI( fVector&nbsp;d_Z, fVector&nbsp;d_X, iVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVF_addVUB( fVector&nbsp;d_Z, fVector&nbsp;d_X, ubVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>void VFcu_addVI( fVector&nbsp;h_Z, fVector&nbsp;h_X, iVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFcu_addVUB( fVector&nbsp;h_Z, fVector&nbsp;h_X, ubVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_addVI( d_Z, d_X:fVector; d_Y:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_addVUL( d_Z, d_X:fVector; d_Y:ulVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_addVI( h_Z, h_X:fVector; h_Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VFcu_addVUL( h_Z, h_X:fVector; h_Y:ulVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = X<sub>i</sub> + Y<sub>i</sub>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#accV">VF_accV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="add2V"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_add2V</b></font></td><td width="33%"><font size="+1"><b>VD_add2V</b></font></td><td><font size="+1"><b>VE_add2V</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Add three vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_add2V( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y1, fVector&nbsp;Y2, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::add2V( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y1, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y2&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_add2V( Z, X, Y1, Y2:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_add2V( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y1, fVector&nbsp;d_Y2, ui&nbsp;size&nbsp;);
<BR>void VFcu_add2V( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y1, fVector&nbsp;h_Y2, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_add2V( d_Z, d_X,&nbsp;d_Y1, d_Y2:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_add2V( h_Z, h_X, h_Y1, h_Y2:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = X<sub>i</sub> + Y1<sub>i</sub> + Y2<sub>i</sub>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#sub2V">VF_sub2V</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="and"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_and</b></font></td><td width="17%"><font size="+1"><b>VBI_and</b></font></td><td width="17%"><font size="+1"><b>VSI_and</b></font></td><td width="17%"><font size="+1"><b>VLI_and</b></font></td><td width="17%"><font size="+1"><b>VQI_and</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_and</b></font></td><td width="17%"><font size="+1"><b>VUB_and</b></font></td><td width="17%"><font size="+1"><b>VUS_and</b></font></td><td width="17%"><font size="+1"><b>VUL_and</b></font></td><td width="17%"><font size="+1"><b>VUQ_and</b></font></td><td><font size="+1"><b>VUI_and</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Bit-wise AND operation.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_and( iVector&nbsp;Y, iVector&nbsp;X, ui&nbsp;size, int&nbsp;C&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::and( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_and( Y,&nbsp;X:iVector; size:UIntSize; C:Integer&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVImath.h&gt;
<BR>int cudaVI_and( iVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size, int&nbsp;C&nbsp;);
<BR>int cusdVI_and( iVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size, int&nbsp;*d_C&nbsp;);
<BR>void VIcu_and( iVector&nbsp;h_Y, iVector&nbsp;h_X, ui&nbsp;size, int&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>function cudaVI_and( d_Y, d_X:iVector; size:UIntSize; C:Integer&nbsp;):&nbsp;IntBool;
<BR>function cusdVI_and( d_Y, d_X:iVector; size:UIntSize; d_C:PInteger&nbsp;):&nbsp;IntBool;
<BR>procedure VIcu_and( h_Y, h_X:iVector; size:UIntSize; C:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = (X<sub>i</sub>) &amp;&nbsp;C
<BR>The bit-wise AND operation is performed on each element X<sub>i</sub> with the bit-mask given by C. A bit is 1 in Y<sub>i</sub>, if it was 1 both in X<sub>i</sub> and in C, and 0 otherwise. Perhaps the most useful application of this family of functions is the fast &quot;modulo&quot; operation on unsigned or positive numbers with the modulus being an integer power of 2. For example, a modulo division by 64 is performed by
<BR><I>VU_and</I>( Y, X, size, 64-1&nbsp;);</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#not">VI_not</a>,&nbsp;&nbsp; <a href="#or">VI_or</a>,&nbsp;&nbsp; <a href="#xor">VI_xor</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="arg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_arg</b></font></td><td width="33%"><font size="+1"><b>VCD_arg</b></font></td><td><font size="+1"><b>VCE_arg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_arg</b></font></td><td width="33%"><font size="+1"><b>VPD_arg</b></font></td><td><font size="+1"><b>VPE_arg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Argument (angle in polar coordinates).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VCF_arg( fVector&nbsp;Arg, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::arg( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_arg( Arg:fVector; X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_arg( fVector&nbsp;d_Arg, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VCFcu_arg( fVector&nbsp;h_Arg, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_arg( d_Arg:fVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VCFcu_arg( h_Arg:fVector; h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Identical to <I><a href="#CtoArg">VF_CtoArg</a>,&nbsp;&nbsp; <a href="#CtoArg">VD_CtoArg</a>,&nbsp;&nbsp; <a href="#CtoArg">VE_CtoArg</a></I>, resp. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ArgtoP"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ArgtoP</b></font></td><td width="33%"><font size="+1"><b>VD_ArgtoP</b></font></td><td><font size="+1"><b>VE_ArgtoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Overwrite the Arg part of a polar complex vector with a real vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_ArgtoP( pfVector&nbsp;Y, fVector&nbsp;Arg, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::ArgtoP( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Arg&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_ArgtoP( X:pfVector; Arg:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_ArgtoP( pfVector&nbsp;d_Y, fVector&nbsp;d_Arg, ui&nbsp;size&nbsp;);
<BR>void VFcu_ArgtoP( pfVector&nbsp;h_Y, fVector&nbsp;h_Arg, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_ArgtoP( d_X:pfVector; d_Arg:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_ArgtoP( h_X:pfVector; h_Arg:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The Arg part of the polar complex vector Y is overwritten with the elements of the real-valued vector Arg. The Mag part of Y is not affected.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoMagArg">VF_PtoMagArg</a>,&nbsp;&nbsp; <a href="#MagArgtoP">VF_MagArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="asin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_asin</b></font></td><td width="33%"><font size="+1"><b>VD_asin</b></font></td><td><font size="+1"><b>VE_asin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_asin</b></font></td><td width="33%"><font size="+1"><b>VCD_asin</b></font></td><td><font size="+1"><b>VCE_asin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_asin</b></font></td><td width="33%"><font size="+1"><b>VDx_asin</b></font></td><td><font size="+1"><b>VEx_asin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_asin</b></font></td><td width="33%"><font size="+1"><b>VCDx_asin</b></font></td><td><font size="+1"><b>VCEx_asin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>arcus sinus function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_asin( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_asin( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::asin( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_asin( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_asin( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_asin( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_asin( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_asin( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_asin( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_asin( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_asin( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_asin( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_asin( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_asin( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_asin( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_asin( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = arcsin ( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;arcsin (A*X<sub>i</sub> + B&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real versions: DOMAIN errors occur for arguments outside the range -1 &lt;= X<sub>i</sub> &lt;= +1; the default result is NAN (&quot;not-a-number&quot;).
<BR>The complex versions should be error-proof as long as the parameter C in the expanded versions is not already near the OVERFLOW limit; this very rare error is either detected nor handled.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#acos">VF_acos</a>,&nbsp;&nbsp; <a href="#atan">VF_atan</a>,&nbsp;&nbsp; asin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="atan"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_atan</b></font></td><td width="33%"><font size="+1"><b>VD_atan</b></font></td><td><font size="+1"><b>VE_atan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_atan</b></font></td><td width="33%"><font size="+1"><b>VCD_atan</b></font></td><td><font size="+1"><b>VCE_atan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_atan</b></font></td><td width="33%"><font size="+1"><b>VDx_atan</b></font></td><td><font size="+1"><b>VEx_atan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_atan</b></font></td><td width="33%"><font size="+1"><b>VCDx_atan</b></font></td><td><font size="+1"><b>VCEx_atan</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>arcus tangens function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_atan( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_atan( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::atan( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_atan( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_atan( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_atan( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_atan( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_atan( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_atan( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_atan( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_atan( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_atan( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_atan( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_atan( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_atan( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_atan( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = arctan ( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;arctan (A*X<sub>i</sub> + B&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>The real versions should be error-proof as long as the parameter C in the expanded versions is not already near the OVERFLOW limit; this very rare error is neither detected nor handled.
<BR>In the complex versions, the result for an argument of {0, -1} is set to {0, -<font face="symbol">p</font>} without notice (and without the program crash resulting in Borland C++ from calling the complex <I>atan</I> with this argument).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tan">VF_tan</a>,&nbsp;&nbsp; <a href="#asin">VF_asin</a>,&nbsp;&nbsp; <a href="#acos">VF_acos</a>,&nbsp;&nbsp; <a href="#atan2">VF_atan2</a>,&nbsp;&nbsp; atan,&nbsp;&nbsp; atan2</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="atan2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_atan2</b></font></td><td width="33%"><font size="+1"><b>VD_atan2</b></font></td><td><font size="+1"><b>VE_atan2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_atan2</b></font></td><td width="33%"><font size="+1"><b>VDx_atan2</b></font></td><td><font size="+1"><b>VEx_atan2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>arcus tangens function of quotients</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_atan2( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>int VFx_atan2( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::atan2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>int vector&lt;T&gt;::x_atan2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_atan2( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_atan2( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_atan2( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_atan2( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_atan2( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_atan2( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);
<BR>int VFxcu_atan2( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_atan2( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_atan2( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_atan2( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_atan2( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_atan2( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = arctan( Y<sub>i</sub> / X<sub>i</sub>&nbsp;)
<BR>expanded versions: Z<sub>i</sub> = C *&nbsp;arctan( Y<sub>i</sub> / (A*X<sub>i</sub>+B)&nbsp;) 
<BR>From Cartesian X -Y-coordinates, the angle of the corresponding polar coordinates is calculated.
<BR>Note: in comparison to the ANSI C function atan2, the ordering of the parameters X and Y is reversed.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If X<sub>i</sub> and Y<sub>i</sub> are both zero, a DOMAIN error results with the default result NAN (&quot;not-a-number&quot;).
<BR>In C/C++, this error is handled by <I>_matherr</I> and <I>_matherrl</I> with X<sub>i</sub> and Y<sub>i</sub> as e-&gt;x and e-&gt;y.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tan">VF_tan</a>,&nbsp;&nbsp; <a href="#asin">VF_asin</a>,&nbsp;&nbsp; <a href="#acos">VF_acos</a>,&nbsp;&nbsp; <a href="#atan">VF_atan</a>,&nbsp;&nbsp;atan,&nbsp;&nbsp;atan2</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="autocorr"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_autocorr</b></font></td><td width="33%"><font size="+1"><b>VD_autocorr</b></font></td><td><font size="+1"><b>VE_autocorr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>autocorrelation function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_autocorr( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;float&gt;::autocorr( const&nbsp;vector&lt;float&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_autocorr( Y,&nbsp;X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_autocorr( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_autocorr( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_autocorr( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_autocorr( h_Y, h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The autocorrelation function (ACF) of X is calculated and stored in Y in wrap-around order: Y<sub>0</sub> to Y<sub>size/2-1</sub> contain the ACF for zero and positive lags. Beginning with the most negative lag in Y<sub>size/2+1</sub>, the elements up to Y<sub>size-1</sub> contain the ACF for negative lags. Since this function assumes X to be periodic, the ACF for the most positive lag is identical to the ACF for the most negative lag. This element is stored as Y<sub>size/2</sub>.
<BR>To get the ACF into normal order, you may call
<BR><font face="courier new"><a href="#rotate">VF_rotate</a>( Y, Y, size, size/2&nbsp;);</font>
<BR>After that, the zero point is at the position size/2.
<P>In case X is non-periodic, you should avoid end effects by the methods described in connection with <I><a href="#convolve">VF_convolve</a></I>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_autocorr</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="autoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_autoPlot</b></font></td><td width="33%"><font size="+1"><b>VCD_autoPlot</b></font></td><td><font size="+1"><b>VCE_autoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Automatic plot of a complex vector into a Cartesian complex plane.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VCF_autoPlot( cfVector&nbsp;X, ui&nbsp;size, unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::autoPlot( unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VCF_autoPlot( X:cfVector; size:UIntSize; form:UInt; color:COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian complex plane is drawn with the axes automatically scaled and the vector X plotted into it. For a description of the parameters form and color, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. The plotting routines have to be initialized by <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I> prior to calling <I>VCF_autoPlot</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#c2AutoPlot">VCF_2AutoPlot</a>,&nbsp;&nbsp; <a href="#dataPlot">VCF_dataPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="c2AutoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VCD_2AutoPlot</b></font></td><td><font size="+1"><b>VCE_2AutoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Automatic plot of two complex vectors into a Cartesian complex plane.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VCF_2AutoPlot( cfVector&nbsp;X1, ui&nbsp;size1, unsigned form1, COLORREF color1, cfVector&nbsp;X2, ui&nbsp;size2, unsigned form2, COLORREF color2&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::_2AutoPlot( unsigned form1, COLORREF color1, 
const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X2, unsigned form2, COLORREF color2&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VCF_2AutoPlot( X1:cfVector; size1:UIntSize; form1:UInt; color1:COLORREF; X2:cfVector; size2:UIntSize; form2:UInt; color2:COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian complex plane is drawn with the axes automatically scaled and the vectors X1 and X2 plotted into it. For a description of the parameters form1, form2, color1, and color2, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. The plotting routines have to be initialized by <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I> prior to calling <I>VCF_2AutoPlot</I>.
<BR>Note the leading underbar in the <I>VecObj</I> function. (It is necessary, as C/C++ does not allow function names to begin with a number.)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#dataPlot">VCF_dataPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.11</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="avdevC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_avdevC</b></font></td><td width="33%"><font size="+1"><b>VD_avdevC</b></font></td><td><font size="+1"><b>VE_avdevC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>average deviation from a preset value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_avdevC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::avdevC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_avdevC( X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_avdevC( float *h_RetVal, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_avdevC( float *d_RetVal, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>float VFcu_avdevC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_avdevC( var h_RetVal:Single; d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_avdevC( d_RetVal:PSingle; d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_avdevC( h_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>avdevC = 1/size *&nbsp;sum( |X<sub>i</sub> - C|&nbsp;)
<BR>The average of the absolute deviation of each element of X from C is calculated and returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>average deviation.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#avdevV">VF_avdevV</a>,&nbsp;&nbsp; <a href="#sumdevC">VF_sumdevC</a>,&nbsp;&nbsp; <a href="#chiabs">VF_chiabs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="avdevV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_avdevV</b></font></td><td width="33%"><font size="+1"><b>VD_avdevV</b></font></td><td><font size="+1"><b>VE_avdevV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>average deviation of the elements of one vector from the corresponding elements of another vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_avdevV( fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::avdevV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_avdevV( X,&nbsp;Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_avdevV( float *h_RetVal, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>int cusdVF_avdevV( float *d_RetVal, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>float VFcu_avdevV( fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_avdevV( var h_RetVal:Single; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_avdevV( d_RetVal:PSingle; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_avdevC( h_X, h_Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>avdevV = 1/size *&nbsp;sum( |X<sub>i</sub> - Y<sub>i</sub>|&nbsp;)
<BR>The average of the absolute deviation of each element of X from the corresponding element of Y is calculated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>average deviation.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevV">VF_ssqdevV</a>,&nbsp;&nbsp; <a href="#avdevC">VF_avdevC</a>,&nbsp;&nbsp; <a href="#sumdevV">VF_sumdevV</a>,&nbsp;&nbsp; <a href="#chiabs">VF_chiabs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="biquad"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_biquad</b></font></td><td width="33%"><font size="+1"><b>VD_biquad</b></font></td><td><font size="+1"><b>VE_biquad</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Biquadratic filtering</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_biquad( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, fVector&nbsp;Param&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::biquad( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Param,&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_biquad( Y,X:fVector; size:UIntSize; Param:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_biquad( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;h_Param&nbsp;);
<BR>int cusdVF_biquad( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;d_Param&nbsp;);
<BR>float VFcu_biquad( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, fVector&nbsp;h_Param&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_biquad( d_Y, d_X:fVector; size:UIntSize; h_Param:fVector&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_biquad( d_Y, d_X:fVector; size:UIntSize; d_Param:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_biquad( h_Y, h_X:fVector; size:UIntSize; h_Param:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A bi-quadratic filter, used mostly in audio data processing, calculates output from input values according to the formula:<br>
Y[i] = a0*X[i] + a1*X[i-1] + a2*X[i-2] - b1*Y[i-1] - b2*Y[i-2]<br>
As this is a recursive filter, the function needs not only the filter coefficients themselves, but also the two input and two output values preceding the data passed in the input vector. All these values are passed to <i>VF_biquad</i> in the vector Param, containing nine entries:<br>
Param[0]=a0
Param[1]=a1
Param[2]=a2 
Param[3]=b1
Param[4]=b2
Param[5]=X[-1]
Param[6]=X[-2]
Param[7]=Y[-1]
Param[8]=Y[-2]
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#filter">VF_filter</a>,&nbsp;&nbsp; <a href="#smooth">VF_smooth</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cabsmax"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cabsmax</b></font></td><td width="33%"><font size="+1"><b>VCD_cabsmax</b></font></td><td><font size="+1"><b>VCE_cabsmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Element of largest absolute value within one vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_cabsmax( cfVector&nbsp;X, ui&nbsp;size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;complex&lt;T&gt;&gt;::cabsmax();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function VCF_cabsmax( X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
<BR>Alternative syntax (obsolete, but still supported):<font face="courier new">
<BR>procedure VCF_cabsmax( var RetVal:fComplex; X:cfVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_cabsmax( fComplex *h_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVCF_cabsmax( fComplex *d_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>fComplex VCFcu_cabsmax( cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_cabsmax( var h_RetVal:fComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVCF_cabsmax( d_RetVal:PfComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VCFcu_cabsmax( h_X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a cartesian-complex vector are compared and the element with the largest absolute value is returned. A variant of this function, finding the largest element in terms of the sum |Re|&nbsp;+&nbsp;|Im|, is offered by <I><a href="#sabsmax">VCF_sabsmax</a></I>. The latter function is much faster than <I>VCF_cabsmax</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>largest element in terms of absolute value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#absmax">VCF_absmax</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a>,&nbsp;&nbsp; <a href="#sabsmax">VCF_sabsmax</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cabsmin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cabsmin</b></font></td><td width="33%"><font size="+1"><b>VCD_cabsmin</b></font></td><td><font size="+1"><b>VCE_cabsmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Element of smallest absolute value within one vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_cabsmin( cfVector&nbsp;X, ui&nbsp;size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;complex&lt;T&gt;&gt;::cabsmin();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function VCF_cabsmin( X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
<BR>Alternative syntax (obsolete, but still supported):<font face="courier new">
<BR>procedure VCF_cabsmin( var RetVal:fComplex; X:cfVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_cabsmin( fComplex *h_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVCF_cabsmin( fComplex *d_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>fComplex VCFcu_cabsmin( cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_cabsmin( var h_RetVal:fComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVCF_cabsmin( d_RetVal:PfComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VCFcu_cabsmin( h_X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a cartesian-complex vector are compared and the element with the smallest absolute value is returned. A variant of this function, finding the smallest element in terms of the sum |Re|&nbsp;+&nbsp;|Im|, is offered by <I><a href="#sabsmin">VCF_sabsmin</a></I>. The latter function is much faster than <I>VCF_cabsmin</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>smallest element in terms of absolute value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#absmin">VCF_absmin</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a>,&nbsp;&nbsp; <a href="#sabsmin">VCF_sabsmin</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CDtoCF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_CDtoCF</b></font></td><td><font size="+1"><b>V_CDtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_CEtoCF</b></font></td><td><font size="+1"><b>V_CEtoCD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_CFtoCD</b></font></td><td><font size="+1"><b>V_CFtoCE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type conversions. See <I><a href="#FtoD">V_FtoD</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ceil"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceil</b></font></td><td width="33%"><font size="+1"><b>VD_ceil</b></font></td><td><font size="+1"><b>VE_ceil</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoI</b></font></td><td><font size="+1"><b>VE_ceiltoI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoBI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoBI</b></font></td><td><font size="+1"><b>VE_ceiltoBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoSI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoSI</b></font></td><td><font size="+1"><b>VE_ceiltoSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoLI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoLI</b></font></td><td><font size="+1"><b>VE_ceiltoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoQI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoQI</b></font></td><td><font size="+1"><b>VE_ceiltoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoU</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoU</b></font></td><td><font size="+1"><b>VE_ceiltoU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoUB</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoUB</b></font></td><td><font size="+1"><b>VE_ceiltoUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoUS</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoUS</b></font></td><td><font size="+1"><b>VE_ceiltoUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoUL</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoUL</b></font></td><td><font size="+1"><b>VE_ceiltoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoUQ</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoUQ</b></font></td><td><font size="+1"><b>VE_ceiltoUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoUI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoUI</b></font></td><td><font size="+1"><b>VE_ceiltoUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Rounding to the next whole number that is greater or equal.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ceil( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VF_ceiltoI( iVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VF_ceiltoLI( liVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ceil( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;int&gt;::ceiltoI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;long&gt;::ceiltoLI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_ceil( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VF_ceiltoI( Y:iVector; X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VF_ceiltoLI( Y:liVector; X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_ceil( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVF_ceiltoI( iVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_ceil( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_ceiltoI( iVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_ceil( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_ceiltoI( d_Y:iVector; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_ceil( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_ceiltoI( h_Y:iVector; h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is rounded to the nearest whole number that is greater than or equal to the input number and the result stored in Y. The functions <I>VF_ceiltoI,&nbsp;&nbsp; VF_ceiltoLI,&nbsp;&nbsp; VF_ceiltoU</I> etc. convert the result into the various integer data types (in the cases mentioned, to int, long int, and unsigned, resp.).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors are handled by setting the result to the extreme value possible. Negative numbers in the versions <I>VF_ceiltoU,&nbsp;&nbsp; VF_ceiltoUS,&nbsp;&nbsp; VF_ceiltoUL</I>, and <I>VF_ceiltoUI</I> lead to DOMAIN errors; they are handled by setting the result to 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#round">VF_round</a>,&nbsp;&nbsp; <a href="#floor">VF_floor</a>,&nbsp;&nbsp; <a href="#chop">VF_chop</a>,&nbsp;&nbsp; <a href="#trunc">VF_trunc</a>,&nbsp;&nbsp; ceil,&nbsp;&nbsp; floor</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="COGI"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_centerOfGravityInd</b></font></td><td width="33%"><font size="+1"><b>VD_centerOfGravityInd</b></font></td><td><font size="+1"><b>VE_centerOfGravityInd</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Center of Gravity of an array, assuming its indices as the abscissa</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_centerOfGravityInd( fVector&nbsp;X, ui&nbsp;siz&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::centerOfGravityInd();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_centerOfGravityInd( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_centerOfGravityInd( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;siz&nbsp;);
<BR>int cusdVF_centerOfGravityInd( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;siz&nbsp;);
<BR>float VFcu_centerOfGravityInd( fVector&nbsp;h_X, ui&nbsp;siz&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_centerOfGravityInd( var h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_centerOfGravityInd( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_centerOfGravityInd( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The center of gravity of the vector X is calculated according to the formula:<br>
COG = sum( X<sub>i</sub> *&nbsp;i ) / sum( X<sub>i</sub> ).<br>
It is assumed that the values of X represent point masses, situated at the positions given by their indices. The center of gravity is returned as a real number, as it will normally fall in between of two adjacent indices. If all elements of X are 0, there is no mass and no gravity; nevertheless, the center of gravity is assumed as the mid-point of X, i.e. (size-1)&nbsp;/&nbsp;2.
<BR>To calculate the center of gravity of a vector over an abscissa explicitly given (rather than over its indices), call  <I><a href="#COGV">VF_centerOfGravityV</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The position of the  center of gravity is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#COGV">VF_centerOfGravityV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="COGV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_centerOfGravityV</b></font></td><td width="33%"><font size="+1"><b>VD_centerOfGravityV</b></font></td><td><font size="+1"><b>VE_centerOfGravityV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Center of Gravity of an array over an explicitly given abscissa</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_centerOfGravityV( fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::centerOfGravityV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_centerOfGravityV( X,&nbsp;Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_centerOfGravityV( float&nbsp;*h_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;siz&nbsp;);
<BR>int cusdVF_centerOfGravityV( float&nbsp;*d_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;siz&nbsp;);
<BR>float VFcu_centerOfGravityV( fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;siz&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_centerOfGravityV( var h_RetVal:Single; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_centerOfGravityV( d_RetVal:PSingle; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_centerOfGravityV( h_X,&nbsp;h_Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The center of gravity of the vector Y = f(X) is calculated according to the formula:<br>
COG = sum( Y<sub>i</sub> *&nbsp;X<sub>i</sub> ) / sum( Y<sub>i</sub> ).<br>
It is assumed that the values of Y represent point masses, situated at the positions given by X. If all elements of X are 0, there is no mass and no gravity; nevertheless, the center of gravity is assumed as the mid-point of X, i.e. (X[size-1] - X[0])&nbsp;/&nbsp;2.
<BR>To calculate the center of gravity of a vector over its indices as the abscissa, call  <I><a href="#COGI">VF_centerOfGravityInd</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The (interpolated) position of the  center of gravity on the X axis is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#COGI">VF_centerOfGravityInd</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="checkBoundaries"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_checkBoundaries</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Check vector / matrix and associated size parameters for dimension consistency</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Veclib.h&gt;
<BR>void V_checkBoundaries( void *X, ui&nbsp;size, int&nbsp;FlagRW, char *funcname&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Veclib;
<BR>procedure V_checkBoundaries( X:Pointer; size:UIntSize; FlagRW:Integer; funcname:PChar&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The single-most frequent cause of hard-to-find errors in vector and matrix calculations is dimension mismatch, leading to violations of the vector or matrix boundaries. The resulting corruption of the heap, in turn, usually leads to problems and crashes much later in the program flow, so that it is very difficult to identify the origin of the problem. This is the reason why we developed the dimension-checking debug libraries (VCF4WD.LIB for Borland / CodeGear C++,  OVVC4D.LIB for Visual C++,  units in LIB4D for Delphi). In these debug libraries, every vector or matrix function of <i>OptiVec</i> calls <i>V_checkBoundaries</i> in order to assert dimension consistency. <i>V_checkBoundaries</i> checks if the allocated size of X is enough for the parameter <i>size</i> which was passed to the respective function. If any irregularity is detected, error and/or warning messages are generated. Thereby, it is made much easier to track and locate the offending code.
<BR>Although the primary purpose of this function is its internal use inside the debug libraries of <i>OptiVec</i>, you may call this function also from your own routines for consistency checks.
<P>Input parameters of <i>V_checkBoundaries</i>:
<table width="100%"><tr valign="TOP"><td width="10%">X</td><td>The definition as a generalized pointer (<font face="courier new">void *</font> in C/C++,  <font face="courier new">Pointer</font> in Pascal/Delphi) means that this function will accept any vector or matrix, regardless of type.</td></tr>
<tr valign="TOP"><td>size</td><td>The size in bytes, up to which the respective vector / matrix will be read or written</td></tr>
<tr valign="TOP"><td>FlagRW</td><td>Bit 0 of this flag indicates read (0) or write (1). If both read and write will occur for the same vector, write (1) is signaled.<BR>Bit 1 indicates if X is a vector (0) or a matrix (1).
<BR>E.g., a vector that will be read only is signaled by FlagRW = 0, &nbsp;a matrix that will be written is signaled by FlagRW=2+1.</td></tr>
<tr valign="TOP"><td>funcname</td><td>A string, containing the name of the function under scrutiny</td></tr></table>&nbsp;
<BR><i>V_checkBoundaries</i> identifies the following types of problems and takes the appropriate measures:
<table border width="100%"><tr valign="TOP"><td width="20%">Detected problem</td><td width="60%">Error message</td><td>Further measures</td></tr>
<tr valign="TOP"><td>X = NULL or <b>nil</b></td><td><i>FuncName</i>: read / write at address 0000.</td><td>Program execution is immediately halted to avoid further damage.</td></tr>
<tr valign="TOP"><td>size = 0</td><td><i>FuncName</i>: Function called with size = 0 (must be &gt;= 1)</td><td>Program execution is immediately halted to avoid further damage.</td></tr>
<tr valign="TOP"><td>size &gt; VectorSize</td><td><i>FuncName</i>: Boundary violation: vector / matrix starting at <i>StartAddress</i>, ending at <i>EndAddress</i>, is read / written up to <i>OffendingAddress</i>.</td><td>Program execution is continued.</td></tr>
<tr valign="TOP"><td>X is a subvector, and size &gt; RemainingVectorSize</td><td><i>FuncName</i>: Boundary violation: subvector / submatrix <i>StartAddress</i> of <i>BasicAddress</i>, ending at <i>EndAddress</i>, is read / written up to <i>OffendingAddress</i>.</td><td>Program execution is continued.</td></tr>
<tr valign="TOP"><td>X not allocated as <i>OptiVec</i> vector / matrix</td><td><i>FuncName</i>: Warning: read / write of unallocated or non-OptiVec vector <i>StartAddress</i></td><td>Program execution is continued.</td></tr></table>&nbsp;
<BR>In case you have to use static arrays (or arrays dynamic allocated with <i>malloc</i> or the Windows API memory functions) and do not want to see the latter warning message, you may call 
<BR><font face="courier new">V_setBoundaryCheckWarn( 0 );</font> &nbsp;(C/C++) or 
<BR><font face="courier new">V_setBoundaryCheckWarn( FALSE );</font>  &nbsp;(Pascal / Delphi).
<BR>This will switch off only the described <u>warning</u> messages. It does not affect the <u>error</u> messages.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setBoundaryCheckWarn">V_setBoundaryCheckWarn</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="chiabs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_chiabs</b></font></td><td width="33%"><font size="+1"><b>VD_chiabs</b></font></td><td><font size="+1"><b>VE_chiabs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Absolute-value analogue of the chi-square merit function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_chiabs( fVector&nbsp;X, fVector&nbsp;Y, fVector&nbsp;Wt, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::chiabs( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Wt&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_chiabs( X, Y, Wt:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_chiabs( float&nbsp;*h_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, fVector&nbsp;d_Wt, ui&nbsp;size&nbsp;);
<BR>int cusdVF_chiabs( float&nbsp;*d_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, fVector&nbsp;d_Wt, ui&nbsp;size&nbsp;);
<BR>float VFcu_chiabs( fVector&nbsp;h_X, fVector&nbsp;h_Y, fVector&nbsp;h_Wt, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_chiabs( var h_RetVal:Single; d_X,&nbsp;d_Y,&nbsp;d_Wt:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_chiabs( d_RetVal:PSingle; d_X,&nbsp;d_Y,&nbsp;d_Wt:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_chiabs( h_X,&nbsp;h_Y,&nbsp;h_Wt:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>chiabs = sum( Wt<sub>i</sub> *&nbsp;|X<sub>i</sub> - Y<sub>i</sub>|&nbsp;).
<BR>The chiabs function is a &quot;robust&quot; replacement for the <font face="symbol">c</font><sup>2</sup> (chi-square) merit function. It is used to judge the quality of a fit in the presence of outlier points. The chiabs function is disturbed by outlier points to a lesser degree than the chi-square function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>chiabs merit function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#chi2">VF_chi2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="chi2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_chi2</b></font></td><td width="33%"><font size="+1"><b>VD_chi2</b></font></td><td><font size="+1"><b>VE_chi2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Chi-square merit function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_chi2( fVector&nbsp;X, fVector&nbsp;Y, fVector&nbsp;InvVar, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::chi2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;InvVar&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_chi2( X, Y, InvVar:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_chi2( float&nbsp;*h_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, fVector&nbsp;d_InvVar, ui&nbsp;size&nbsp;);
<BR>int cusdVF_chi2( float&nbsp;*d_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, fVector&nbsp;d_InvVar, ui&nbsp;size&nbsp;);
<BR>float VFcu_chi2( fVector&nbsp;h_X, fVector&nbsp;h_Y, fVector&nbsp;h_InvVar, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_chi2( var h_RetVal:Single; d_X,&nbsp;d_Y,&nbsp;d_InvVar:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_chi2( d_RetVal:PSingle; d_X,&nbsp;d_Y,&nbsp;d_InvVar:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_chi2( h_X,&nbsp;h_Y,&nbsp;h_InvVar:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><font face="symbol">c</font><sup>2</sup> = sum( 1/<font face="symbol">s</font><sub>i</sub><sup>2</sup> *&nbsp;(X<sub>i</sub> - Y<sub>i</sub>)<sup>2</sup>&nbsp;).
<BR>The <font face="symbol">c</font><sup>2</sup> (chi-square) merit function is most often used to judge the quality of a fit. One vector (either X or Y) represents experimental values that are obtained with individual standard deviations sigma<sub>i</sub>, the other contains the values predicted on the basis of a theory or a model. If the experimental data are &quot;normally&quot; distributed, and if <font face="symbol">s</font> (sigma) is the correct measure for the quality of these data, then <font face="symbol">c</font><sup>2</sup> is a measure for the quality of the fit. Rather than the standard deviations themselves, the routine needs the inverse of their squares (i.e., the inverse of the variances) to be passed as the vector InvVar.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>chi<sup>2</sup> merit function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#varianceVwW">VF_varianceVwW</a>,&nbsp;&nbsp; <a href="#varianceV">VF_varianceV</a>,&nbsp;&nbsp; <a href="#varianceCwW">VF_varianceCwW</a></I>,
&nbsp;&nbsp;<I><a href="#chiabs">VF_chiabs</a>,&nbsp;&nbsp; <a href="#square">VF_square</a>,&nbsp;&nbsp; <a href="#inv">VF_inv</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="chop"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_chop</b></font></td><td width="33%"><font size="+1"><b>VD_chop</b></font></td><td><font size="+1"><b>VE_chop</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoI</b></font></td><td><font size="+1"><b>VE_choptoI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoBI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoBI</b></font></td><td><font size="+1"><b>VE_choptoBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoSI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoSI</b></font></td><td><font size="+1"><b>VE_choptoSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoLI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoLI</b></font></td><td><font size="+1"><b>VE_choptoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoQI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoQI</b></font></td><td><font size="+1"><b>VE_choptoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoU</b></font></td><td width="33%"><font size="+1"><b>VD_choptoU</b></font></td><td><font size="+1"><b>VE_choptoU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoUB</b></font></td><td width="33%"><font size="+1"><b>VD_choptoUB</b></font></td><td><font size="+1"><b>VE_choptoUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoUS</b></font></td><td width="33%"><font size="+1"><b>VD_choptoUS</b></font></td><td><font size="+1"><b>VE_choptoUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoUL</b></font></td><td width="33%"><font size="+1"><b>VD_choptoUL</b></font></td><td><font size="+1"><b>VE_choptoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoUQ</b></font></td><td width="33%"><font size="+1"><b>VD_choptoUQ</b></font></td><td><font size="+1"><b>VE_choptoUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoUI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoUI</b></font></td><td><font size="+1"><b>VE_choptoUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Chopping&quot; towards zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_chop( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VF_choptoI( iVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VF_choptoLI( liVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::chop( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;int&gt;::choptoI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;long&gt;::choptoLI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_chop( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VF_choptoI( Y:iVector; X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VF_choptoLI( Y:liVector; X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_chop( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVF_choptoI( iVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_chop( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_choptoI( iVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_chop( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_choptoI( d_Y:iVector; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_chop( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_choptoI( h_Y:iVector; h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is rounded to an integer number by &quot;chopping off&quot; the fractional part. For example, -3.9 yields -3, and +3.9 yields +3. The result is stored in Y. The functions <I>VF_choptoI,&nbsp;&nbsp; VF_choptoLI</I>, etc. convert the result into the various integer data types.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors are handled by setting the result to the extreme value possible. Negative numbers in the versions <I>VF_choptoU,&nbsp;&nbsp; VF_choptoUS,&nbsp;&nbsp; VF_choptoUL</I>, and <I>VF_choptoUI</I> lead to DOMAIN errors; they are handled by setting the result to 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#round">VF_round</a>,&nbsp;&nbsp; <a href="#floor">VF_floor</a>,&nbsp;&nbsp; <a href="#ceil">VF_ceil</a>,&nbsp;&nbsp; ceil,&nbsp;&nbsp; floor</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="closeErrorEventFile"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_closeErrorEventFile</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Restore default printing of error messages into <I>stderr</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_closeErrorEventFile( void&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_closeErrorEventFile;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>After error messages have been redirected into an event file by <I><a href="#setErrorEventFile">V_setErrorEventFile</a></I>, the event file is closed by <I>V_closeErrorEventFile</I> and any further messages will be handled according to the parameter <i>ScreenAndFile</i> with which the event file was created (0: no message at all; 1: message box; 2: for console programmes, output into <I>stderr</I> which normally is the screen, see <a href="HANDBOOK.HTM#chap5_5">chapter&nbsp;5.5</a>). Both of these functions will not be included in versions of <I>VectorLib</I> for compilers that do already offer the possibility of printing error messages simultaneously to the screen and to an event file.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#noteError">V_noteError</a>,&nbsp;&nbsp; <a href="#setErrorEventFile">V_setErrorEventFile</a>,&nbsp;&nbsp; _matherr</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="closeMT"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_closeMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Close down the worker threads of the multi-processor optimized library</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>int  V_closeMT( void&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function V_closeMT: IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function terminates the worker threads initialized by <I><a href="#initMT">V_initMT</a></I>. The call to <i>V_closeMT</i> should be at the end of any programme using the multi-processor libraries of <i>OptiVec</i>. No call to a vector or matrix function fo <i>OptiVec</i> is allowed to follow the closing-down of the worker threads.
<BR>To facilitate testing of the various <i>OptiVec</i>library versions, <i>V_closeMT</i> is present as an empty function also in the (non-threaded) general-purpose libraries. Calling it just does not have any effect then.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if the threads could be shut down error-free, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#initMT">V_initMT</a></I>, <a href="HANDBOOK.HTM#chap1_1_2">chap.&nbsp;1.1.2.</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cmp0"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cmp0</b></font></td><td width="33%"><font size="+1"><b>VD_cmp0</b></font></td><td><font size="+1"><b>VE_cmp0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_cmp0</b></font></td><td width="20%"><font size="+1"><b>VBI_cmp0</b></font></td><td width="20%"><font size="+1"><b>VSI_cmp0</b></font></td><td width="20%"><font size="+1"><b>VLI_cmp0</b></font></td><td><font size="+1"><b>VQI_cmp0</b></font></td></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compares each element of a vector with 0 (signum function).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_cmp0( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::cmp0( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_cmp0( Y,X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cmp0( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_cmp0( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cmp0( d_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_cmp0( h_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is compared with 0 and the result of the comparison stored in Y:
<BR>Y<sub>i</sub> = +1.0, if X<sub>i</sub> &gt; 0
<BR>Y<sub>i</sub> = &nbsp;&nbsp;0.0, if X<sub>i</sub> = 0
<BR>Y<sub>i</sub> = &nbsp;-1.0, if X<sub>i</sub> &lt; 0.
<BR>This function may also be called under its synonym <I><a href="#sgn">VF_sgn</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cmp_">VF_cmp_...</a>,&nbsp;&nbsp; <a href="#cmpC">VF_cmpC</a>,&nbsp;&nbsp; <a href="#cmpV">VF_cmpV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cmpC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cmpC</b></font></td><td width="34%"><font size="+1"><b>VD_cmpC</b></font></td><td><font size="+1"><b>VE_cmpC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_cmpC</b></font></td><td width="17%"><font size="+1"><b>VBI_cmpC</b></font></td><td width="17%"><font size="+1"><b>VSI_cmpC</b></font></td><td width="17%"><font size="+1"><b>VLI_cmpC</b></font></td><td width="17%"><font size="+1"><b>VQI_cmpC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_cmpC</b></font></td><td width="17%"><font size="+1"><b>VUB_cmpC</b></font></td><td width="17%"><font size="+1"><b>VUS_cmpC</b></font></td><td width="17%"><font size="+1"><b>VUL_cmpC</b></font></td><td width="17%"><font size="+1"><b>VUQ_cmpC</b></font></td><td><font size="+1"><b>VUI_cmpC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compares each element of a vector with a constant.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_cmpC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VI_cmpC( iVector&nbsp;Y, iVector&nbsp;X, ui&nbsp;size, int&nbsp;C&nbsp;);
<BR>void VU_cmpC( iVector&nbsp;Y, uVector&nbsp;X, ui&nbsp;size, unsigned&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::cmpC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);</font>
<BR>unsigned integer types: function belongs to corresponding signed integer class:
<BR><font face="courier new">void vector&lt;T&gt;::cmpC( const&nbsp;vector&lt;unsigned T&gt;&amp;&nbsp;X, const&nbsp;unsigned T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_cmpC( Y,X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VI_cmpC( Y,X:iVector; size:UIntSize; C:Integer&nbsp;);
<BR>procedure VU_cmpC( Y:iVector; X:uVector; size:UIntSize; C:UInt&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cmpC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_cmpC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>void VFcu_cmpC( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cmpC( d_Y,&nbsp;d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_cmpC( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_cmpC( h_Y,&nbsp;h_X:fVector; size:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is compared with C and the result of the comparison stored in Y:
<BR>Y<sub>i</sub> = +1.0, if X<sub>i</sub> &gt; C
<BR>Y<sub>i</sub> = &nbsp;&nbsp;0.0, if X<sub>i</sub> = C
<BR>Y<sub>i</sub> = &nbsp;-1.0, if X<sub>i</sub> &lt; C
<BR>For unsigned integer input vectors, the output is of the corresponding signed data type.
<BR>To compare with C=0, use more efficiently the function <I><a href="#cmp0">VF_cmp0</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cmp_">VF_cmp_</a></I>...,&nbsp;&nbsp;<I><a href="#cmp0">VF_cmp0</a>,&nbsp;&nbsp; <a href="#cmpV">VF_cmpV</a>,&nbsp;&nbsp; <a href="#iselementC">VF_iselementC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cmpV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cmpV</b></font></td><td width="34%"><font size="+1"><b>VD_cmpV</b></font></td><td><font size="+1"><b>VE_cmpV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_cmpV</b></font></td><td width="17%"><font size="+1"><b>VBI_cmpV</b></font></td><td width="17%"><font size="+1"><b>VSI_cmpV</b></font></td><td width="17%"><font size="+1"><b>VLI_cmpV</b></font></td><td width="17%"><font size="+1"><b>VQI_cmpV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_cmpV</b></font></td><td width="17%"><font size="+1"><b>VUB_cmpV</b></font></td><td width="17%"><font size="+1"><b>VUS_cmpV</b></font></td><td width="17%"><font size="+1"><b>VUL_cmpV</b></font></td><td width="17%"><font size="+1"><b>VUQ_cmpV</b></font></td><td><font size="+1"><b>VUI_cmpV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compares each element of a vector with the corresponding element of another vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_cmpV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VI_cmpV( iVector&nbsp;Z, iVector&nbsp;X, iVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VU_cmpV( iVector&nbsp;Z, uVector&nbsp;X, uVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::cmpV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font>
<BR>unsigned integer types: function belongs to corresponding signed integer class:
<BR><font face="courier new">void vector&lt;T&gt;::cmpV( const&nbsp;vector&lt;unsigned T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;unsigned T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_cmpV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VI_cmpV( Z, X,&nbsp;Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VU_cmpV( Z:uVector; X,&nbsp;Y:iVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cmpV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>void VFcu_cmpV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cmpV( d_Z,&nbsp;d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_cmpV( h_Z,&nbsp;h_X,&nbsp;h_Y:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is compared with the corresponding element of Y and the result of the comparison stored in Z:
<BR>Z<sub>i</sub> = +1.0, if X<sub>i</sub> &gt; Y<sub>i</sub>
<BR>Z<sub>i</sub> = &nbsp;&nbsp;0.0, if X<sub>i</sub> = Y<sub>i</sub>
<BR>Z<sub>i</sub> = &nbsp;-1.0, if X<sub>i</sub> &lt; Y<sub>i</sub>.
<BR>For unsigned integer input vectors, the output is of the corresponding signed data type.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cmp_">VF_cmp_</a></I>...,&nbsp;&nbsp;<I><a href="#cmp0">VF_cmp0</a>,&nbsp;&nbsp; <a href="#cmpC">VF_cmpC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cmp_"></a><a name="cmp_..."></a>
<table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%">
<tr valign="TOP"><td width="33%"><font size="+1"><b>VF_cmp_...</b></font></td><td width="34%"><font size="+1"><b>VD_cmp_...</b></font></td><td><font size="+1"><b>VE_cmp_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_cmp_...</b></font></td><td width="17%"><font size="+1"><b>VBI_cmp_...</b></font></td><td width="17%"><font size="+1"><b>VSI_cmp_...</b></font></td><td width="17%"><font size="+1"><b>VLI_cmp_...</b></font></td><td width="17%"><font size="+1"><b>VQI_cmp_...</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_cmp_...</b></font></td><td width="17%"><font size="+1"><b>VUB_cmp_...</b></font></td><td width="17%"><font size="+1"><b>VUS_cmp_...</b></font></td><td width="17%"><font size="+1"><b>VUL_cmp_...</b></font></td><td width="17%"><font size="+1"><b>VUQ_cmp_...</b></font></td><td><font size="+1"><b>VUI_cmp_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eq0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ne0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gt0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ge0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...le0</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...lt0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gtC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...geC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...leC</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ltC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gtV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...geV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...leV</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ltV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eq0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ne0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gt0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ge0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...le0ind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...lt0ind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gtCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...geCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...leCind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ltCind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqVind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neVind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gtVind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...geVind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...leVind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ltVind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...inclrange0C</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...exclrange0C</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...inclrangeCC</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...exclrangeCC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...inclrange0Cind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...exclrange0Cind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...inclrangeCCind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...exclrangeCCind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cmp_...</b></font></td><td width="33%"><font size="+1"><b>VCD_cmp_...</b></font></td><td><font size="+1"><b>VCE_cmp_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_cmp_...</b></font></td><td width="33%"><font size="+1"><b>VPD_cmp_...</b></font></td><td><font size="+1"><b>VPE_cmp_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eq0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ne0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqV</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eq0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ne0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqVind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neVind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Comparisons</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>ui VF_cmp_eq0( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VF_cmp_ne0( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VF_cmp_gt0( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VF_cmp_ge0( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VF_cmp_lt0( fVector&nbsp;Y, fVector&nbsp;X , ui&nbsp;size&nbsp;);
<BR>ui VF_cmp_le0( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR><P><font face="courier new">ui VF_cmp_eqC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neC, ..._gtC, ..._geC, ..._ltC, ..._leC</I>)
<BR><font face="courier new">ui VF_cmp_eqV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neV, ..._gtV, ..._geV, ..._ltV, ..._leV</I>)
<BR><font face="courier new">ui VF_cmp_eq0ind( uiVector&nbsp;Ind, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._ne0ind, ..._gt0ind, ..._ge0ind, ..._lt0ind, ..._le0ind</I>)
<BR><font face="courier new">ui VF_cmp_eqCind( uiVector&nbsp;Ind, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neCind, ..._gtCind, ..._geCind, ..._ltCind, ..._leCind</I>)
<BR><font face="courier new">ui VF_cmp_eqVind( uiVector&nbsp;Ind, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neVind, ..._gtVind, ..._geVind, ..._ltVind, ..._leVind</I>)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I> and <I>VE_</I> versions)
<P><font face="courier new">ui VF_cmp_inclrange0C( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>ui VF_cmp_exclrange0C( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>ui VF_cmp_inclrangeCC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;CLo, float&nbsp;CHi&nbsp;);
<BR>ui VF_cmp_exclrangeCC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;CLo, float&nbsp;CHi&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I> and <I>VE_</I> versions)
<P><font face="courier new">ui VF_cmp_inclrange0Cind( uiVector&nbsp;Ind, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>ui VF_cmp_exclrange0Cind( uiVector&nbsp;Ind, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>ui VF_cmp_inclrangeCCind( uiVector&nbsp;Ind, fVector&nbsp;X, ui&nbsp;size, float&nbsp;CLo, float&nbsp;CHi&nbsp;);
<BR>ui VF_cmp_exclrangeCCind( uiVector&nbsp;Ind, fVector&nbsp;X, ui&nbsp;size, float&nbsp;CLo, float&nbsp;CHi&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I> and <I>VE_</I> versions)
<P><font face="courier new">ui VCF_cmp_eq0( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VCF_cmp_ne0( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VCF_cmp_eqC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>ui VCF_cmp_neC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>ui VCF_cmp_eqV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>ui VCF_cmp_neV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>ui VCF_cmp_eq0ind( uiVector&nbsp;Ind, cfVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VCF_cmp_ne0ind( uiVector&nbsp;Ind, cfVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VCF_cmp_eqCind( uiVector&nbsp;Ind, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>ui VCF_cmp_neCind( uiVector&nbsp;Ind, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>ui VCF_cmp_eqVind( uiVector&nbsp;Ind, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>ui VCF_cmp_neVind( uiVector&nbsp;Ind, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VPF_</I>, <I>VPD_</I>, <I>VPE_</I>,  <I>VCD_</I>, and <I>VCE_</I> versions)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;T&gt;::cmp_eq0( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;T&gt;::cmp_ne0( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;T&gt;::cmp_gt0( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;T&gt;::cmp_ge0( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;T&gt;::cmp_lt0( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;T&gt;::cmp_le0( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;T&gt;::cmp_eqC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>ui vector&lt;T&gt;::cmp_eqV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_eq0ind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_eqCind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_eqVind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;T&gt;::cmp_inclrange0C( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>ui vector&lt;T&gt;::cmp_exclrange0C( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>ui vector&lt;T&gt;::cmp_inclrangeCC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;CLo, const&nbsp;T&amp;&nbsp;CHi&nbsp;);
<BR>ui vector&lt;T&gt;::cmp_exclrangeCC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;CLo, const&nbsp;T&amp;&nbsp;CHi&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_inclrange0Cind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_exclrange0Cind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_inclrangeCCind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;CLo, const&nbsp;T&amp;&nbsp;CHi&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_exclrangeCCind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;CLo, const&nbsp;T&amp;&nbsp;CHi&nbsp;);
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_eq0( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_ne0( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_eqC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; C&nbsp;);
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_neC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; C&nbsp;);
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_eqV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y&nbsp;);
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_neV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_eq0ind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_ne0ind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_eqCind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_neCind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_eqVind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);
<BR>ui vector&lt;ui&gt;::cmp_neVind( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_cmp_eq0( Y,X:fVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VF_cmp_ne0( Y,X:fVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VF_cmp_gt0( Y,X:fVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VF_cmp_ge0( Y,X:fVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VF_cmp_lt0( Y,X:fVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VF_cmp_le0( Y,X:fVector; size:UIntSize&nbsp;):UIntSize;</font>
<BR><P><font face="courier new">function VF_cmp_eqC( Y,X:fVector; size:UIntSize; C:Single&nbsp;):UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neC, ..._gtC, ..._geC, ..._ltC, ..._leC</I>)
<BR><font face="courier new">function VF_cmp_eqV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;):UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neV, ..._gtV, ..._geV, ..._ltV, ..._leV</I>)
<BR><font face="courier new">function VF_cmp_eq0ind( Ind:uVector; X:fVector; size:UIntSize&nbsp;):UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._ne0ind, ..._gt0ind, ..._ge0ind, ..._lt0ind, ..._le0ind</I>)
<BR><font face="courier new">function VF_cmp_eqCind( Ind:uVector; X:fVector; size:UIntSize; C:Single&nbsp;):UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neCind, ..._gtCind, ..._geCind, ..._ltCind, ..._leCind</I>)
<BR><font face="courier new">function VF_cmp_eqVind( Ind:uVector; X,&nbsp;Y:fVector; size:UIntSize&nbsp;):UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neVind, ..._gtVind, ..._geVind, ..._ltVind, ..._leVind</I>)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I>, <I>VE_</I>, <I>VI_</I>, and so on)
<BR><P><font face="courier new">function VF_cmp_inclrange0C( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;UIntSize;
<BR>function VF_cmp_exclrange0C( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;UIntSize;
<BR>function VF_cmp_inclrangeCC( Y,&nbsp;X:fVector; size:UIntSize; CLo, CHi:Single&nbsp;):&nbsp;UIntSize;
<BR>function VF_cmp_exclrangeCC( Y,&nbsp;X:fVector; size:UIntSize; CLo, CHi:Single&nbsp;):&nbsp;UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I>, <I>VE_</I>, <I>VI_</I>, and so on)
<BR><P><font face="courier new">function VF_cmp_inclrange0Cind( Ind:uVector; X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;UIntSize;
<BR>function VF_cmp_exclrange0Cind( Ind:uVector; X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;UIntSize;
<BR>function VF_cmp_inclrangeCCind( Ind:uVector; X:fVector; size:UIntSize; CLo, CHi:Single&nbsp;):&nbsp;UIntSize;
<BR>function VF_cmp_exclrangeCCind( Ind:uVector; X:fVector; size:UIntSize; CLo, CHi:Single&nbsp;):&nbsp;UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I>, <I>VE_</I>, <I>VI_</I>, and so on)
<BR><P><font face="courier new">function VCF_cmp_eq0( Y,&nbsp;X:cfVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VCF_cmp_ne0( Y,&nbsp;X:cfVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VCF_cmp_eqC( Y,&nbsp;X:cfVector; size:UIntSize; C:fComplex&nbsp;):UIntSize;
<BR>function VCF_cmp_neC( Y,&nbsp;X:cfVector; size:UIntSize; C:fComplex&nbsp;):UIntSize;
<BR>function VCF_cmp_eqV( Z, X,&nbsp;Y:cfVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VCF_cmp_neV( Z, X,&nbsp;Y:cfVector; size:UIntSize&nbsp;):UIntSize;</font>
<BR><P><font face="courier new">function VCF_cmp_eq0ind( Ind:uVector; X:cfVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VCF_cmp_ne0ind( Ind:uVector; X:cfVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VCF_cmp_eqCind( Ind:uVector; X:cfVector; size:UIntSize; C:fComplex&nbsp;):UIntSize;
<BR>function VCF_cmp_neCind( Ind:uVector; X:cfVector; size:UIntSize; C:fComplex&nbsp;):UIntSize;
<BR>function VCF_cmp_eqVind( Ind:uVector; X,&nbsp;Y:cfVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VCF_cmp_neVind( Ind:uVector; X,&nbsp;Y:cfVector; size:UIntSize&nbsp;):UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VPF_</I>, <I>VPD_</I>, <I>VPE_</I>,  <I>VCD_</I>, and <I>VCE_</I> versions)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cmp_eq0( ui&nbsp;*h_nTrue, fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>ui VFcu_cmp_eq0( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>.._ne0</I>, <I>.._gt0</I>, <I>.._ge0</I>, <I>.._le0</I>, <I>.._lt0</I>)
<P><font face="courier new">int cudaVF_cmp_eqC( ui&nbsp;*h_nTrue, fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_cmp_eqC( ui&nbsp;*h_nTrue, fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>ui VFcu_cmp_eqC( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neC, ..._gtC, ..._geC, ..._ltC, ..._leC</I>)
<P><font face="courier new">int cudaVF_cmp_eqV( ui&nbsp;*h_nTrue, fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size);
<BR>ui VFcu_cmp_eqV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neV, ..._gtV, ..._geV, ..._ltV, ..._leV</I>)
<P><font face="courier new">int cudaVF_cmp_inclrange0C( ui&nbsp;*h_nTrue, fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_cmp_inclrange0C( ui&nbsp;*h_nTrue, fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>int cudaVF_cmp_inclrangeCC( ui&nbsp;*h_nTrue, fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;CLo, float&nbsp;CHi&nbsp;);
<BR>int cusdVF_cmp_inclrangeCC( ui&nbsp;*h_nTrue, fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_CLo, float&nbsp;*d_CHi&nbsp;);
<BR>ui VFcu_cmp_inclrange0C( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>ui VFcu_cmp_inclrangeCC( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;CLo, float&nbsp;CHi&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._exclrange0C</I> and <I>..._exclrangeCC</I>)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(no <i>cudaV?_cmp_???ind</i> or <i>V?cu_cmp_???ind</i> functions!)<BR>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cmp_eq0( var h_nTrue:UIntSize; d_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cmp_eq0( h_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;):&nbsp;UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>.._ne0</I>, <I>.._gt0</I>, <I>.._ge0</I>, <I>.._le0</I>, <I>.._lt0</I>)
<P><font face="courier new">function cudaVF_cmp_eqC( var h_nTrue:UIntSize; d_Y,&nbsp;d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_cmp_eqC( var h_nTrue:UIntSize; d_Y,&nbsp;d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cmp_eqC( h_Y,&nbsp;h_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neC, ..._gtC, ..._geC, ..._ltC, ..._leC</I>)
<P><font face="courier new">function cudaVF_cmp_eqV( var h_nTrue:UIntSize; d_Z,&nbsp;d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cmp_eqV( h_Z,&nbsp;h_X,&nbsp;h_Y:fVector; size:UIntSize&nbsp;):&nbsp;UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neV, ..._gtV, ..._geV, ..._ltV, ..._leV</I>)
<P><font face="courier new">function cudaVF_cmp_inclrange0C( var h_nTrue:UIntSize; d_Y,&nbsp;d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_cmp_inclrange0C( var h_nTrue:UIntSize; d_Y,&nbsp;d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_cmp_inclrangeCC( var h_nTrue:UIntSize; d_Y,&nbsp;d_X:fVector; size:UIntSize; CLo,&nbsp;CHi:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_cmp_inclrangeCC( var h_nTrue:UIntSize; d_Y,&nbsp;d_X:fVector; size:UIntSize; d_CLo,&nbsp;d_CHi:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cmp_inclrange0C( h_Y,&nbsp;h_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;UIntSize;
<BR>function VFcu_cmp_inclrangeCC( h_Y,&nbsp;h_X:fVector; size:UIntSize; CLo,&nbsp;CHi:Single&nbsp;):&nbsp;UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._exclrange0C</I> and <I>..._exclrangeCC</I>)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(no <i>cudaV?_cmp_???ind</i> or <i>V?cu_cmp_???ind</i> functions!)
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>a) Simple comparisons:
<BR>Each element of X is compared with either 0, or a constant C, or the corresponding element of another vector, Y. The conditions to be tested are denoted by two letters as in ASSEMBLER or FORTRAN:<BR>&nbsp;
<TABLE>
<TR><TD>&quot;eq&quot; (&quot;equal&quot;)</TD><TD>True, if X<sub>i</sub> = 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;ne&quot; (&quot;not equal&quot;)</TD><TD>True, if X<sub>i</sub> != 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;gt&quot; (&quot;gteater than&quot;)</TD><TD>True, if X<sub>i</sub> &gt; 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;ge&quot; (&quot;greater or equal&quot;) &nbsp;&nbsp;</TD><TD>True, if X<sub>i</sub> &gt;= 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;lt&quot; (&quot;less than&quot;)</TD><TD>True, if X<sub>i</sub> &lt; 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;le&quot; (&quot;less or equal&quot;)</TD><TD>True, if X<sub>i</sub> &lt;= 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
</TABLE>
<P>For complex numbers, only the test for equality (&quot;eq&quot;) or inequality (&quot;ne&quot;) makes sense and is available.
<BR>For the unsigned integer data types, those functions checking for X<sub>i</sub> &lt; 0 or X<sub>i</sub> &lt;= 0 do not exist, as no unsigned number can possibly be below 0. Likewise, there are no "VU_cmp_ge0" functions, as the condition X<sub>i</sub> &gt;= 0 is trivially fulfilled for any possible input value.
<P>b) Range-checking functions
<BR>Each element of X is checked if it falls into a range which is specified either by 0 and a (positive or negative) constant C, or by two constants, CLo and CHi. One has the choice between two versions, treating the range either as inclusive or as exclusive of the end points:
<BR><I>VF_cmp_inclrange0C</I> checks for 0 &lt;= x &lt;= C (positive C) or 0 &gt;= x &gt;= C (negative C), whereas <I>VF_cmp_exclrangeCC</I> checks for CLo &lt; x &lt; CHi.
<BR>For the unsigned integer types, there are no functions "<i>VU_cmp_inclrange0C</i>", as the condition X<sub>i</sub> &gt;= 0 is trivially fulfilled for any possible input number.
<P>a) and b):
<BR>There are two different ways how the result of the comparison is treated. The result for each element of X is either stored as 1.0 for TRUE and 0.0 for FALSE in a vector of a floating-point data type (with the imaginary part in the complex versions always set to 0), or the indices of the elements for which the result is TRUE are stored in an index vector; the latter is the case in the functions with the suffix &quot;ind&quot; as the last part of their names, like in <I>VF_cmp_neCind</I>. In any case, the number of TRUE results encountered is returned by the function. The index-finding variant is especially useful to extract the elements for which the condition is TRUE into a sub-vector by <I><a href="#indpick">VF_indpick</a></I>; be sure to check that the return value nTrue is non-zero if you wish to do that (remember that the parameter size for any of the functions of this <I>VectorLib</I> library must be non-zero!).
<BR>Even if you happen to know that the number of TRUE results is small, the size of the <i>Ind</i> vector must still be the full size of <i>X</i>, as the routine might use parts of <i>Ind</i> for intermediate storage.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>number of elements for which the condition was found to be TRUE.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cnt_">VF_cnt_...</a>,&nbsp;&nbsp; <a href="#cmp0">VF_cmp0</a>,&nbsp;&nbsp; <a href="#cmpC">VF_cmpC</a>,&nbsp;&nbsp; <a href="#cmpV">VF_cmpV</a>,&nbsp;&nbsp; <a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#iselementC">VF_iselementC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cnt_"></a><a name="cnt_..."></a>
<table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%">
<tr valign="TOP"><td width="33%"><font size="+1"><b>VF_cnt_...</b></font></td><td width="34%"><font size="+1"><b>VD_cnt_...</b></font></td><td><font size="+1"><b>VE_cnt_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_cnt_...</b></font></td><td width="17%"><font size="+1"><b>VBI_cnt_...</b></font></td><td width="17%"><font size="+1"><b>VSI_cnt_...</b></font></td><td width="17%"><font size="+1"><b>VLI_cnt_...</b></font></td><td width="17%"><font size="+1"><b>VQI_cnt_...</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_cnt_...</b></font></td><td width="17%"><font size="+1"><b>VUB_cnt_...</b></font></td><td width="17%"><font size="+1"><b>VUS_cnt_...</b></font></td><td width="17%"><font size="+1"><b>VUL_cnt_...</b></font></td><td width="17%"><font size="+1"><b>VUQ_cnt_...</b></font></td><td><font size="+1"><b>VUI_cnt_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eq0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ne0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gt0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ge0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...le0</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...lt0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gtC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...geC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...leC</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ltC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gtV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...geV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...leV</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ltV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...inclrange0C</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...exclrange0C</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...inclrangeCC</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...exclrangeCC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cnt_...</b></font></td><td width="33%"><font size="+1"><b>VCD_cnt_...</b></font></td><td><font size="+1"><b>VCE_cnt_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_cnt_...</b></font></td><td width="33%"><font size="+1"><b>VPD_cnt_...</b></font></td><td><font size="+1"><b>VPE_cnt_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eq0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ne0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqV</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neV</b></font></td></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Count how often a condition is met</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>ui VF_cnt_eq0( fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VF_cnt_ne0( fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VF_cnt_gt0( fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VF_cnt_ge0( fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VF_cnt_lt0( fVector&nbsp;X , ui&nbsp;size&nbsp;);
<BR>ui VF_cnt_le0( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR><P><font face="courier new">ui VF_cnt_eqC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neC, ..._gtC, ..._geC, ..._ltC, ..._leC</I>)
<BR><font face="courier new">ui VF_cnt_eqV( fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neV, ..._gtV, ..._geV, ..._ltV, ..._leV</I>)
<P><font face="courier new">ui VF_cnt_inclrange0C( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>ui VF_cnt_exclrange0C( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>ui VF_cnt_inclrangeCC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;CLo, float&nbsp;CHi&nbsp;);
<BR>ui VF_cnt_exclrangeCC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;CLo, float&nbsp;CHi&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I>, <I>VE_</I>, <I>VI_</I>, and so on)
<P><font face="courier new">ui VCF_cnt_eq0( cfVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VCF_cnt_ne0( cfVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>ui VCF_cnt_eqC( cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>ui VCF_cnt_neC( cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>ui VCF_cnt_eqV( cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>ui VCF_cnt_neV( cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VPF_</I>, <I>VPD_</I>, <I>VPE_</I>,  <I>VCD_</I>, and <I>VCE_</I> versions)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;T&gt;::cnt_eq0( );
<BR>ui vector&lt;T&gt;::cnt_ne0( );
<BR>ui vector&lt;T&gt;::cnt_gt0( );
<BR>ui vector&lt;T&gt;::cnt_ge0( );
<BR>ui vector&lt;T&gt;::cnt_lt0( );
<BR>ui vector&lt;T&gt;::cnt_le0( );
<BR>ui vector&lt;T&gt;::cnt_eqC( const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>ui vector&lt;T&gt;::cnt_eqV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>ui vector&lt;T&gt;::cnt_inclrange0C( const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>ui vector&lt;T&gt;::cnt_exclrange0C( const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>ui vector&lt;T&gt;::cnt_inclrangeCC( const&nbsp;T&amp;&nbsp;CLo, const&nbsp;T&amp;&nbsp;CHi&nbsp;);
<BR>ui vector&lt;T&gt;::cnt_exclrangeCC( const&nbsp;T&amp;&nbsp;CLo, const&nbsp;T&amp;&nbsp;CHi&nbsp;);
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cnt_eq0( );
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cnt_ne0( );
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cnt_eqC( complex&lt;T&gt; C&nbsp;);
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cnt_neC( complex&lt;T&gt; C&nbsp;);
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cnt_eqV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y&nbsp;);
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cnt_neV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y&nbsp;);
</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_cnt_eq0( X:fVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VF_cnt_ne0( X:fVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VF_cnt_gt0( X:fVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VF_cnt_ge0( X:fVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VF_cnt_lt0( X:fVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VF_cnt_le0( X:fVector; size:UIntSize&nbsp;):UIntSize;</font>
<BR><P><font face="courier new">function VF_cnt_eqC( X:fVector; size:UIntSize; C:Single&nbsp;):UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neC, ..._gtC, ..._geC, ..._ltC, ..._leC</I>)
<BR><font face="courier new">function VF_cnt_eqV( X,&nbsp;Y:fVector; size:UIntSize&nbsp;):UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neV, ..._gtV, ..._geV, ..._ltV, ..._leV</I>)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I>, <I>VE_</I>, <I>VI_</I>, and so on)
<BR><P><font face="courier new">function VF_cnt_inclrange0C( X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;UIntSize;
<BR>function VF_cnt_exclrange0C( X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;UIntSize;
<BR>function VF_cnt_inclrangeCC( X:fVector; size:UIntSize; CLo, CHi:Single&nbsp;):&nbsp;UIntSize;
<BR>function VF_cnt_exclrangeCC( X:fVector; size:UIntSize; CLo, CHi:Single&nbsp;):&nbsp;UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I>, <I>VE_</I>, <I>VI_</I>, and so on)
<BR><P><font face="courier new">function VCF_cnt_eq0( X:cfVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VCF_cnt_ne0( X:cfVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VCF_cnt_eqC( X:cfVector; size:UIntSize; C:fComplex&nbsp;):UIntSize;
<BR>function VCF_cnt_neC( X:cfVector; size:UIntSize; C:fComplex&nbsp;):UIntSize;
<BR>function VCF_cnt_eqV( X,&nbsp;Y:cfVector; size:UIntSize&nbsp;):UIntSize;
<BR>function VCF_cnt_neV( X,&nbsp;Y:cfVector; size:UIntSize&nbsp;):UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VPF_</I>, <I>VPD_</I>, <I>VPE_</I>,  <I>VCD_</I>, and <I>VCE_</I> versions)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cnt_eq0( ui&nbsp;*h_nTrue, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>ui VFcu_cnt_eq0( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>.._ne0</I>, <I>.._gt0</I>, <I>.._ge0</I>, <I>.._le0</I>, <I>.._lt0</I>)
<P><font face="courier new">int cudaVF_cnt_eqC( ui&nbsp;*h_nTrue, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_cnt_eqC( ui&nbsp;*h_nTrue, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>ui VFcu_cnt_eqC( fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neC, ..._gtC, ..._geC, ..._ltC, ..._leC</I>)
<P><font face="courier new">int cudaVF_cnt_eqV( ui&nbsp;*h_nTrue, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size);
<BR>ui VFcu_cnt_eqV( fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neV, ..._gtV, ..._geV, ..._ltV, ..._leV</I>)
<P><font face="courier new">int cudaVF_cnt_inclrange0C( ui&nbsp;*h_nTrue, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_cnt_inclrange0C( ui&nbsp;*h_nTrue, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>int cudaVF_cnt_inclrangeCC( ui&nbsp;*h_nTrue, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;CLo, float&nbsp;CHi&nbsp;);
<BR>int cusdVF_cnt_inclrangeCC( ui&nbsp;*h_nTrue, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_CLo, float&nbsp;*d_CHi&nbsp;);
<BR>ui VFcu_cnt_inclrange0C( fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>ui VFcu_cnt_inclrangeCC( fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;CLo, float&nbsp;CHi&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._exclrange0C</I> and <I>..._exclrangeCC</I>)
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cnt_eq0( var h_nTrue:UIntSize; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cnt_eq0( h_X:fVector; size:UIntSize&nbsp;):&nbsp;UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>.._ne0</I>, <I>.._gt0</I>, <I>.._ge0</I>, <I>.._le0</I>, <I>.._lt0</I>)
<P><font face="courier new">function cudaVF_cnt_eqC( var h_nTrue:UIntSize; d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_cnt_eqC( var h_nTrue:UIntSize; d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cnt_eqC( h_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neC, ..._gtC, ..._geC, ..._ltC, ..._leC</I>)
<P><font face="courier new">function cudaVF_cnt_eqV( var h_nTrue:UIntSize; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cnt_eqV( h_X,&nbsp;h_Y:fVector; size:UIntSize&nbsp;):&nbsp;UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neV, ..._gtV, ..._geV, ..._ltV, ..._leV</I>)
<P><font face="courier new">function cudaVF_cnt_inclrange0C( var h_nTrue:UIntSize; d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_cnt_inclrange0C( var h_nTrue:UIntSize; d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_cnt_inclrangeCC( var h_nTrue:UIntSize; d_X:fVector; size:UIntSize; CLo,&nbsp;CHi:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_cnt_inclrangeCC( var h_nTrue:UIntSize; d_X:fVector; size:UIntSize; d_CLo,&nbsp;d_CHi:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cnt_inclrange0C( h_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;UIntSize;
<BR>function VFcu_cnt_inclrangeCC( h_X:fVector; size:UIntSize; CLo,&nbsp;CHi:Single&nbsp;):&nbsp;UIntSize;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._exclrange0C</I> and <I>..._exclrangeCC</I>)
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions are similar to the <a href="#cmp_">VF_cmp_...</a> functions. Here, however, only the number of TRUE occurrences is counted and returned.
<P>a) Simple comparisons:
<BR>Each element of X is compared with either 0, or a constant C, or the corresponding element of another vector, Y. The conditions to be tested are denoted by two letters as in ASSEMBLER or FORTRAN:<BR>&nbsp;
<TABLE>
<TR><TD>&quot;eq&quot; (&quot;equal&quot;)</TD><TD>True, if X<sub>i</sub> = 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;ne&quot; (&quot;not equal&quot;)</TD><TD>True, if X<sub>i</sub> != 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;gt&quot; (&quot;gteater than&quot;)</TD><TD>True, if X<sub>i</sub> &gt; 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;ge&quot; (&quot;greater or equal&quot;) &nbsp;&nbsp;</TD><TD>True, if X<sub>i</sub> &gt;= 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;lt&quot; (&quot;less than&quot;)</TD><TD>True, if X<sub>i</sub> &lt; 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;le&quot; (&quot;less or equal&quot;)</TD><TD>True, if X<sub>i</sub> &lt;= 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
</TABLE>
<P>For complex numbers, only the test for equality (&quot;eq&quot;) or inequality (&quot;ne&quot;) makes sense and is available.
<BR>For the unsigned integer data types, those functions checking for X<sub>i</sub> &lt; 0 or X<sub>i</sub> &lt;= 0 do not exist, as no unsigned number can possibly be below 0. Likewise, there are no "VU_cnt_ge0" functions, as the condition X<sub>i</sub> &gt;= 0 is trivially fulfilled for any possible input value.
<P>b) Range-checking functions
<BR>Each element of X is checked if it falls into a range which is specified either by 0 and a (positive or negative) constant C, or by two constants, CLo and CHi. One has the choice between two versions, treating the range either as inclusive or as exclusive of the end points:
<BR><I>VF_cnt_inclrange0C</I> checks for 0 &lt;= x &lt;= C (positive C) or 0 &gt;= x &gt;= C (negative C), whereas <I>VF_cnt_exclrangeCC</I> checks for CLo &lt; x &lt; CHi.
<BR>For the unsigned integer types, there are no functions "<i>VU_cnt_inclrange0C</i>", as the condition X<sub>i</sub> &gt;= 0 is trivially fulfilled for any possible input number.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>number of elements for which the condition was found to be TRUE.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cmp_">VF_cmp_...</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="comb"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_comb</b></font></td><td width="33%"><font size="+1"><b>VD_comb</b></font></td><td><font size="+1"><b>VE_comb</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initializes a vector with a comb function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_comb( fVector&nbsp;X, ui&nbsp;size, ui&nbsp;spac, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::comb( ui&nbsp;spac, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_comb( X:fVector; size:UIntSize; spac:Word; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_comb( fVector&nbsp;d_X, ui&nbsp;size, ui&nbsp;spac, float&nbsp;C&nbsp;);
<BR>int cusdVF_comb( fVector&nbsp;d_X, ui&nbsp;size, ui&nbsp;spac, float&nbsp;*d_C&nbsp;);
<BR>void VFcu_comb( fVector&nbsp;h_X, ui&nbsp;size, ui&nbsp;spac, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_comb( d_X:fVector; size:UIntSize; spac:Word; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_comb( d_X:fVector; size:UIntSize; spac:Word; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_comb( h_X:fVector; size:UIntSize; spac:Word; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = C, i = 0, 1*spac, 2*spac,...
<BR>X<sub>i</sub> = 0, otherwise</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If the spacing <i>spac</i> of the comb exceeds size, an error message &quot;Invalid parameter(s)&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#equ0">VF_equ0</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="complex"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_complex</b></font></td><td width="33%"><font size="+1"><b>VCD_complex</b></font></td><td><font size="+1"><b>VCE_complex</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_complex</b></font></td><td width="33%"><font size="+1"><b>VPD_complex</b></font></td><td><font size="+1"><b>VPE_complex</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Constructs a complex vector (either cartesian or polar coordinates) from its real and imaginary parts.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VCF_complex( cfVector&nbsp;X, fVector&nbsp;Re, fVector&nbsp;Im, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::complex( vector&lt;T&gt; Re, vector&lt;T&gt; Im&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_complex( X:cfVector; Re,&nbsp;Im:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_complex( cfVector&nbsp;d_X, fVector&nbsp;d_Re, fVector&nbsp;d_Im, ui&nbsp;size&nbsp;);
<BR>void VCFcu_complex( cfVector&nbsp;h_X, fVector&nbsp;h_Re, fVector&nbsp;h_Im, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_complex( d_X:cfVector; d_Re,&nbsp;d_Im:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VCFcu_complex( h_X:cfVector; h_Re,&nbsp;h_Im:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Identical to <I><a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#ReImtoC">VD_ReImtoC</a></I>, and <I><a href="#ReImtoC">VE_ReImtoC</a></I>. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="conj"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_conj</b></font></td><td width="33%"><font size="+1"><b>VCD_conj</b></font></td><td><font size="+1"><b>VCE_conj</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_conj</b></font></td><td width="33%"><font size="+1"><b>VPD_conj</b></font></td><td><font size="+1"><b>VPE_conj</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex conjugate of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFmath.h&gt;
<BR>int VCF_conj( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;complex&lt;T&gt;&gt;::conj( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFmath;
<BR>function VCF_conj( Y,&nbsp;X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVCF_conj( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VCFcu_conj( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFmath;
<BR>function cudaVCF_conj( d_Y,&nbsp;d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VCFcu_conj( h_Y,&nbsp;h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Re(Y<sub>i</sub>) = Re(X<sub>i</sub>)
<BR>Im(Y<sub>i</sub>) = -Im(X<sub>i</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#neg">VCF_neg</a>,&nbsp;&nbsp; <a href="#abs">VCF_abs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="continuePlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_continuePlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Get back into the last viewport used for plotting</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_continuePlot( void&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_continuePlot;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>If one wants to add new DataPlots to an existing coordinate system after one has already defined a new viewport (e.g., for text output), this function takes one back to the most recently used coordinate system.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#getCoordSystem">V_getCoordSystem</a>,&nbsp;&nbsp; <a href="#setCoordSystem">V_setCoordSystem</a>,&nbsp;&nbsp; <a href="#setPlotRegion">V_setPlotRegion</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="convolve"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_convolve</b></font></td><td width="33%"><font size="+1"><b>VD_convolve</b></font></td><td><font size="+1"><b>VE_convolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculates the convolution of a vector with a response function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_convolve( fVector&nbsp;Y, fVector&nbsp;Flt, fVector&nbsp;X, fVector&nbsp;Rsp, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::convolve( vector&lt;T&gt; Flt, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Rsp&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_convolve( Y, Flt, X, Rsp:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_convolve( fVector&nbsp;d_Y, fVector&nbsp;d_Flt, fVector&nbsp;d_X, fVector&nbsp;d_Rsp, ui&nbsp;size&nbsp;);
<BR>void VFcu_convolve( fVector&nbsp;h_Y, fVector&nbsp;h_Flt, fVector&nbsp;h_X, fVector&nbsp;h_Rsp, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_convolve( d_Y,&nbsp;d_Flt,&nbsp;d_X,&nbsp;d_Rsp:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_convolve( h_Y,&nbsp;h_Flt,&nbsp;h_X,&nbsp;h_Rsp:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The convolution of X with the response function Rsp is calculated and stored in Y. A filter Flt is also calculated. If more than one vector is to be convolved with the same Rsp, use <I>VF_convolve</I> only once and use <I><a href="#filter">VF_filter</a></I> for the other vectors.
<BR>The response has to be stored in Rsp in wrap-around order: the response for zero and positive times (or whatever the independent variable is) is stored in Rsp<sub>0</sub> to Rsp<sub>size/2</sub> and the response for negative times (beginning with the most negative time) in Rsp<sub>size/2+1</sub> to Rsp<sub>size-1</sub>. You may wish to use <I><a href="#rotate">VF_rotate</a></I> or <I><a href="#reflect">VF_reflect</a></I> to achieve this wrap-around order and to construct the response vector.
<BR>Notice that Rsp has to be of the same size as X.
<P>The result of the convolution appears scaled with the sum of all elements of Rsp. Normally, therefore, Rsp should be normalized to 1.0.
<P>X, Y, Rsp, and Flt must all be of the same size, which has to be an integer power of 2. X may be overwritten by Y, Rsp may be overwritten by Flt, but X and Flt as well as Y and Rsp have to be distinct from each other.
<P>The treatment of round-off errors in the construction of Flt may be modified by <I><a href="#setRspEdit">VF_setRspEdit</a></I>.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new"><a href="#ramp">VF_ramp</a>( Time, 1024, 0.0, 1.0&nbsp;);
<BR><a href="#Gauss">VF_Gauss</a>( Rsp, Time, 513, 10.0, 0.0, 1.0&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Response function for zero and positive times */
<BR><a href="#reflect">VF_reflect</a>( Rsp+1, 1023&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;... and for negative times */
<BR><a href="#divC">VF_divC</a>( Rsp, Rsp, 1024, VF_sum( Rsp, 1024&nbsp;)&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Normalisation of Rsp */
<BR>VF_convolve( X, Rsp, X, Rsp, 1024&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Convolution; X is overwritten by the desired result
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and Rsp is overwritten by the frequency filter */
<BR><a href="#filter">VF_filter</a>( Y, Y, Rsp, 1024&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Next convolution: instead of another call to
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_convolve, Y is filtered using the frequency
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter just obtained */<BR>&nbsp;</font></td></tr>
<tr valign="TOP">
<td>Example Pascal/Delphi</td><td><font face="courier new"><a href="#ramp">VF_ramp</a>( Time, 1024, 0.0, 1.0&nbsp;);
<BR><a href="#Gauss">VF_Gauss</a>( Rsp, Time, 513, 10.0, 0.0, 1.0&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Response function for zero and positive times *)
<BR><a href="#reflect">VF_reflect</a>( VF_Pelement(Rsp,1), 1023&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;... and for negative times *)
<BR><a href="#divC">VF_divC</a>( Rsp, Rsp, 1024, VF_sum( Rsp, 1024&nbsp;)&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Normalisation of Rsp *)
<BR>VF_convolve( X, Rsp, X, Rsp, 1024&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Convolution; X is overwritten by the desired result and Rsp is overwritten by the frequency filter *)
<BR><a href="#filter">VF_filter</a>( Y, Y, Rsp, 1024&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Next convolution: instead of another call to VF_convolve, Y is filtered using the frequency filter just obtained&nbsp;&nbsp;&nbsp;*)</font><P>Mathematically, this convolution is based on the assumption that X is periodic; it still works well if X is non-periodic but converges on both ends to the same value X<sub>0</sub> = X<sub>size-1</sub>. If that is not the case, the first and the last elements of Y are spoiled by &quot;wrap-around&quot; from elements on the other side. Extrapolate X on both sides in order to imbed the original X in a larger vector, if wrap-around is a problem. The minimum number of elements to be added equals half the width of the response function. (In the case of an asymmetric response function, it is the broader wing that counts.) After convolving the larger vector with the response function, it will be the dummy elements just added which become spoiled by wrap-around. Those elements of the result vector which correspond to the original X will represent the desired convolution of X with Rsp.
<BR>If X is smoothly converging on both sides to different values, it is not necessary to employ the procedure just described. Rather, the difference between the end points may be regarded as a linear trend. In this case, remove the trend, convolve the resultant vector and add the trend to the result.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">d = (X[size-1] - X[0]) / (size-1);
<BR><a href="#ramp">VF_ramp</a>( Trend, size, 0.0, d&nbsp;);
<BR><a href="#subV">VF_subV</a>( Y, X, Trend, size&nbsp;);
<BR>VF_convolve( Y, Flt, Y, Rsp, size&nbsp;);
<BR><a href="#addV">VF_addV</a>( Y, Y, Trend, size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Example for treatment of end effects in Pascal/Delphi</td><td><font face="courier new"> 
d := (<a href="#element">VF_element</a>(X,size-1) - X^) / (size-1);
<BR><a href="#ramp">VF_ramp</a>( Trend, size, 0.0, d&nbsp;);
<BR><a href="#subV">VF_subV</a>( Y, X, Trend, size&nbsp;);
<BR>VF_convolve( Y, Flt, Y, Rsp, size&nbsp;);
<BR><a href="#addV">VF_addV</a>( Y, Y, Trend, size&nbsp;);</font><P>You might notice that Flt is declared as fVector&nbsp;rather than cfVector, although the information stored in Flt consists of complex numbers. The reason is that these numbers are stored in the packed complex format (as described for <I><a href="#FFT">VF_FFT</a></I>) which is used only in connection with Fourier-Transform operations of real vectors.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_convolve</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#filter">VF_filter</a>,&nbsp;&nbsp; <a href="#deconvolve">VF_deconvolve</a>,&nbsp;&nbsp; <a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="corrcoeff"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_corrcoeff</b></font></td><td width="33%"><font size="+1"><b>VD_corrcoeff</b></font></td><td><font size="+1"><b>VE_corrcoeff</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Linear correlation coefficient between two distributions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_corrcoeff( fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float Xmean, float Ymean&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::corrcoeff( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, T Xmean, T Ymean&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_corrcoeff( X,&nbsp;Y:fVector; size:UIntSize; Xmean, Ymean:Single&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_corrcoeff( ui&nbsp;*h_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;Xmean, float&nbsp;Ymean&nbsp;);
<BR>int cusdVF_corrcoeff( ui&nbsp;*d_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_Xmean, float&nbsp;*d_Ymean&nbsp;);
<BR>float VFcu_corrcoeff( fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;Xmean, float&nbsp;Ymean&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_corrcoeff( var h_RetVal:Single; d_X,&nbsp;d_Y:fVector; size:UIntSize; Xmean,&nbsp;Ymean:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_corrcoeff( d_RetVal:PSingle; d_X,&nbsp;d_Y:fVector; size:UIntSize; d_Xmean,&nbsp;d_Ymean:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_corrcoeff( h_X,&nbsp;h_Y:fVector; size:UIntSize; Xmean,&nbsp;Ymean:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The linear correlation coefficient (&quot;Pearson's r&quot;) takes on values between -1.0 and +1.0. The mean values of both distributions must be known. They are passed to <I>VF_corrcoeff</I> as the parameters Xmean and Ymean.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">r = VF_corrcoeff( X, Y, n, <a href="#mean">VF_mean</a>( X, n&nbsp;), VF_mean( Y, n&nbsp;)&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>linear correlation coefficient r</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#varianceV">VF_varianceV</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cos"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cos</b></font></td><td width="33%"><font size="+1"><b>VD_cos</b></font></td><td><font size="+1"><b>VE_cos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cos</b></font></td><td width="33%"><font size="+1"><b>VDx_cos</b></font></td><td><font size="+1"><b>VEx_cos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_cos</b></font></td><td width="33%"><font size="+1"><b>VDr_cos</b></font></td><td><font size="+1"><b>VEr_cos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_cos</b></font></td><td width="33%"><font size="+1"><b>VDrx_cos</b></font></td><td><font size="+1"><b>VErx_cos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cos</b></font></td><td width="33%"><font size="+1"><b>VCD_cos</b></font></td><td><font size="+1"><b>VCE_cos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_cos</b></font></td><td width="33%"><font size="+1"><b>VCDx_cos</b></font></td><td><font size="+1"><b>VCEx_cos</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cosine function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cos( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_cos( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VFr_cos( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFrx_cos( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cos( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_cos( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>int vector&lt;T&gt;::r_cos( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::rx_cos( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cos( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_cos( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VFr_cos( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFrx_cos( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cos( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_cos( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_cos( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_cos( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_cos( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cos( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_cos( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_cos( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cos( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_cos( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cos ( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;cos ( A*X<sub>i</sub> + B&nbsp;)
<BR>For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as rational multiples of <font face="symbol">p</font>, it is better to use <I><a href="#cosrpi">VF_cosrpi</a></I> than <I>VF_cos</I>.
<BR>If, on the other hand, one can be sure that all X<sub>i</sub> are within the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>, one can employ the faster reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I> (only for CPU, not for CUDA).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors in the real-value functions lead to a default result of 1.0 (as if the input were 0.0) and to a non-zero return value, but are otherwise ignored; <I>_matherr</I> is not called.
<BR>OVERFLOW errors can only occur in the complex versions and lead to a result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cos2">VF_cos2</a>,&nbsp;&nbsp; <a href="#cosrpi">VF_cosrpi</a>,&nbsp;&nbsp; <a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#cosh">VF_cosh</a>,&nbsp;&nbsp; <a href="#acos">VF_acos</a>,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cos2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cos2</b></font></td><td width="33%"><font size="+1"><b>VD_cos2</b></font></td><td><font size="+1"><b>VE_cos2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cos2</b></font></td><td width="33%"><font size="+1"><b>VDx_cos2</b></font></td><td><font size="+1"><b>VEx_cos2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_cos2</b></font></td><td width="33%"><font size="+1"><b>VDr_cos2</b></font></td><td><font size="+1"><b>VEr_cos2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_cos2</b></font></td><td width="33%"><font size="+1"><b>VDrx_cos2</b></font></td><td><font size="+1"><b>VErx_cos2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the cosine function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cos2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_cos2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cos2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_cos2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cos2( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_cos2( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cos2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_cos2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_cos2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_cos2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_cos2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cos2( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_cos2( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_cos2( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cos2( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_cos2( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cos<sup>2</sup>( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;cos<sup>2</sup>( A*X<sub>i</sub> + B&nbsp;)
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards. The reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I> are for situations in which one can be sure that all input values lie in the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT> (not available for CUDA).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors lead to a default result of 1.0 (as if the input were 0.0) and a non-zero return value, but are otherwise ignored; <I>_matherr</I> is not called.
<BR>OVERFLOW errors can only occur in the complex versions and lead to a result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cos">VF_cos</a>,&nbsp;&nbsp; <a href="#cosrpi">VF_cosrpi</a></I>,&nbsp;&nbsp;cos</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosec"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosec</b></font></td><td width="33%"><font size="+1"><b>VD_cosec</b></font></td><td><font size="+1"><b>VE_cosec</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cosec</b></font></td><td width="33%"><font size="+1"><b>VDx_cosec</b></font></td><td><font size="+1"><b>VEx_cosec</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cosecant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosec( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_cosec( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosec( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_cosec( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosec( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_cosec( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cosec( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_cosec( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_cosec( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_cosec( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_cosec( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cosec( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_cosec( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_cosec( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cosec( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_cosec( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cosec ( X<sub>i</sub>&nbsp;) = 1.0 / sin ( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;cosec ( A*X<sub>i</sub> + B&nbsp;)
<BR>The cosecant is defined as the inverse of the sine (not to be mistaken for the arcus function arcsin!) For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as rational multiples of <font face="symbol">p</font>, it is better to use <I><a href="#cosecrpi">VF_cosecrpi</a></I> than <I>VF_cosec</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>For TLOSS precision errors, the default result is arbitrarily set to 1.0 (as an exception from the general rule which would require the result to be the mean of the results for +0 and -0. This would be 0.0. However, zero is not a valid result for the cosecant function). For SING and OVERFLOW errors, the default result is &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cosec2">VF_cosec2</a>,&nbsp;&nbsp; <a href="#cosecrpi">VF_cosecrpi</a>,&nbsp;&nbsp; <a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#cosech">VF_cosech</a>,&nbsp;&nbsp; sin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosec2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosec2</b></font></td><td width="33%"><font size="+1"><b>VD_cosec2</b></font></td><td><font size="+1"><b>VE_cosec2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cosec2</b></font></td><td width="33%"><font size="+1"><b>VDx_cosec2</b></font></td><td><font size="+1"><b>VEx_cosec2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the cosecant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosec2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_cosec2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosec2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_cosec2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosec2( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_cosec2( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cosec2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_cosec2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_cosec2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_cosec2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_cosec2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cosec2( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_cosec2( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_cosec2( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cosec2( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_cosec2( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cosec<sup>2</sup> ( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;cosec<sup>2</sup> ( A*X<sub>i</sub> + B&nbsp;)
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>For SING, OVERFLOW, and TLOSS errors, the default result is &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cosec">VF_cosec</a>,&nbsp;&nbsp; <a href="#cosecrpi">VF_cosecrpi</a></I>,&nbsp;&nbsp;sin</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosech"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosech</b></font></td><td width="33%"><font size="+1"><b>VD_cosech</b></font></td><td><font size="+1"><b>VE_cosech</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cosech</b></font></td><td width="33%"><font size="+1"><b>VDx_cosech</b></font></td><td><font size="+1"><b>VEx_cosech</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic cosecant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosech( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_cosech( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosech( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_cosech( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosech( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_cosech( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cosech( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_cosech( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_cosech( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_cosech( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_cosech( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cosech( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_cosech( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_cosech( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cosech( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_cosech( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cosech ( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;cosech ( A*X<sub>i</sub>+B&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors lead to a default result of 0 (mean of +HUGE_VAL and -HUGE_VAL); OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; sinh</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosecrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosecrpi</b></font></td><td width="33%"><font size="+1"><b>VD_cosecrpi</b></font></td><td><font size="+1"><b>VE_cosecrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosecrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_cosecrpi2</b></font></td><td><font size="+1"><b>VE_cosecrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosecrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_cosecrpi3</b></font></td><td><font size="+1"><b>VE_cosecrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cosecant function of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosecrpi( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_cosecrpi2( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_cosecrpi3( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosecrpi( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::cosecrpi2( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::cosecrpi3( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosecrpi( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_cosecrpi2( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_cosecrpi3( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cosecrpi( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_cosecrpi2( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_cosecrpi3( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_cosecrpi( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_cosecrpi2( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_cosecrpi3( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cosecrpi( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_cosecrpi2( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_cosecrpi3( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cosecrpi( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cosecrpi2( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cosecrpi3( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = cosec( (P<sub>i</sub> / q) *&nbsp;<font face="symbol">p</font>&nbsp;)
<BR>The cosecant of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_cosecrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_cosecrpi2</I> should be used which is a highly optimized version using a look-up table. If q is a multiple of 3, <I>VF_cosecrpi3</I> should be used. <I>VF_cosecrpi2</I> and <I>VF_cosecrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors occur if P<sub>i</sub> / q is exactly an integer number; the default result is 0.0 (which is the mean of +HUGE_VAL and -HUGE_VAL; in contrast to <I><a href="#cosec">VF_cosec</a></I>, 0.0 is chosen irrespective of the fact that it is not a valid result of the cosecant function); q must be non-zero; this is, however, not tested for.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cosec">VF_cosec</a>,&nbsp;&nbsp; sin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosectab2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosectab2</b></font></td><td width="33%"><font size="+1"><b>VD_cosectab2</b></font></td><td><font size="+1"><b>VE_cosectab2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosectab3</b></font></td><td width="33%"><font size="+1"><b>VD_cosectab3</b></font></td><td><font size="+1"><b>VE_cosectab3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">&nbsp;</TD><td>Table of cosecant values for arguments between 0 and <font face="symbol">p</font>/2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_cosectab2[ VF_tabsz2+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_cosectab2[ VD_tabsz2+1 ];
<BR>extern extended&nbsp;VE_cosectab2[ VE_tabsz2+1 ];
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_cosectab3[ VF_tabsz3+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_cosectab3[ VD_tabsz3+1 ];
<BR>extern extended&nbsp;VE_cosectab3[ VE_tabsz3+1 ];</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses FCSCTAB3, DCSCTAB3, ECSCTAB3;
<BR>VF_cosectab2: array[0..VF_tabsz2] of Single;
<BR>VD_cosectab2: array[0..VD_tabsz2] of Double;
<BR>VE_cosectab2: array[0..VE_tabsz2] of Extended;
<BR>VF_cosectab3: array[0..VF_tabsz3] of Single;
<BR>VD_cosectab3: array[0..VD_tabsz3] of Double;
<BR>VE_cosectab3: array[0..VE_tabsz3] of Extended;
<BR></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><font face="courier new"> VF_cosectab2[ i ] = cosec ( i/(2*VF_tabsz2) *&nbsp;<font face="symbol">p</font>&nbsp;), &nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz2-1
<BR>VF_cosectab3[ i ] = cosec ( i/(2*VF_tabsz3) *&nbsp;<font face="symbol">p</font>&nbsp;), &nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz3-1
<BR>VF_cosectab2[ VF_tabsz2 ] = VF_cosectab3[ VF_tabsz3 ] = 0</font>
<BR>These look-up tables of cosecant values for arguments between 0 and <font face="symbol">p</font>/2 are used by VF_cosecrpi2 and the other functions of that family and are also available to the user. Since the cosecant of <font face="symbol">p</font>/2 is not defined, zero is stored at its place.
<BR><u>C/C++:</u> The symbols VF_tabsz2 etc., denoting the size of the tables, are defined in &lt;xmath.h&gt;.
<BR><u>Pascal/Delphi:</u> The symbols VF_tabsz2 etc. are defined in the same units as the tables themselves.
<BR><u>FreePascal/Lazarus:</u> These tables are not available for FreePascal/Lazarus.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosh"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosh</b></font></td><td width="33%"><font size="+1"><b>VD_cosh</b></font></td><td><font size="+1"><b>VE_cosh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cosh</b></font></td><td width="33%"><font size="+1"><b>VDx_cosh</b></font></td><td><font size="+1"><b>VEx_cosh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cosh</b></font></td><td width="33%"><font size="+1"><b>VCD_cosh</b></font></td><td><font size="+1"><b>VCE_cosh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_cosh</b></font></td><td width="33%"><font size="+1"><b>VCDx_cosh</b></font></td><td><font size="+1"><b>VCEx_cosh</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic cosine</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosh( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_cosh( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VCF_cosh( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VCFx_cosh( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosh( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_cosh( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosh( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_cosh( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cosh( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_cosh( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_cosh( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_cosh( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_cosh( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cosh( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_cosh( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_cosh( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cosh( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_cosh( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cosh ( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;cosh ( A*X<sub>i</sub>+B&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a></I>,&nbsp;&nbsp;cosh</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosrpi</b></font></td><td width="33%"><font size="+1"><b>VD_cosrpi</b></font></td><td><font size="+1"><b>VE_cosrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_cosrpi2</b></font></td><td><font size="+1"><b>VE_cosrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_cosrpi3</b></font></td><td><font size="+1"><b>VE_cosrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cosine function of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosrpi( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_cosrpi2( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_cosrpi3( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosrpi( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::cosrpi2( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::cosrpi3( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosrpi( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_cosrpi2( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_cosrpi3( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cosrpi( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_cosrpi2( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_cosrpi3( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_cosrpi( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_cosrpi2( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_cosrpi3( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cosrpi( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_cosrpi2( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_cosrpi3( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cosrpi( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cosrpi2( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cosrpi3( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = cos( (P<sub>i</sub> / q) *&nbsp;<font face="symbol">p</font>&nbsp;)
<BR>The cosine of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_cosrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_cosrpi2</I> should be used which is a highly optimized version reading the results from a look-up table, if possible. If q is a multiple of 3, <I>VF_cosrpi3</I> should be used. <I>VF_cosrpi3</I> offers a convenient way to use degrees instead of radians; if, for example, q is 180, the unit of the elements of P is &quot;degree&quot;. <I>VF_cosrpi2</I> and <I>VF_cosrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions are error-proof, as long as q != 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cos">VF_cos</a>,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cot</b></font></td><td width="33%"><font size="+1"><b>VD_cot</b></font></td><td><font size="+1"><b>VE_cot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cot</b></font></td><td width="33%"><font size="+1"><b>VDx_cot</b></font></td><td><font size="+1"><b>VEx_cot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cotangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cot( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_cot( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cot( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_cot( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cot( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_cot( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cot( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_cot( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_cot( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_cot( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_cot( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cot( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_cot( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_cot( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cot( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_cot( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cot ( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;cot ( A*X<sub>i</sub>+B&nbsp;)
<BR>The cotangent is defined as the inverse of the tangent (not to be mistaken for the arcus function arctan!) For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as rational multiples of <font face="symbol">p</font>, it is better to use <I><a href="#cotrpi">VF_cotrpi</a></I> than <I>VF_cot</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>For TLOSS precision errors, the default result is 0.0 (which is the mean of +HUGE_VAL and -HUGE_VAL); for SING and OVERFLOW errors, the default result is &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cot2">VF_cot2</a>,&nbsp;&nbsp; <a href="#cotrpi">VF_cotrpi</a>,&nbsp;&nbsp; <a href="#coth">VF_coth</a>,&nbsp;&nbsp; <a href="#atan">VF_atan</a>,&nbsp;&nbsp; <a href="#atan2">VF_atan2</a>,&nbsp;&nbsp; tan</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cot2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cot2</b></font></td><td width="33%"><font size="+1"><b>VD_cot2</b></font></td><td><font size="+1"><b>VE_cot2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cot2</b></font></td><td width="33%"><font size="+1"><b>VDx_cot2</b></font></td><td><font size="+1"><b>VEx_cot2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the cotangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cot2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_cot2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cot2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_cot2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cot2( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_cot2( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cot2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_cot2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_cot2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_cot2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_cot2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cot2( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_cot2( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_cot2( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cot2( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_cot2( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cot<sup>2</sup>( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;cot<sup>2</sup>( A*X<sub>i</sub>+B&nbsp;)
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>For SING, OVERFLOW and TLOSS errors, the default result is +HUGE_VAL (multiplied by the sign of C in the expanded versions).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cot">VF_cot</a>,&nbsp;&nbsp; <a href="#cotrpi">VF_cotrpi</a>,&nbsp;&nbsp; tan</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="coth"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_coth</b></font></td><td width="33%"><font size="+1"><b>VD_coth</b></font></td><td><font size="+1"><b>VE_coth</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_coth</b></font></td><td width="33%"><font size="+1"><b>VDx_coth</b></font></td><td><font size="+1"><b>VEx_coth</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic cotangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_coth( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_coth( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::coth( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_coth( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_coth( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_coth( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_coth( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_coth( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_coth( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_coth( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_coth( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_coth( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_coth( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_coth( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_coth( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_coth( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = coth ( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;coth ( A*X<sub>i</sub>+B&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors lead to a default result of 0.0 (the mean of +HUGE_VAL and -HUGE_VAL); OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#tanh">VF_tanh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; tanh</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cotrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cotrpi</b></font></td><td width="33%"><font size="+1"><b>VD_cotrpi</b></font></td><td><font size="+1"><b>VE_cotrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cotrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_cotrpi2</b></font></td><td><font size="+1"><b>VE_cotrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cotrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_cotrpi3</b></font></td><td><font size="+1"><b>VE_cotrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cotangent function of rational multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cotrpi( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_cotrpi2( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_cotrpi3( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cotrpi( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::cotrpi2( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::cotrpi3( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cotrpi( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_cotrpi2( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_cotrpi3( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cotrpi( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_cotrpi2( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_cotrpi3( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_cotrpi( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_cotrpi2( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_cotrpi3( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cotrpi( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_cotrpi2( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_cotrpi3( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cotrpi( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cotrpi2( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cotrpi3( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = cot( (P<sub>i</sub> / q) *&nbsp;<font face="symbol">p</font>&nbsp;)
<BR>The cotangent of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_cotrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_cotrpi2</I> should be used which is a highly optimized version using a look-up table. If q is a multiple of 3, <I>VF_cotrpi3</I> should be used. <I>VF_cotrpi2</I> and <I>VF_cotrpi3</I> also work with q values they are not optimized for; in this case, however, memory space is wasted for the tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors occur if P<sub>i</sub> / q is a whole number. The default result is 0.0 (which is the mean of +HUGE_VAL and -HUGE_VAL); q must be non-zero; this is, however, not tested for.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cot">VF_cot</a>,&nbsp;&nbsp; tan</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cprint"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cprint</b></font></td><td width="34%"><font size="+1"><b>VD_cprint</b></font></td><td><font size="+1"><b>VE_cprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cprint</b></font></td><td width="34%"><font size="+1"><b>VCD_cprint</b></font></td><td><font size="+1"><b>VCE_cprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_cprint</b></font></td><td width="34%"><font size="+1"><b>VPD_cprint</b></font></td><td><font size="+1"><b>VPE_cprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_cprint</b></font></td><td width="17%"><font size="+1"><b>VBI_cprint</b></font></td><td width="17%"><font size="+1"><b>VSI_cprint</b></font></td><td width="17%"><font size="+1"><b>VLI_cprint</b></font></td><td width="17%"><font size="+1"><b>VQI_cprint</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_cprint</b></font></td><td width="17%"><font size="+1"><b>VUB_cprint</b></font></td><td width="17%"><font size="+1"><b>VUS_cprint</b></font></td><td width="17%"><font size="+1"><b>VUL_cprint</b></font></td><td width="17%"><font size="+1"><b>VUQ_cprint</b></font></td><td><font size="+1"><b>VUI_cprint</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>print a vector to the screen. Only for console applications</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_cprint( fVector&nbsp;X, ui&nbsp;size, unsigned nperline&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::cprint( unsigned nperline&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_cprint( X:fVector; size:UIntSize; nperline:UInt&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_cprint( fVector&nbsp;d_X, ui&nbsp;size, unsigned nperline&nbsp;);
<BR>int cudaVF_cprint_buf( fVector&nbsp;d_X, ui&nbsp;size, unsigned nperline, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_cprint( d_X:fVector; size:UIntSize; nperline:UInt&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_cprint_buf( d_X:fVector; size:UIntSize; nperline:UInt; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>size elements of X are printed to the screen (or &quot;console&quot;), into the actual text window, nperline elements in each line.
<P>The display starts always with a new line. Please note that this may lead to an empty line at the beginning.
<BR>Each line begins with the index of the first element printed into that line. The index is followed by a colon and by the requested nperline elements.
<BR>Cartesian complex numbers are printed in braces, with the real and imaginary parts separated by a komma: {Re,&nbsp;Im}. Polar complex numbers are also written in braces, with the Mag and Arg parts separated by an at-sign: {Mag @ Arg}.
<P>The display pauses every screenful. The user is prompted after each page to continue or to stop printing.
<BR>The number of digits per element is determined by the available space, which depends in turn on the line width and on the parameter nperline.
<P>CUDA versions only: <i>cudaV?_cprint_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as X. By avoiding the need of <i>cudaV?_cprint</i> to allocate its own buffer memory, <i>cudaV?_cprint_buf</i> is slightly faster.
<P>This family of functions is available only for console applications.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If <i>nperline</i> exceeds the maximum number of entries possible in the current text mode, an error message &quot;Cannot use requested format (too many entries per line)!&quot; is generated; in this case, the program chooses the maximum possible number <i>nperline</i>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#fprint">VF_fprint</a>,&nbsp;&nbsp; <a href="#print">VF_print</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; cprintf</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="createCudaWorkspace"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_createCudaWorkspace</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Create a new workspace (CUDA stream with associated buffer memory)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>V_CUDAWORKSPACE V_createCudaWorkspace( void&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Delphi</td><td><font face="courier new">uses VecLib;
<BR>function V_createCudaWorkspace: V_CUDAWORKSPACE;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A new workspace, consisting of a CUDA stream and associated buffer memory, is created. When this workspace is no longer needed, it should be destroyed by calling <I><a href="#destroyCudaWorkspace">V_destroyCudaWorkspace</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The created workspace of type V_CUDAWORKSPACE</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap5">CudaOptiVec.htm, Chapter 5. Streams and Workspaces</a></td></tr></table></td></tr>
</table>


<P>&nbsp;<P><a name="CtoAbs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoAbs</b></font></td><td width="33%"><font size="+1"><b>VD_CtoAbs</b></font></td><td><font size="+1"><b>VE_CtoAbs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Absolute value (magnitude) of cartesian complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoAbs( fVector&nbsp;Abs, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoAbs( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoAbs( Abs:fVector; X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVF_CtoAbs( fVector&nbsp;d_Abs, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
void VFcu_CtoAbs( fVector&nbsp;h_Abs, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVF_CtoAbs( d_Abs:fVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_CtoAbs( h_Abs:fVector; h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Abs<sub>i</sub> = sqrt( Re<sup>2</sup>(X<sub>i</sub>) + Im<sup>2</sup>(X<sub>i</sub>)&nbsp;)
<BR>The absolute value, i.e. the magnitude of each element of the complex vector X is calculated. This function is almost identical to <I><a href="#abs">VCF_abs</a></I>, but does not perform any error handling and requires input values whose real and imaginary parts are both smaller than &#177;sqrt( HUGE ).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#abs">VCF_abs</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a>,&nbsp;&nbsp; <a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#CtoArg">VF_CtoArg</a>,&nbsp;&nbsp; <a href="#CtoNorm">VF_CtoNorm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoArg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoArg</b></font></td><td width="33%"><font size="+1"><b>VD_CtoArg</b></font></td><td><font size="+1"><b>VE_CtoArg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Argument (angle) of cartesian-complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoArg( fVector&nbsp;Arg, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoArg( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoArg( Arg:fVector; X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVF_CtoArg( fVector&nbsp;d_Arg, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
void VFcu_CtoArg( fVector&nbsp;h_Arg, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVF_CtoArg( d_Arg:fVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_CtoArg( h_Arg:fVector; h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Arg<sub>i</sub> = arctan( Im(X<sub>i</sub>) / Re(X<sub>i</sub>)&nbsp;)
<BR>The argument, i.e. the angle of each element of the complex vector X is calculated. For Cartesian coordinates {0, 0}, the angle is arbitrary and is set to zero.
<BR>When necessary, depending on the signs of Re(X<sub>i</sub>) and Im(X<sub>i</sub>), <font face="symbol">p</font> is added or subtracted from the arctan to obtain the correct quadrant.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PolartoC">VF_PolartoC</a>,&nbsp;&nbsp; <a href="#CtoPolar">VF_CtoPolar</a>,&nbsp;&nbsp; <a href="#atan2">VF_atan2</a>,&nbsp;&nbsp; <a href="#CtoAbs">VF_CtoAbs</a>,&nbsp;&nbsp; <a href="#CtoReIm">VF_CtoReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoIm</b></font></td><td width="33%"><font size="+1"><b>VD_CtoIm</b></font></td><td><font size="+1"><b>VE_CtoIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extract the imaginary part from a cartesian-complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoIm( fVector&nbsp;Im, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoIm( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoIm( Im:fVector; X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVF_CtoIm( fVector&nbsp;d_Im, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
void VFcu_CtoIm( fVector&nbsp;h_Im, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVF_CtoIm( d_Im:fVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_CtoIm( h_Im:fVector; h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The imaginary part of the complex vector X is extracted and stored in Im.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#ImtoC">VF_ImtoC</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoNorm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoNorm</b></font></td><td width="33%"><font size="+1"><b>VD_CtoNorm</b></font></td><td><font size="+1"><b>VE_CtoNorm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Norm (square of the absolute value) of cartesian-complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoNorm( fVector&nbsp;Norm, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoNorm( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoNorm( Norm:fVector; X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVF_CtoNorm( fVector&nbsp;d_Norm, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
void VFcu_CtoNorm( fVector&nbsp;h_Norm, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVF_CtoNorm( d_Norm:fVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_CtoNorm( h_Norm:fVector; h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Norm<sub>i</sub> = Re<sup>2</sup>(X<sub>i</sub>) + Im<sup>2</sup>(X<sub>i</sub>)
<BR>This definition of the Norm of a complex number is the same as in C++, but it is not consistent with the usual definition in mathematics, where the term &quot;norm&quot; is used as a synomym for &quot;absolute value&quot; or &quot;magnitude&quot;. As defined here, the Norm is the square of the absolute value. The absolute value itself is available by the functions <I><a href="#CtoAbs">VF_CtoAbs</a></I> (without error handling) and <I><a href="#abs">VCF_abs</a></I> (with error handling).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PolartoC">VF_PolartoC</a>,&nbsp;&nbsp; <a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#CtoArg">VF_CtoArg</a>,&nbsp;&nbsp; <a href="#CtoAbs">VF_CtoAbs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoP"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoP</b></font></td><td width="33%"><font size="+1"><b>VD_CtoP</b></font></td><td><font size="+1"><b>VE_CtoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Transformation of a cartesian complex into a polar complex vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_CtoP( pfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::CtoP( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_CtoP( Y:pfVector; X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_CtoP( pfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
void VFcu_CtoP( pfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_CtoP( d_Y:pfVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_CtoP( h_Y:pfVector; h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X is transformed from cartesian coordinates {Re,&nbsp;Im} into polar coordinates {Mag @ Arg}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoPolar">VF_CtoPolar</a>,&nbsp;&nbsp; <a href="#PtoC">VF_PtoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoPolar"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoPolar</b></font></td><td width="33%"><font size="+1"><b>VD_CtoPolar</b></font></td><td><font size="+1"><b>VE_CtoPolar</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Transformation of complex numbers from Cartesian into polar coordinates, stored in separate vectors Mag and Arg.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoPolar( fVector&nbsp;Mag, fVector&nbsp;Arg, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoPolar( vector&lt;T&gt; Arg, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoPolar( Mag, Arg:fVector; X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVF_CtoPolar( fVector&nbsp;d_Mag, fVector&nbsp;d_Arg, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
void VFcu_CtoPolar( fVector&nbsp;h_Mag, fVector&nbsp;h_Arg, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVF_CtoPolar( d_Mag,&nbsp;d_Arg:fVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_CtoPolar( h_Mag,&nbsp;h_Arg:fVector; h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar coordinates Mag (magnitude, absolute value) and Arg (argument, angle) of each element of the Cartesian complex vector X are calculated. For the Cartesian coordinates {0, 0}, the polar coordinates are also set to {0 @ 0}.
<BR>This function is similar to <I><a href="#CtoP">VF_CtoP</a></I>, with the exception that Mag and Arg are stored in separate vectors instead of one polar complex vector, as in <I><a href="#CtoP">VF_CtoP</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoP">VF_CtoP</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a>,&nbsp;&nbsp; <a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#CtoAbs">VF_CtoAbs</a>,&nbsp;&nbsp; <a href="#CtoArg">VF_CtoArg</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoRe"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoRe</b></font></td><td width="33%"><font size="+1"><b>VD_CtoRe</b></font></td><td><font size="+1"><b>VE_CtoRe</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extracts the real part from a cartesian-complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoRe( fVector&nbsp;Re, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoRe( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoRe( Re:fVector; X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVF_CtoRe( fVector&nbsp;d_Re, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
void VFcu_CtoRe( fVector&nbsp;h_Re, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVF_CtoRe( d_Re:fVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_CtoRe( h_Re:fVector; h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The real part of the complex vector X is extracted and stored in Re.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#RetoC">VF_RetoC</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoReIm</b></font></td><td width="33%"><font size="+1"><b>VD_CtoReIm</b></font></td><td><font size="+1"><b>VE_CtoReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extracts the real and imaginary parts from a cartesian-complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoReIm( fVector&nbsp;Re, fVector&nbsp;Im, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoReIm( vector&lt;T&gt; Im, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoReIm( Re,&nbsp;Im:fVector; X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVF_CtoReIm( fVector&nbsp;d_Re, fVector&nbsp;d_Im, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
void VFcu_CtoReIm( fVector&nbsp;h_Re, fVector&nbsp;h_Im, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVF_CtoReIm( d_Re,&nbsp;d_Im:fVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_CtoReIm( h_Re,&nbsp;h_Im:fVector; h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The real and imaginary parts of the complex vector X are extracted and stored in Re and Im, resp.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoRe">VF_CtoRe</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#RetoC">VF_RetoC</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cubic"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cubic</b></font></td><td width="33%"><font size="+1"><b>VD_cubic</b></font></td><td><font size="+1"><b>VE_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cubic</b></font></td><td width="33%"><font size="+1"><b>VDx_cubic</b></font></td><td><font size="+1"><b>VEx_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFu_cubic</b></font></td><td width="33%"><font size="+1"><b>VDu_cubic</b></font></td><td><font size="+1"><b>VEu_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFux_cubic</b></font></td><td width="33%"><font size="+1"><b>VDux_cubic</b></font></td><td><font size="+1"><b>VEux_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cubic</b></font></td><td width="33%"><font size="+1"><b>VCD_cubic</b></font></td><td><font size="+1"><b>VCE_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_cubic</b></font></td><td width="33%"><font size="+1"><b>VCDx_cubic</b></font></td><td><font size="+1"><b>VCEx_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFu_cubic</b></font></td><td width="33%"><font size="+1"><b>VCDu_cubic</b></font></td><td><font size="+1"><b>VCEu_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFux_cubic</b></font></td><td width="33%"><font size="+1"><b>VCDux_cubic</b></font></td><td><font size="+1"><b>VCEux_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_cubic</b></font></td><td width="33%"><font size="+1"><b>VPD_cubic</b></font></td><td><font size="+1"><b>VPE_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPFu_cubic</b></font></td><td width="33%"><font size="+1"><b>VPDu_cubic</b></font></td><td><font size="+1"><b>VPEu_cubic</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cubic (third power)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cubic( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_cubic( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int VFu_cubic( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFux_cubic( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cubic( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_cubic( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);
<BR>int vector&lt;T&gt;::u_cubic( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::ux_cubic( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cubic( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_cubic( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function VFu_cubic( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFux_cubic( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_cubic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_cubic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_cubic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int VFucu_cubic( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFuxcu_cubic( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cudaVFu_cubic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFux_cubic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFux_cubic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int VFucu_cubic( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFuxcu_cubic( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_cubic( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_cubic( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_cubic( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_cubic( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_cubic( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cudaVFu_cubic( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFux_cubic( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFux_cubic( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFucu_cubic( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFuxcu_cubic( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = (X<sub>i</sub>)<sup>3</sup>
<BR>expanded versions: Y<sub>i</sub> = (A*X<sub>i</sub>+B)<sup>3</sup>
<P>&quot;unprotected&quot; versions (prefix <I>VFu_,&nbsp;&nbsp; VFux_</I>, etc.):
<BR>These functions do not perform any error handling, which makes them much faster (up to 50%) than the standard versions. The extended-precision complex (<I>VCEu_</I> and <I>VCEux_</I>) versions do not take some of the security measures present in the standard version and might fail for results very near the overflow limit; results near the underflow limit might be rendered as 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#square">VF_square</a>,&nbsp;&nbsp; <a href="#quartic">VF_quartic</a>,&nbsp;&nbsp; <a href="#sqrt">VF_sqrt</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="dataPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_dataPlot</b></font></td><td width="33%"><font size="+1"><b>VCD_dataPlot</b></font></td><td><font size="+1"><b>VCE_dataPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Plot of a complex vector into an existing Cartesian complex plane.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VCF_dataPlot( cfVector&nbsp;X, ui&nbsp;size, unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::dataPlot( unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VCF_dataPlot( X:cfVector; size:UIntSize; form:UInt; color:COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is plotted into a Cartesian complex plane that has been drawn previously by a call to either <I><a href="#autoPlot">VCF_autoPlot</a></I>, or <I><a href="#c2AutoPlot">VCF_2AutoPlot</a></I> or <I><a href="#drawAxes">V_drawAxes</a></I>.
<BR>For a description of the parameters form and color, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#c2AutoPlot">VCF_2AutoPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="deconvolve"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_deconvolve</b></font></td><td width="33%"><font size="+1"><b>VD_deconvolve</b></font></td><td><font size="+1"><b>VE_deconvolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Deconvolution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_deconvolve( fVector&nbsp;Y, fVector&nbsp;Flt, fVector&nbsp;X, fVector&nbsp;Rsp, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::deconvolve( vector&lt;T&gt; Flt, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Rsp&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_deconvolve( Y, Flt, X, Rsp:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_deconvolve( fVector&nbsp;d_Y, fVector&nbsp;d_Flt, fVector&nbsp;d_X, fVector&nbsp;d_Rsp, ui&nbsp;size&nbsp;);
<BR>void VFcu_deconvolve( fVector&nbsp;h_Y, fVector&nbsp;h_Flt, fVector&nbsp;h_X, fVector&nbsp;h_Rsp, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_deconvolve( d_Y,&nbsp;d_Flt,&nbsp;d_X,&nbsp;d_Rsp:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_deconvolve( h_Y,&nbsp;h_Flt,&nbsp;h_X,&nbsp;h_Rsp:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X is assumed to be the result of a convolution of some &quot;true&quot; profile with the response function Rsp; a deconvolution is attempted and stored in Y. A filter Flt is also calculated; if more than one vector is to be deconvolved with the same Rsp, use <I>VF_deconvolve</I> only once and use the filter Flt thus obtained to deconvolve other vectors by calling <I><a href="#filter">VF_filter</a></I>. The response has to be stored in Rsp in wrap-around order: the elements for zero and positive times (or whatever the independent variable is) are stored as Rsp<sub>0</sub> to Rsp<sub>size/2</sub> and the elements for negative times as Rsp<sub>size/2+1</sub> to Rsp<sub>size-1</sub>.
<BR>You may wish to use <I><a href="#rotate">VF_rotate</a></I> or <I><a href="#reflect">VF_reflect</a></I> to obtain the correct order when constructing the response vector.
<P>X, Y, Rsp, and Flt must all be of the same size, which has to be an integer power of 2. X may be overwritten by Y, Rsp may be overwritten by Flt, but X and Flt as well as Y and Rsp have to be distinct from each other.
<P>Mathematically, Flt is the inverse of the Fourier transform of Rsp. If the Fourier transform of Rsp contains elements equal to zero, all information is lost for the respective frequency and no reconstruction is possible. The best one can do in this case is to accept this loss and to deconvolve only up to those frequencies where still something is left to be reconstructed.
<BR>You are therefore advised not to use this function blindly but rather to inspect the Fourier transform of Rsp and decide what to do on the basis of your specific application. If you wish to use this function nevertheless, you may rely on the automatic editing of the filter, built into <I>VF_deconvolve</I>. Thereby, Flt is set to zero (instead of infinity) at those frequences where all information has been lost. You may set the threshold for this implicit editing by <I><a href="#setRspEdit">VF_setRspEdit</a></I>. In order to retrieve the threshold actually set, use <I><a href="#getRspEdit">VF_getRspEdit</a></I>.
<P>This deconvolution is based on the implicit assumption that X is periodic; if this is not the case, see the description of <I><a href="#convolve">VF_convolve</a></I> about how to avoid end effects.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_deconvolve</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.
<BR>If, by <I><a href="#setRspEdit">VF_setRspEdit</a></I>, you specified Trunc.Re = Trunc.Im = 0, SING errors may occur that are handled by setting Flt to &#177;HUGE_VAL at the respective frequency. During multiplication with the transform of X, this may lead to unhandled floating-point overflow errors (in case your guess of Rsp was wrong and there is some information left at the frequencies where you thought it was not).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#filter">VF_filter</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="delete"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_delete</b></font></td><td width="34%"><font size="+1"><b>VD_delete</b></font></td><td><font size="+1"><b>VE_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_delete</b></font></td><td width="34%"><font size="+1"><b>VCD_delete</b></font></td><td><font size="+1"><b>VCE_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_delete</b></font></td><td width="34%"><font size="+1"><b>VPD_delete</b></font></td><td><font size="+1"><b>VPE_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_delete</b></font></td><td width="17%"><font size="+1"><b>VBI_delete</b></font></td><td width="17%"><font size="+1"><b>VSI_delete</b></font></td><td width="17%"><font size="+1"><b>VLI_delete</b></font></td><td width="17%"><font size="+1"><b>VQI_delete</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_delete</b></font></td><td width="17%"><font size="+1"><b>VUB_delete</b></font></td><td width="17%"><font size="+1"><b>VUS_delete</b></font></td><td width="17%"><font size="+1"><b>VUL_delete</b></font></td><td width="17%"><font size="+1"><b>VUQ_delete</b></font></td><td><font size="+1"><b>VUI_delete</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Delete one element from a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_delete( fVector&nbsp;X, ui&nbsp;size, ui&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::delete( ui&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_delete( X:fVector; size, pos:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_delete( fVector&nbsp;d_X, ui&nbsp;size, ui&nbsp;pos&nbsp;);
<BR>void VFcu_delete( fVector&nbsp;h_X, ui&nbsp;size, ui&nbsp;pos&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_delete( d_X:fVector; size,&nbsp;pos:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_delete( h_X:fVector; size,&nbsp;pos:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This is one of the few functions where the input vector itself is changed, instead of being mapped onto an output vector. The element numbered pos is deleted from the vector, and all the following elements are shifted one position lower; the last element is left undefined.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#rotate">VF_rotate</a>,&nbsp;&nbsp; <a href="#insert">VF_insert</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="derivC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_derivC</b></font></td><td width="33%"><font size="+1"><b>VD_derivC</b></font></td><td><font size="+1"><b>VE_derivC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Derivative of an array with respect to an independent variable sampled at constant intervals</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_derivC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float DeltaT&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::derivC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, T DeltaT&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_derivC( Y,&nbsp;X:fVector; size:UIntSize; DeltaT:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_derivC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;DeltaT&nbsp;);
<BR>int cusdVF_derivC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_DeltaT&nbsp;);
<BR>void VFcu_derivC( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;DeltaT&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_derivC( d_Y,&nbsp;d_X:fVector; size:UIntSize; DeltaT:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_derivC( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_DeltaT:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_derivC( h_Y,&nbsp;h_X:fVector; size:UIntSize; DeltaT:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y(t) = dX(t) / dt.
<BR>The vector X is assumed to be a function of a variable t; the t values themselves are equally spaced. Therefore, only the spacing, DeltaT, must be passed to the function. By parabolic interpolation, the derivative of X with respect to t is calculated. This function does the inverse of the integration by <I><a href="#runintegralC">VF_runintegralC</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#derivV">VF_derivV</a>,&nbsp;&nbsp; <a href="#runintegralC">VF_runintegralC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="derivV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_derivV</b></font></td><td width="33%"><font size="+1"><b>VD_derivV</b></font></td><td><font size="+1"><b>VE_derivV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Derivative of one array with respect to another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_derivV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::derivV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_derivV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_derivV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>void VFcu_derivV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_derivV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_derivV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z(X) = dY(X) / dX.
<BR>The derivative of Y with respect to X is calculated by parabolic interpolation and stored in Z. If the elements of X are equally-spaced, it is better to use <I><a href="#derivC">VF_derivC</a></I>. The inverse procedure, i.e. integration, is performed by <I><a href="#runintegralV">VF_runintegralV</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#derivC">VF_derivC</a>,&nbsp;&nbsp; <a href="#runintegralV">VF_runintegralV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="destroyCudaWorkspace"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_destroyCudaWorkspace</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Destroy an <i>OptiVec for CUDA</i> workspace</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>overror_t V_destroyCudaWorkspace( V_CUDAWORKSPACE *wsp&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Delphi</td><td><font face="courier new">uses VecLib;
<BR>function V_destroyCudaWorkspace( wsp: PV_CUDAWORKSPACE&nbsp;): Integer;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Any <i>OptiVec for CUDA</i> workspaces created by <I><a href="#createCudaWorkspace">V_createCudaWorkspace</a></I> must be destroyed by this function, in order to release the allocated resources.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>0 if successful; non-zero if the workspace was invalid </td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap5">CudaOptiVec.htm, Chapter 5. Streams and Workspaces</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="distribution"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_distribution</b></font></td><td width="34%"><font size="+1"><b>VD_distribution</b></font></td><td><font size="+1"><b>VE_distribution</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_distribution</b></font></td><td width="17%"><font size="+1"><b>VBI_distribution</b></font></td><td width="17%"><font size="+1"><b>VSI_distribution</b></font></td><td width="17%"><font size="+1"><b>VLI_distribution</b></font></td><td width="17%"><font size="+1"><b>VQI_distribution</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_distribution</b></font></td><td width="17%"><font size="+1"><b>VUB_distribution</b></font></td><td width="17%"><font size="+1"><b>VUS_distribution</b></font></td><td width="17%"><font size="+1"><b>VUL_distribution</b></font></td><td width="17%"><font size="+1"><b>VUQ_distribution</b></font></td><td><font size="+1"><b>VUI_distribution</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Histogram or Distribution function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>ui VF_distribution( uiVector&nbsp;Abund, fVector&nbsp;Limits, ui&nbsp;nbins, fVector&nbsp;X, ui&nbsp;sizex, int&nbsp;mode&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;ui&gt;::distribution( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Limits, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, int&nbsp;mode=0&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_distribution( Abund:uiVector; Limits:fVector; bins:UIntSize; X:fVector; sizex:UIntSize; mode:Integer&nbsp;):UIntSize;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_distribution( ui&nbsp;*h_nOutside, uiVector&nbsp;d_Abund, fVector&nbsp;d_Limits, ui&nbsp;nbins, fVector&nbsp;d_X, ui&nbsp;sizex, int&nbsp;mode&nbsp;);
<BR>int cusdVF_distribution( ui&nbsp;*d_nOutside, uiVector&nbsp;d_Abund, fVector&nbsp;d_Limits, ui&nbsp;nbins, fVector&nbsp;d_X, ui&nbsp;sizex, int&nbsp;mode&nbsp;);
<BR>ui VFcu_distribution( uiVector&nbsp;h_Abund, fVector&nbsp;h_Limits, ui&nbsp;nbins, fVector&nbsp;h_X, ui&nbsp;sizex, int&nbsp;mode&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_distribution( var h_nOutside:UIntSize; d_Abund:uiVector; d_Limits:fVector; bins:UIntSize; d_X:fVector; sizex:UIntSize; mode:Integer&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_distribution( d_nOutside:PUIntSize; d_Abund:uiVector; d_Limits:fVector; bins:UIntSize; d_X:fVector; sizex:UIntSize; mode:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_distribution( h_Abund:uiVector; h_Limits:fVector; bins:UIntSize; h_X:fVector; sizex:UIntSize; mode:Integer&nbsp;):&nbsp;UIntSize;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function counts the number of elements of X falling into each of the intervals defined by Limits. The abundances thus determined are stored in Abund.
<BR>nbins is the number of elements of Limits, i.e. the number of intervals. sizex is the size of X.
<P>Limits must be in ascending order. The spacing between the elements of Limits need not necessarily be constant.
<P>The parameter mode specifies how to interpret the values given in Limits.
<BR>mode &gt; 0: Limits contains the upper limits of the intervals
<BR>mode &lt; 0: Limits contains the lower limits of the intervals
<BR>mode = 0: Limits contains the mid-points of the intervals. An element of X belongs to the element of Limits closest to it. In case of exactly equal distances, the interval with the lower index is chosen.
<BR>The interval defined by Limits<sub>0</sub> extends down to -HUGE_VAL, the interval defined by Limits<sub>nbins-1</sub> reaches up to +HUGE_VAL.
<P>The number of elements of X not falling into one of the intervals is returned. For mode &gt; 0, these are the elements greater than the highest limit. For mode &lt; 0, these are the elements smaller than the lowest limit.
<BR>For mode = 0, the return value is always zero, because the intervals are open on both sides. So every element of X is accounted for in Abund.
<P>In order to get the normalized distribution function, use the sequence
<BR><font face="courier new">VF_distribution( Abund, Limits, nbins, X, sizex, 0&nbsp;);
<BR><a href="#ItoF">V_UItoD</a>( Y, Abund, nbins&nbsp;);
<BR><a href="#divC">VD_divC</a>( Y, Y, nbins, VD_integralV(Limits,Y,nbins)&nbsp;);</font>
<P>After that, a call to
<BR><font face="courier new"><a href="#runintegralC">VD_runintegralC</a>( Y, Y, nbins, 1.0&nbsp;);</font>
<BR>yields the cumulated distribution function.
<P>Batch processing of several vectors of equal size is possible using <I><a href="MATRIX.HTM#Rows_distribution">MF_Rows_distribution</a></I> (preferred for C/C++) and <I><a href="MATRIX.HTM#Cols_distribution">MF_Cols_distribution</a></I> (for Delphi).</P>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>number of elements of X not accounted for in Abund</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#searchV">VF_searchV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="divC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divC</b></font></td><td width="34%"><font size="+1"><b>VD_divC</b></font></td><td><font size="+1"><b>VE_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divC</b></font></td><td width="34%"><font size="+1"><b>VCD_divC</b></font></td><td><font size="+1"><b>VCE_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divReC</b></font></td><td width="34%"><font size="+1"><b>VCD_divReC</b></font></td><td><font size="+1"><b>VCE_divReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divC</b></font></td><td width="34%"><font size="+1"><b>VPD_divC</b></font></td><td><font size="+1"><b>VPE_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divReC</b></font></td><td width="34%"><font size="+1"><b>VPD_divReC</b></font></td><td><font size="+1"><b>VPE_divReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_divC</b></font></td><td width="17%"><font size="+1"><b>VBI_divC</b></font></td><td width="17%"><font size="+1"><b>VSI_divC</b></font></td><td width="17%"><font size="+1"><b>VLI_divC</b></font></td><td width="17%"><font size="+1"><b>VQI_divC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_divC</b></font></td><td width="17%"><font size="+1"><b>VUB_divC</b></font></td><td width="17%"><font size="+1"><b>VUS_divC</b></font></td><td width="17%"><font size="+1"><b>VUL_divC</b></font></td><td width="17%"><font size="+1"><b>VUQ_divC</b></font></td><td><font size="+1"><b>VUI_divC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Divide by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_divC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VCF_divC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>void VCF_divReC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::divC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::divC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::divReC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;CRe&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_divC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VCF_divC( Y,&nbsp;X:cfVector; size:UIntSize; C:fComplex&nbsp;);
<BR>procedure VCF_divReC( Y,&nbsp;X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_divC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_divC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_divC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVCF_divReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);
<BR>int cusdVCF_divReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_CRe&nbsp;);
<BR>void VCFcu_divReC( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_divC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_divC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_divC( h_Y, h_X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>function cudaVCF_divReC( d_Y, d_X:cfVector; size:UIntSize; CRe:Single&nbsp;);
<BR>function cusdVCF_divReC( d_Y, d_X:cfVector; size:UIntSize; d_CRe:PSingle&nbsp;);
<BR>procedure VCFcu_divReC( h_Y, h_X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> / C
<BR>The integer versions perform an integer division, discarding the remainder; the remainder itself may be obtained by the functions of the <I><a href="#modC">VI_modC</a></I> family.
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe by which the complex vector is divided.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divrC">VF_divrC</a>,&nbsp;&nbsp; <a href="#modC">VF_modC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="divrC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrC</b></font></td><td width="34%"><font size="+1"><b>VD_divrC</b></font></td><td><font size="+1"><b>VE_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divrC</b></font></td><td width="34%"><font size="+1"><b>VCD_divrC</b></font></td><td><font size="+1"><b>VCE_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divrReC</b></font></td><td width="34%"><font size="+1"><b>VCD_divrReC</b></font></td><td><font size="+1"><b>VCE_divrReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_divrC</b></font></td><td width="34%"><font size="+1"><b>VDx_divrC</b></font></td><td><font size="+1"><b>VEx_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_divrC</b></font></td><td width="34%"><font size="+1"><b>VCDx_divrC</b></font></td><td><font size="+1"><b>VCEx_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divrC</b></font></td><td width="34%"><font size="+1"><b>VPD_divrC</b></font></td><td><font size="+1"><b>VPE_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divrReC</b></font></td><td width="34%"><font size="+1"><b>VPD_divrReC</b></font></td><td><font size="+1"><b>VPE_divrReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_divrC</b></font></td><td width="17%"><font size="+1"><b>VBI_divrC</b></font></td><td width="17%"><font size="+1"><b>VSI_divrC</b></font></td><td width="17%"><font size="+1"><b>VLI_divrC</b></font></td><td width="17%"><font size="+1"><b>VQI_divrC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_divrC</b></font></td><td width="17%"><font size="+1"><b>VUB_divrC</b></font></td><td width="17%"><font size="+1"><b>VUS_divrC</b></font></td><td width="17%"><font size="+1"><b>VUL_divrC</b></font></td><td width="17%"><font size="+1"><b>VUQ_divrC</b></font></td><td><font size="+1"><b>VUI_divrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse division: divide a constant by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_divrC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFx_divrC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>void VCF_divrC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>void VCFx_divrC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);
<BR>void VCF_divrReC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::divrC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;T&gt;::x_divrC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::divrC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_divrC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; A, complex&lt;T&gt; B, complex&lt;T&gt; C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::divrReC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;CRe&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_divrC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VFx_divrC( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;);
<BR>procedure VCF_divrC( Y,&nbsp;X:cfVector; size:UIntSize; C:fComplex&nbsp;);
<BR>procedure VCFx_divrC( Y,&nbsp;X:cfVector; size:UIntSize; A,&nbsp;B,&nbsp;C:fComplex&nbsp;);
<BR>procedure VCF_divrReC( Y,&nbsp;X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_divrC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_divrC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_divrC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cudaVFx_divrC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_divrC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>void VFxcu_divrC( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVCF_divrReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);
<BR>int cusdVCF_divrReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_CRe&nbsp;);
<BR>void VCFcu_divrReC( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_divrC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_divrC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_divrC( h_Y, h_X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>function cudaVFx_divrC( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;);
<BR>function cusdVFx_divrC( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;);
<BR>procedure VFxcu_divrC( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;);
<BR>function cudaVCF_divrReC( d_Y, d_X:cfVector; size:UIntSize; CRe:Single&nbsp;);
<BR>function cusdVCF_divrReC( d_Y, d_X:cfVector; size:UIntSize; d_CRe:PSingle&nbsp;);
<BR>procedure VCFcu_divrReC( h_Y, h_X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = C / X<sub>i</sub>
<BR>expanded versions: Y<sub>i</sub> = C / (A*X<sub>i</sub>+B)
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe which are divided by the complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none; for the floating-point versions, there are related functions that calculate 1.0 / X<sub>i</sub> and 1.0 / (A*X<sub>i</sub>+B): <I><a href="#inv">VF_inv</a></I> and <I><a href="#inv">VFx_inv</a></I>, respectively; both of these detect and handle SING errors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#inv">VF_inv</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#modC">VF_modC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="divrV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrV</b></font></td><td width="34%"><font size="+1"><b>VD_divrV</b></font></td><td><font size="+1"><b>VE_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divrV</b></font></td><td width="34%"><font size="+1"><b>VCD_divrV</b></font></td><td><font size="+1"><b>VCE_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divrReV</b></font></td><td width="34%"><font size="+1"><b>VCD_divrReV</b></font></td><td><font size="+1"><b>VCE_divrReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFs_divrV</b></font></td><td width="34%"><font size="+1"><b>VDs_divrV</b></font></td><td><font size="+1"><b>VEs_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_divrV</b></font></td><td width="34%"><font size="+1"><b>VDx_divrV</b></font></td><td><font size="+1"><b>VEx_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_divrV</b></font></td><td width="34%"><font size="+1"><b>VCDx_divrV</b></font></td><td><font size="+1"><b>VCEx_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_divrReV</b></font></td><td width="34%"><font size="+1"><b>VCDx_divrReV</b></font></td><td><font size="+1"><b>VCEx_divrReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divrV</b></font></td><td width="34%"><font size="+1"><b>VPD_divrV</b></font></td><td><font size="+1"><b>VPE_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divrReV</b></font></td><td width="34%"><font size="+1"><b>VPD_divrReV</b></font></td><td><font size="+1"><b>VPE_divrReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_divrV</b></font></td><td width="17%"><font size="+1"><b>VBI_divrV</b></font></td><td width="17%"><font size="+1"><b>VSI_divrV</b></font></td><td width="17%"><font size="+1"><b>VLI_divrV</b></font></td><td width="17%"><font size="+1"><b>VQI_divrV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_divrV</b></font></td><td width="17%"><font size="+1"><b>VUB_divrV</b></font></td><td width="17%"><font size="+1"><b>VUS_divrV</b></font></td><td width="17%"><font size="+1"><b>VUL_divrV</b></font></td><td width="17%"><font size="+1"><b>VUQ_divrV</b></font></td><td><font size="+1"><b>VUI_divrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Divide two vectors in reverse order</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_divrV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VFx_divrV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>void VCF_divrV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCF_divrReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCFx_divrV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFx_divrReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::divrV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::x_divrV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::divrV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::divrReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_divrV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_divrReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_divrV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFx_divrV( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);
<BR>procedure VCF_divrV( Z, X,&nbsp;Y:cfVector; size:UIntSize&nbsp;);
<BR>procedure VCF_divrReV( Z, X:cfVector; Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCFx_divrV( Z, X,&nbsp;Y:cfVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);
<BR>procedure VCFx_divrReV( Z, X:cfVector; Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVF_divrV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVFs_divrV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVFs_divrV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>int cudaVFx_divrV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_divrV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int cudaVCF_divrReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>int cudaVCFx_divrReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>int cusdVCFx_divrReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;*d_A, fComplex&nbsp;*d_B&nbsp;);
<BR>void VFcu_divrV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFscu_divrV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFxcu_divrV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>void VCFcu_divrReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);
<BR>void VCFxcu_divrV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, cfVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFxcu_divrReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_divrV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFs_divrV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFs_divrV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_divrV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_divrV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVCF_divrReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVCFx_divrReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;):&nbsp;IntBool;
<BR>function cusdVCFx_divrReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PfComplex&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_divrV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFscu_divrV( h_Z, h_X, h_Y:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VFxcu_divrV( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);
<BR>procedure VCFcu_divrReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCFxcu_divrReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = Y<sub>i</sub> / X<sub>i</sub>
<BR>expanded versions: Z<sub>i</sub> = Y<sub>i</sub> / (A*X<sub>i</sub>+B)
<BR>The complex floating-point versions exist in two variants: in the first variant (e.g., <I>VCF_divrV,&nbsp;&nbsp; VCFx_divrV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g., <I>VCF_divrReV</I> - &quot;division in reverse order: divide a real vector by a complex one&quot;).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divrC">VF_divrC</a>,&nbsp;&nbsp; <a href="#divrVI">VF_divrVI</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#modV">VF_modV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="divrVI"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrVI</b></font></td><td width="33%"><font size="+1"><b>VD_divrVI</b></font></td><td><font size="+1"><b>VE_divrVI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrVBI</b></font></td><td width="33%"><font size="+1"><b>VD_divrVBI</b></font></td><td><font size="+1"><b>VE_divrVBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrVSI</b></font></td><td width="33%"><font size="+1"><b>VD_divrVSI</b></font></td><td><font size="+1"><b>VE_divrVSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrVLI</b></font></td><td width="33%"><font size="+1"><b>VD_divrVLI</b></font></td><td><font size="+1"><b>VE_divrVLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrVQI</b></font></td><td width="33%"><font size="+1"><b>VD_divrVQI</b></font></td><td><font size="+1"><b>VE_divrVQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrVU</b></font></td><td width="33%"><font size="+1"><b>VD_divrVU</b></font></td><td><font size="+1"><b>VE_divrVU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrVUB</b></font></td><td width="33%"><font size="+1"><b>VD_divrVUB</b></font></td><td><font size="+1"><b>VE_divrVUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrVUS</b></font></td><td width="33%"><font size="+1"><b>VD_divrVUS</b></font></td><td><font size="+1"><b>VE_divrVUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrVUL</b></font></td><td width="33%"><font size="+1"><b>VD_divrVUL</b></font></td><td><font size="+1"><b>VE_divrVUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrVUQ</b></font></td><td width="33%"><font size="+1"><b>VD_divrVUQ</b></font></td><td><font size="+1"><b>VE_divrVUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrVUI</b></font></td><td width="33%"><font size="+1"><b>VD_divrVUI</b></font></td><td><font size="+1"><b>VE_divrVUI</b></font></td></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse division: divide the elements of an integer vector by corresponding elements of a floating-point vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_divrVI( fVector&nbsp;Z, fVector&nbsp;X, iVector&nbsp;Y,ui&nbsp;size&nbsp;);
<BR>void VF_divrVUB( fVector&nbsp;Z, fVector&nbsp;X, ubVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::divrVI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;int&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::divrVUS( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;unsigned short&gt;&amp;&nbsp;Y,&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_divrVI( Z, X:fVector; Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VF_divrVUL( Z, X:fVector; Y:ulVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_divrVI( fVector&nbsp;d_Z, fVector&nbsp;d_X, iVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVF_divrVUB( fVector&nbsp;d_Z, fVector&nbsp;d_X, ubVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>void VFcu_divrVI( fVector&nbsp;h_Z, fVector&nbsp;h_X, iVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFcu_divrVUB( fVector&nbsp;h_Z, fVector&nbsp;h_X, ubVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_divrVI( d_Z, d_X:fVector; d_Y:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_divrVUL( d_Z, d_X:fVector; d_Y:ulVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_divrVI( h_Z, h_X:fVector; h_Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VFcu_divrVUL( h_Z, h_X:fVector; h_Y:ulVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = Y<sub>i</sub> / X<sub>i</sub>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divrV">VF_divrV</a>,&nbsp;&nbsp; <a href="#divVI">VF_divVI</a>,&nbsp;&nbsp; <a href="#addVI">VF_addVI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="divV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divV</b></font></td><td width="34%"><font size="+1"><b>VD_divV</b></font></td><td><font size="+1"><b>VE_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFs_divV</b></font></td><td width="34%"><font size="+1"><b>VDs_divV</b></font></td><td><font size="+1"><b>VEs_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_divV</b></font></td><td width="34%"><font size="+1"><b>VDx_divV</b></font></td><td><font size="+1"><b>VEx_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divV</b></font></td><td width="34%"><font size="+1"><b>VCD_divV</b></font></td><td><font size="+1"><b>VCE_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divReV</b></font></td><td width="34%"><font size="+1"><b>VCD_divReV</b></font></td><td><font size="+1"><b>VCE_divReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_divV</b></font></td><td width="34%"><font size="+1"><b>VCDx_divV</b></font></td><td><font size="+1"><b>VCEx_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_divReV</b></font></td><td width="34%"><font size="+1"><b>VCDx_divReV</b></font></td><td><font size="+1"><b>VCEx_divReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divV</b></font></td><td width="34%"><font size="+1"><b>VPD_divV</b></font></td><td><font size="+1"><b>VPE_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divReV</b></font></td><td width="34%"><font size="+1"><b>VPD_divReV</b></font></td><td><font size="+1"><b>VPE_divReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_divV</b></font></td><td width="17%"><font size="+1"><b>VBI_divV</b></font></td><td width="17%"><font size="+1"><b>VSI_divV</b></font></td><td width="17%"><font size="+1"><b>VLI_divV</b></font></td><td width="17%"><font size="+1"><b>VQI_divV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_divV</b></font></td><td width="17%"><font size="+1"><b>VUB_divV</b></font></td><td width="17%"><font size="+1"><b>VUS_divV</b></font></td><td width="17%"><font size="+1"><b>VUL_divV</b></font></td><td width="17%"><font size="+1"><b>VUQ_divV</b></font></td><td><font size="+1"><b>VUI_divV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Divide two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_divV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VFs_divV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFx_divV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>void VCF_divV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCF_divReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCFx_divV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFx_divReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::divV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::s_divV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;T&gt;::x_divV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::divV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::divReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_divV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_divReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_divV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFs_divV( Z, X,&nbsp;Y:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VFx_divV( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);
<BR>procedure VCF_divV( Z, X,&nbsp;Y:cfVector; size:UIntSize&nbsp;);
<BR>procedure VCF_divReV( Z, X:cfVector; Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCFx_divV( Z, X,&nbsp;Y:cfVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);
<BR>procedure VCFx_divrReV( Z, X:cfVector; Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVF_divV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVFs_divV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVFs_divV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>int cudaVFx_divV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_divV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int cudaVCF_divReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>int cudaVCFx_divReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>int cusdVCFx_divReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;*d_A, fComplex&nbsp;*d_B&nbsp;);
<BR>void VFcu_divV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFscu_divV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFxcu_divV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>void VCFcu_divReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);
<BR>void VCFxcu_divV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, cfVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFxcu_divReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_divV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFs_divV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFs_divV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_divV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_divV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVCF_divReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVCFx_divReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;):&nbsp;IntBool;
<BR>function cusdVCFx_divReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PfComplex&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_divV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFscu_divV( h_Z, h_X, h_Y:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VFxcu_divV( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);
<BR>procedure VCFcu_divReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCFxcu_divReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = X<sub>i</sub> / Y<sub>i</sub>
<BR>scaled versions: Z<sub>i</sub> = C *&nbsp;(X<sub>i</sub> / Y<sub>i</sub>)
<BR>expanded versions: Z<sub>i</sub> = (A*X<sub>i</sub>+B) / Y<sub>i</sub>
<BR>The complex floating-point versions exist in two variants: in the first variant (e.g., <I>VCF_divV,&nbsp;&nbsp; VCFx_divV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g., <I>VCF_divReV</I> - &quot;divide by a real vector&quot;).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#divVI">VF_divVI</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#modV">VF_modV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="divVI"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divVI</b></font></td><td width="33%"><font size="+1"><b>VD_divVI</b></font></td><td><font size="+1"><b>VE_divVI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divVBI</b></font></td><td width="33%"><font size="+1"><b>VD_divVBI</b></font></td><td><font size="+1"><b>VE_divVBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divVSI</b></font></td><td width="33%"><font size="+1"><b>VD_divVSI</b></font></td><td><font size="+1"><b>VE_divVSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divVLI</b></font></td><td width="33%"><font size="+1"><b>VD_divVLI</b></font></td><td><font size="+1"><b>VE_divVLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divVQI</b></font></td><td width="33%"><font size="+1"><b>VD_divVQI</b></font></td><td><font size="+1"><b>VE_divVQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divVU</b></font></td><td width="33%"><font size="+1"><b>VD_divVU</b></font></td><td><font size="+1"><b>VE_divVU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divVUB</b></font></td><td width="33%"><font size="+1"><b>VD_divVUB</b></font></td><td><font size="+1"><b>VE_divVUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divVUS</b></font></td><td width="33%"><font size="+1"><b>VD_divVUS</b></font></td><td><font size="+1"><b>VE_divVUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divVUL</b></font></td><td width="33%"><font size="+1"><b>VD_divVUL</b></font></td><td><font size="+1"><b>VE_divVUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divVUQ</b></font></td><td width="33%"><font size="+1"><b>VD_divVUQ</b></font></td><td><font size="+1"><b>VE_divVUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divVUI</b></font></td><td width="33%"><font size="+1"><b>VD_divVUI</b></font></td><td><font size="+1"><b>VE_divVUI</b></font></td></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Element-wise division of a floating-point vector by an integer vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_divVI( fVector&nbsp;Z, fVector&nbsp;X, iVector&nbsp;Y,ui&nbsp;size&nbsp;);
<BR>void VF_divVUB( fVector&nbsp;Z, fVector&nbsp;X, ubVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::divVI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;int&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::divVUS( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;unsigned short&gt;&amp;&nbsp;Y,&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_divVI( Z, X:fVector; Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VF_divVUL( Z, X:fVector; Y:ulVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_divVI( fVector&nbsp;d_Z, fVector&nbsp;d_X, iVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVF_divVUB( fVector&nbsp;d_Z, fVector&nbsp;d_X, ubVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>void VFcu_divVI( fVector&nbsp;h_Z, fVector&nbsp;h_X, iVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFcu_divVUB( fVector&nbsp;h_Z, fVector&nbsp;h_X, ubVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_divVI( d_Z, d_X:fVector; d_Y:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_divVUL( d_Z, d_X:fVector; d_Y:ulVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_divVI( h_Z, h_X:fVector; h_Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VFcu_divVUL( h_Z, h_X:fVector; h_Y:ulVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = X<sub>i</sub> / Y<sub>i</sub>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#divrVI">VF_divrVI</a>,&nbsp;&nbsp; <a href="#addVI">VF_addVI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="drawAxes"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_drawAxes</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Draws a Cartesian coordinate system.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_drawAxes( long double Xmin, long double Xmax, long double Ymin, long double Ymax&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_drawAxes( xmin, xmax, ymin, ymax:Extended&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian coordinate system is drawn with the axes scaled according to the values passed as Xmin, Xmax, Ymin, and Ymax. Ten subdivision lines are drawn on each axis. No adjustment of this scaling is performed; if automatic fine-tuning of the scaling is desired, call <I><a href="#findAxes">V_findAxes</a></I> instead. Before using this function, either <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I> has to be called. <I>V_drawAxes</I> is used internally by all functions of the AutoPlot family.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#findAxes">V_findAxes</a>,&nbsp;&nbsp; <a href="#initPlot">V_initPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#xyDataPlot">VF_xyDataPlot</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="DtoF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_DtoF</b></font></td><td><font size="+1"><b>V_DtoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type conversions. See <I><a href="#FtoD">V_FtoD</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="element"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_element</b></font></td><td width="34%"><font size="+1"><b>VD_element</b></font></td><td><font size="+1"><b>VE_element</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_element</b></font></td><td width="34%"><font size="+1"><b>VCD_element</b></font></td><td><font size="+1"><b>VCE_element</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_element</b></font></td><td width="34%"><font size="+1"><b>VPD_element</b></font></td><td><font size="+1"><b>VPE_element</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_element</b></font></td><td width="17%"><font size="+1"><b>VBI_element</b></font></td><td width="17%"><font size="+1"><b>VSI_element</b></font></td><td width="17%"><font size="+1"><b>VLI_element</b></font></td><td width="17%"><font size="+1"><b>VQI_element</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_element</b></font></td><td width="17%"><font size="+1"><b>VUB_element</b></font></td><td width="17%"><font size="+1"><b>VUS_element</b></font></td><td width="17%"><font size="+1"><b>VUL_element</b></font></td><td width="17%"><font size="+1"><b>VUQ_element</b></font></td><td><font size="+1"><b>VUI_element</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Returns the value of a vector element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_element( fVector&nbsp;X, ui&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::element( ui&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_element( X:fVector; pos:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>float cudaVF_element( fVector&nbsp;d_X, ui&nbsp;pos&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_element( d_X:fVector; pos:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The element at the position pos is returned.
<BR>This function is needed to read elements of dynamically allocated vectors. Note that the bracket notation, X[pos] does not work for dynamic <i>OptiVec</i> vectors in Pascal/Delphi; also, it does not work for vectors in CUDA device memory.
<BR><I>VF_element</I> is &quot;read-only&quot;. This means, you c a n n o t write something like
<BR><font face="courier new">VF_element( X, 4&nbsp;) := 5;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>X[pos]</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Pelement">VF_Pelement</a>, &nbsp;&nbsp;<a href="#setElement">VF_setElement</a>, &nbsp;&nbsp;<a href="#getElement">VF_getElement</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="equ0"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_equ0</b></font></td><td width="33%"><font size="+1"><b>VD_equ0</b></font></td><td><font size="+1"><b>VE_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_equ0</b></font></td><td width="33%"><font size="+1"><b>VCD_equ0</b></font></td><td><font size="+1"><b>VCE_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_equ0</b></font></td><td width="33%"><font size="+1"><b>VPD_equ0</b></font></td><td><font size="+1"><b>VPE_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="17%"><font size="+1"><b>VI_equ0</b></font></td><td width="17%"><font size="+1"><b>VBI_equ0</b></font></td><td width="17%"><font size="+1"><b>VSI_equ0</b></font></td><td width="17%"><font size="+1"><b>VLI_equ0</b></font></td><td width="17%"><font size="+1"><b>VQI_equ0</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="17%"><font size="+1"><b>VU_equ0</b></font></td><td width="17%"><font size="+1"><b>VUB_equ0</b></font></td><td width="17%"><font size="+1"><b>VUS_equ0</b></font></td><td width="17%"><font size="+1"><b>VUL_equ0</b></font></td><td width="17%"><font size="+1"><b>VUQ_equ0</b></font></td><td><font size="+1"><b>VUI_equ0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>(Re-) initialize a vector with zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_equ0( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::equ0();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_equ0( X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_equ0( fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_equ0( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_equ0( d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_equ0( h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="equ1"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_equ1</b></font></td><td width="33%"><font size="+1"><b>VD_equ1</b></font></td><td><font size="+1"><b>VE_equ1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_equ1</b></font></td><td width="33%"><font size="+1"><b>VCD_equ1</b></font></td><td><font size="+1"><b>VCE_equ1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_equ1</b></font></td><td width="33%"><font size="+1"><b>VPD_equ1</b></font></td><td><font size="+1"><b>VPE_equ1</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize a vector with 1.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_equ1( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::equ1();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_equ1( X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_equ1( fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_equ1( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_equ1( d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_equ1( h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = 1.0
<BR>In the cartesian complex versions, the imaginary parts are set to zero. In the polar complex versions, all elements are set to {1.0 @ 0}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ0">VF_equ0</a>,&nbsp;&nbsp; <a href="#equm1">VF_equm1</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="equC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_equC</b></font></td><td width="34%"><font size="+1"><b>VD_equC</b></font></td><td><font size="+1"><b>VE_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_equC</b></font></td><td width="34%"><font size="+1"><b>VCD_equC</b></font></td><td><font size="+1"><b>VCE_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_equC</b></font></td><td width="34%"><font size="+1"><b>VPD_equC</b></font></td><td><font size="+1"><b>VPE_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_equC</b></font></td><td width="17%"><font size="+1"><b>VBI_equC</b></font></td><td width="17%"><font size="+1"><b>VSI_equC</b></font></td><td width="17%"><font size="+1"><b>VLI_equC</b></font></td><td width="17%"><font size="+1"><b>VQI_equC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_equC</b></font></td><td width="17%"><font size="+1"><b>VUB_equC</b></font></td><td width="17%"><font size="+1"><b>VUS_equC</b></font></td><td width="17%"><font size="+1"><b>VUL_equC</b></font></td><td width="17%"><font size="+1"><b>VUQ_equC</b></font></td><td><font size="+1"><b>VUI_equC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initializes a vector with a constant value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_equC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::equC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_equC( X:fVector; size:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_equC( fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_equC( fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>void VFcu_equC( fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_equC( d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_equC( d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_equC( h_X:fVector; size:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = C</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ0">VF_equ0</a>,&nbsp;&nbsp; <a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a>,&nbsp;&nbsp; <a href="#comb">VF_comb</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="equm1"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_equm1</b></font></td><td width="33%"><font size="+1"><b>VD_equm1</b></font></td><td><font size="+1"><b>VE_equm1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_equm1</b></font></td><td width="33%"><font size="+1"><b>VCD_equm1</b></font></td><td><font size="+1"><b>VCE_equm1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_equm1</b></font></td><td width="33%"><font size="+1"><b>VPD_equm1</b></font></td><td><font size="+1"><b>VPE_equm1</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize a vector with -1.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_equm1( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::equm1();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_equm1( X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_equm1( fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_equm1( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_equm1( d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_equm1( h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = -1.0
<BR>In the cartesian complex versions, the imaginary parts are set to zero. In the polar complex versions, all elements are set to { 1.0 @ <font face="symbol">p</font> }.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ0">VF_equ0</a>,&nbsp;&nbsp; <a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="equV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_equV</b></font></td><td width="34%"><font size="+1"><b>VD_equV</b></font></td><td><font size="+1"><b>VE_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_equV</b></font></td><td width="34%"><font size="+1"><b>VCD_equV</b></font></td><td><font size="+1"><b>VCE_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_equV</b></font></td><td width="34%"><font size="+1"><b>VDx_equV</b></font></td><td><font size="+1"><b>VEx_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_equV</b></font></td><td width="34%"><font size="+1"><b>VCDx_equV</b></font></td><td><font size="+1"><b>VCEx_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_equV</b></font></td><td width="34%"><font size="+1"><b>VPD_equV</b></font></td><td><font size="+1"><b>VPE_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_equV</b></font></td><td width="17%"><font size="+1"><b>VBI_equV</b></font></td><td width="17%"><font size="+1"><b>VSI_equV</b></font></td><td width="17%"><font size="+1"><b>VLI_equV</b></font></td><td width="17%"><font size="+1"><b>VQI_equV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_equV</b></font></td><td width="17%"><font size="+1"><b>VUB_equV</b></font></td><td width="17%"><font size="+1"><b>VUS_equV</b></font></td><td width="17%"><font size="+1"><b>VUL_equV</b></font></td><td width="17%"><font size="+1"><b>VUQ_equV</b></font></td><td><font size="+1"><b>VUI_equV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Copies one vector to another.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_equV( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>void VFx_equV( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::equV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>void vector&lt;T&gt;::x_equV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_equV( Y,&nbsp;X:fVector; size:UIntSize&nbsp;);
<BR>procedure VFx_equV( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_equV( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_equV( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_equV( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>void VFcu_equV( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>void VFxcu_equV( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>&nbsp;<BR>int cudaVF_equVhost( fVector&nbsp;d_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VF_equVdevice( fVector&nbsp;h_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_equV( d_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_equV( d_Y,&nbsp;d_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);
<BR>function cusdVFx_equV( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;);
<BR>procedure VFcu_equV( h_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;);
<BR>procedure VFxcu_equV( h_Y,&nbsp;h_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);
<BR>&nbsp;<BR>function cudaVF_equVhost( d_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VF_equVdevice( h_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = X<sub>i</sub>
<BR>expanded versions: Y<sub>i</sub> = A *&nbsp;X<sub>i</sub> + B
<P>CUDA versions: <i>cudaVF_equVhost</i> and <i>VF_equVdevice</i> transfer vectors from host to device memory and vice versa.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ0">VF_equ0</a>,&nbsp;&nbsp; <a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="erf"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_erf</b></font></td><td width="33%"><font size="+1"><b>VD_erf</b></font></td><td><font size="+1"><b>VE_erf</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_erf</b></font></td><td width="33%"><font size="+1"><b>VDx_erf</b></font></td><td><font size="+1"><b>VEx_erf</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Error function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_erf( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_erf( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::erf( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_erf( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_erf( Y,X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_erf( Y,X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_erf( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_erf( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_erf( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_erf( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_erf( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_erf( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_erf( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_erf( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_erf( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_erf( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = erf( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;erf( A*X<sub>i</sub>+B&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>this function should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#erfc">VF_erfc</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="erfc"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_erfc</b></font></td><td width="33%"><font size="+1"><b>VD_erfc</b></font></td><td><font size="+1"><b>VE_erfc</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_erfc</b></font></td><td width="33%"><font size="+1"><b>VDx_erfc</b></font></td><td><font size="+1"><b>VEx_erfc</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Complementary error function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_erfc( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_erfc( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::erfc( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_erfc( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_erfc( Y,X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_erfc( Y,X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_erfc( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_erfc( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_erfc( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_erfc( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_erfc( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_erfc( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_erfc( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_erfc( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_erfc( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_erfc( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 1.0 - erf( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;(1.0 - erf( A*X<sub>i</sub>+B&nbsp;))</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>this function should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#erf">VF_erf</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Euclid"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Euclid</b></font></td><td width="33%"><font size="+1"><b>VD_Euclid</b></font></td><td><font size="+1"><b>VE_Euclid</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculates the Euclidean norm of a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_Euclid( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::Euclid();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_Euclid( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_Euclid( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_Euclid( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_Euclid( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_Euclid( var&nbsp;h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_Euclid( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_Euclid( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>norm = sqrt( sum( X<sub>i</sub><sup>2</sup>&nbsp;)&nbsp;)
<BR>The Euclidean norm of a vector is defined as the square-root of the scalar product of the vector with itself.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but beware of a possible overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The Euclidean norm is returned</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#rms">VF_rms</a>,&nbsp;&nbsp; <a href="#scalprod">VF_scalprod</a>,&nbsp;&nbsp; <a href="#xprod">VF_xprod</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="exp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_exp</b></font></td><td width="33%"><font size="+1"><b>VD_exp</b></font></td><td><font size="+1"><b>VE_exp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_exp</b></font></td><td width="33%"><font size="+1"><b>VCD_exp</b></font></td><td><font size="+1"><b>VCE_exp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_exp</b></font></td><td width="33%"><font size="+1"><b>VDx_exp</b></font></td><td><font size="+1"><b>VEx_exp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_exp</b></font></td><td width="33%"><font size="+1"><b>VCDx_exp</b></font></td><td><font size="+1"><b>VCEx_exp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_exptoP</b></font></td><td width="33%"><font size="+1"><b>VCD_exptoP</b></font></td><td><font size="+1"><b>VCE_exptoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Exponential function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_exp( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_exp( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VCF_exptoP( pfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::exp( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_exp( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>int vector&lt;polar&lt;T&gt;&gt;::exptoP( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_exp( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_exp( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VCF_exptoP( Y:pfVector; X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_exp( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_exp( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_exp( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_exp( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_exp( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_exp( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_exp( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_exp( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_exp( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_exp( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = exp( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;exp( A*X<sub>i</sub>+B&nbsp;)
<BR>Euler's constant <I>e</I> is raised to the X<sub>i</sub>'th power.
<BR>For cartesian complex numbers, the result can be stored either in cartesian complex format (<I>VCF_exp</I>), or in polar coordinates (<I>VCF_exptoP</I>).
<BR>Variants of the exponential function, like its complement (<I><a href="#expc">VF_expc</a></I>), the hyperbolic functions (e.g. <I><a href="#sinh">VF_sinh</a></I>), or the Gaussian distribution (<I><a href="#Gauss">VF_Gauss</a></I>) are also available; see <a href="HANDBOOK.HTM#chap4_6_7">chapter&nbsp;4.6.7</a> about &quot;Exponentials&quot; before using <I>VF_exp</I> for sums or other combinations of exponentials - maybe the desired function already exists.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#log">VF_log</a>,&nbsp;&nbsp; <a href="#expc">VF_expc</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#powexp">VF_powexp</a>,&nbsp;&nbsp; <a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp2">VF_exp2</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a>,&nbsp;&nbsp; <a href="#log">VPF_logtoC</a>,&nbsp;&nbsp; exp</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="exp2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_exp2</b></font></td><td width="33%"><font size="+1"><b>VD_exp2</b></font></td><td><font size="+1"><b>VE_exp2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_exp2</b></font></td><td width="33%"><font size="+1"><b>VDx_exp2</b></font></td><td><font size="+1"><b>VEx_exp2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Exponential function to the basis 2</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_exp2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_exp2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::exp2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_exp2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_exp2( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_exp2( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_exp2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_exp2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_exp2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_exp2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_exp2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_exp2( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_exp2( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_exp2( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_exp2( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_exp2( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 2 <sup>X</sup><font size="-1">i</font>
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;2 <sup>(A*X</sup><font size="-1">i</font><sup>+B)</sup>
<BR>Two is raised to the X<sub>i</sub>'th power. These function names are used as synonyms for <I><a href="#pow2">VF_pow2</a></I> etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#exp10">VF_exp10</a>,&nbsp;&nbsp; <a href="#ipow2">VF_ipow2</a>,&nbsp;&nbsp; <a href="#scale2">VF_scale2</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="exp10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_exp10</b></font></td><td width="33%"><font size="+1"><b>VD_exp10</b></font></td><td><font size="+1"><b>VE_exp10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_exp10</b></font></td><td width="33%"><font size="+1"><b>VDx_exp10</b></font></td><td><font size="+1"><b>VEx_exp10</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Exponential function to the basis 10</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_exp10( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_exp10( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::exp10( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_exp10( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_exp10( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_exp10( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_exp10( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_exp10( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_exp10( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_exp10( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_exp10( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_exp10( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_exp10( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_exp10( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_exp10( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_exp10( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 10 <sup>X</sup><font size="-1">i</font>
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;10 <sup>(A*X</sup><font size="-1">i</font><sup>+B)</sup>
<BR>Ten is raised to the X<sub>i</sub>'th power. These function names are used as synonyms for <I><a href="#pow10">VF_pow10</a></I> etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#exp2">VF_exp2</a>,&nbsp;&nbsp; <a href="#ipow10">VF_ipow10</a>,&nbsp;&nbsp; <a href="#scale10">VF_scale10</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="expArbBase"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_expArbBase</b></font></td><td width="33%"><font size="+1"><b>VD_expArbBase</b></font></td><td><font size="+1"><b>VE_expArbBase</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_expArbBase</b></font></td><td width="33%"><font size="+1"><b>VCD_expArbBase</b></font></td><td><font size="+1"><b>VCE_expArbBase</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_expArbBase</b></font></td><td width="33%"><font size="+1"><b>VDx_expArbBase</b></font></td><td><font size="+1"><b>VEx_expArbBase</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_expArbBase</b></font></td><td width="33%"><font size="+1"><b>VCDx_expArbBase</b></font></td><td><font size="+1"><b>VCEx_expArbBase</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Exponential function of an arbitrary base</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_expArbBase( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;Base&nbsp;);
<BR>int VFx_expArbBase( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;Base, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::expArbBase( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;Base&nbsp;);
<BR>int vector&lt;T&gt;::x_expArbBase( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;Base, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_expArbBase( Y,&nbsp;X:fVector; size:UIntSize; Base:Single&nbsp;):&nbsp;IntBool;
<BR>function VFx_expArbBase( Y,&nbsp;X:fVector; size:UIntSize; Base,&nbsp;A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_expArbBase( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Base&nbsp;);
<BR>int cusdVF_expArbBase( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_Base&nbsp;);
<BR>int cudaVFx_expArbBase( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Base, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_expArbBase( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_Base, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_expArbBase( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Base&nbsp;);
<BR>int VFxcu_expArbBase( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Base, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_expArbBase( d_Y, d_X:fVector; size:UIntSize; Base:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_expArbBase( d_Y, d_X:fVector; size:UIntSize; d_Base:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_expArbBase( d_Y, d_X:fVector; size:UIntSize; Base,&nbsp;A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_expArbBase( d_Y, d_X:fVector; size:UIntSize; d_Base,&nbsp;d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_expArbBase( h_Y, h_X:fVector; size:UIntSize; Base:Single&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_expArbBase( h_Y, h_X:fVector; size:UIntSize; Base,&nbsp;A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = Base <sup>X</sup><font size="-1">i</font>
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;Base <sup>(A*X</sup><font size="-1">i</font><sup>+B)</sup>
<BR>Base must be positive and non-zero in the real-number versions. In the complex versions, Base must be non-zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="expc"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_expc</b></font></td><td width="33%"><font size="+1"><b>VD_expc</b></font></td><td><font size="+1"><b>VE_expc</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_expc</b></font></td><td width="33%"><font size="+1"><b>VDx_expc</b></font></td><td><font size="+1"><b>VEx_expc</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Complementary exponential function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_expc( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_expc( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::expc( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_expc( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_expc( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_expc( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_expc( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_expc( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_expc( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_expc( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_expc( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_expc( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_expc( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_expc( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_expc( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_expc( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 1 - exp( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;(1 - exp [A*X<sub>i</sub> + B ])
<BR>The difference between 1.0 and the exponential function of X<sub>i</sub> is calculated. Note that the expc function is directly available from the 80x87 coprocessor in high accuracy; in fact, it is the exponential function itself that is internally calculated via the expc function. The expc function is often encountered in the natural sciences for the description of decay and growth processes.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#log">VF_log</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp2">VF_exp2</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a></I>,&nbsp;&nbsp;exp</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="expmx2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_expmx2</b></font></td><td width="33%"><font size="+1"><b>VD_expmx2</b></font></td><td><font size="+1"><b>VE_expmx2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_expmx2</b></font></td><td width="33%"><font size="+1"><b>VDx_expmx2</b></font></td><td><font size="+1"><b>VEx_expmx2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Exponential function of the negative square of the argument</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_expmx2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_expmx2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::expmx2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_expmx2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_expmx2( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_expmx2( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_expmx2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_expmx2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_expmx2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_expmx2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_expmx2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_expmx2( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_expmx2( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_expmx2( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_expmx2( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_expmx2( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = exp( -X<sub>i</sub><sup>2</sup>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;exp( -(A*X<sub>i</sub>+B)<sup>2</sup>&nbsp;)
<BR>This function yields a bell-shaped curve similar to the Gaussian function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>This function should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#log">VF_log</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a>,&nbsp;&nbsp; <a href="#sech2">VF_sech2</a>,&nbsp;&nbsp; <a href="#Lorentz">VF_Lorentz</a>,&nbsp;&nbsp; exp</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="FFT"></a><a name="FFTtoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_FFT</b></font></td><td width="33%"><font size="+1"><b>VD_FFT</b></font></td><td><font size="+1"><b>VE_FFT</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>VFb_FFT</b></font></td><td width="33%"><font size="+1"><b>VDb_FFT</b></font></td><td><font size="+1"><b>VEb_FFT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_FFTtoC</b></font></td><td width="33%"><font size="+1"><b>VD_FFTtoC</b></font></td><td><font size="+1"><b>VE_FFTtoC</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>VFb_FFTtoC</b></font></td><td width="33%"><font size="+1"><b>VDb_FFTtoC</b></font></td><td><font size="+1"><b>VEb_FFTtoC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_FFT</b></font></td><td width="33%"><font size="+1"><b>VCD_FFT</b></font></td><td><font size="+1"><b>VCE_FFT</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFb_FFT</b></font></td><td width="33%"><font size="+1"><b>VCDb_FFT</b></font></td><td><font size="+1"><b>VCEb_FFT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Fast Fourier transform</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_FFT( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;dir&nbsp;);
<BR>void VCF_FFT( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, int&nbsp;dir&nbsp;);
<BR>void VF_FFTtoC( cfVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>void VFb_FFT( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;dir; fVector&nbsp;Buf&nbsp;);
<BR>void VCFb_FFT( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, int&nbsp;dir; cfVector&nbsp;Buf&nbsp;);
<BR>void VFb_FFTtoC( cfVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size; cfVector&nbsp;Buf&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::FFT( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, int&nbsp;dir=1&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::FFT( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, int&nbsp;dir=1&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::FFTtoC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>void vector&lt;T&gt;::b_FFT( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, int&nbsp;dir, vector&lt;T&gt;&amp;&nbsp;Buf&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::b_FFT( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, int&nbsp;dir, vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Buf&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::b_FFTtoC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Buf&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_FFT( Y,&nbsp;X:fVector; size:UIntSize; dir:Integer&nbsp;);
<BR>procedure VCF_FFT( Y,&nbsp;X:cfVector; size:UIntSize; dir:Integer&nbsp;);
<BR>procedure VF_FFTtoC( Y:cfVector; X:fVector; size:UIntSize&nbsp;);
<BR>procedure VFb_FFT( Y,&nbsp;X:fVector; size:UIntSize; dir:Integer; Buf:&nbsp;fVector&nbsp;);
<BR>procedure VCFb_FFT( Y,&nbsp;X:cfVector; size:UIntSize; dir:Integer; Buf:&nbsp;cfVector&nbsp;);
<BR>procedure VFb_FFTtoC( Y:cfVector; X:fVector; size:UIntSize; Buf:&nbsp;cfVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_FFT( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;dir&nbsp;);
<BR>int cudaVCF_FFT( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, int&nbsp;dir&nbsp;);
<BR>int cudaVF_FFTtoC( cfVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_FFT( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, int&nbsp;dir&nbsp;);
<BR>void VCFcu_FFT( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, int&nbsp;dir&nbsp;);
<BR>void VFcu_FFTtoC( cfVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd, VCFstd;
<BR>function cudaVF_FFT( d_Y,&nbsp;d_X:fVector; size:UIntSize; dir:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVCF_FFT( d_Y,&nbsp;d_X:cfVector; size:UIntSize; dir:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_FFTtoC( d_Y:cfVector; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_FFT( h_Y,&nbsp;h_X:fVector; size:UIntSize; dir:Integer&nbsp;);
<BR>procedure VCFcu_FFT( h_Y,&nbsp;h_X:cfVector; size:UIntSize; dir:Integer&nbsp;);
<BR>procedure VFcu_FFTtoC( h_Y:cfVector; h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The Fourier transform of X is calculated and stored in Y. A Fast Fourier Transform algorithm is used that requires size to be a power of 2. The forward transform is obtained by setting dir = 1, the inverse (or backward) transform by setting dir = -1. By convention, the inverse transform involves scaling the result by the factor <I>1.0/size</I> (so as to ensure that the resul of one forward and one backward transform yields &#x2013; within round-off error &#x2013; the original vector). Since it is sometimes desirable to skip this implicit scaling, <I>VF_FFT</I> offers the possibility to do so: specify dir = -2 in this case.
<BR>Complex version: Both X and the output Y are complex vectors.
<BR>Real-to-complex version: The input vector X is real. The output vector is complex. As this function can only perform a forward transform, no argument &quot;dir&quot; is needed.
<BR>Purely real version: For the forward transform, X is a real vector. The output Y is also defined as fVector, although it consists of complex numbers. These are packed in a special way such as to fit into the same amount of memory as the original real vector X. The order of storage in Y is indicated in the following table (N=size, U is the uncompressed Fourier Transform of X):
<BR>&nbsp;
<table border width="100%">
<tr valign="TOP">
<td>Y<sub>0</sub></td><td>Y<sub>1</sub></td><td>Y<sub>2</sub>
</td><td>Y<sub>3</sub></td><td>&nbsp;&nbsp;.....&nbsp;&nbsp;
</td><td>Y<sub>N-2</sub></td><td>Y<sub>N-1</sub></td></tr>
<tr valign="TOP">
<td>U<sub>0</sub>.Re</td><td>U<sub>N/2</sub>.Re</td><td>U<sub>1</sub>.Re
</td><td>U<sub>1</sub>.Im</td><td>&nbsp;&nbsp;.....&nbsp;&nbsp;
</td><td>U<sub>N/2-1</sub>.Re</td><td>U<sub>N/2-1</sub>.Im</td></tr></table>
<BR>The reason for this packing is the following. If the size real data points of X represent a function of the time, X = g(t), then the forward transform yields a function U = G(f) in the frequency domain. In principle, U consists of size+1 complex data points: size/2 points for positive frequencies, another size/2 points for negative frequencies, and one point at frequency zero.
<BR>For the Fourier Transform of a real vector, the symmetry relation G(-f) = |G(f)|<sup>*</sup> holds (the asterisc denoting the complex conjugate). This means that the points at negative frequencies need not be stored; all information is already contained in the positive frequency half. Moreover, the zeroth and the size2'th element of the transform are both purely real. Therefore, only these two real and size/2-1 complex data points have to be stored - which exactly fit into the same amount of memory as the original size real data points of X. This allows X to be overwritten by its transform, if desired.
<P>For the real version of the inverse transform, X has to be a complex vector packed in the way just described, and a real-valued vector Y is obtained.
<P>For the Fourier Transform of several vectors of equal size, we recommend to copy the individual vectors into the rows (C/C++) or the columns (Pascal/Delphi) of a matrix and to call <a href="MATRIX.HTM#Rows_FFT">MF_Rows_FFT</a> or <a href="MATRIX.HTM#Cols_FFT">MF_Cols_FFT</a>, respectively. Depending on the size of the individual vectors, this way is more efficient than the individual processing already from about 4 vectors on.
<P><i>VFb_FFT, VFb_FFTtoC</i> and <i>VCFb_FFT</i> take a buffer vector <i>Buf</i> as an additional argument. They are slightly more efficient than the un-buffered versions. <i>Buf</i> must have (at least) the same size as X and Y.
<P>For historical reasons, there exist special versions with the prefixes <I>VFp_, &nbsp;VFs_</I> and <I>VFl_</I>. They are deprecated and may be removed in future versions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, an error message &quot;Size must be an integer power of 2&quot; is generated and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#filter">VF_filter</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="filter"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_filter</b></font></td><td width="33%"><font size="+1"><b>VD_filter</b></font></td><td><font size="+1"><b>VE_filter</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_filter</b></font></td><td width="33%"><font size="+1"><b>VCD_filter</b></font></td><td><font size="+1"><b>VCE_filter</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Frequency filtering</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_filter(fVector&nbsp;Y, fVector&nbsp;X, fVector&nbsp;Flt, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::filter( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Flt&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_filter( Y, X, Flt:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_filter(fVector&nbsp;d_Y, fVector&nbsp;d_X, fVector&nbsp;d_Flt, ui&nbsp;size&nbsp;);
<BR>void VFcu_filter(fVector&nbsp;h_Y, fVector&nbsp;h_X, fVector&nbsp;h_Flt, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_filter( d_Y,&nbsp;d_X,&nbsp;d_Flt:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_filter( h_Y,&nbsp;h_X,&nbsp;h_Flt:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A frequency filter Flt is applied to the vector X. Internally, this is done by performing a Fourier transform on X, multiplying the transform with Flt and transforming the product back into the time domain.
<P>Complex versions: X, Y and the filter Flt are complex vectors.
<BR>Real versions: X and Y are real. Flt has to be in the packed complex format that is obtained by Fourier transforming a real vector with <I><a href="#FFT">VF_FFT</a></I> (see that function for the description of the packed complex format) or by using <I><a href="#convolve">VF_convolve</a></I>.
<P>For purely real filter functions known analytically, construct your filter by first evaluating it for a real vector of size/2+1 elements, and subsequently copy this real vector into Flt, as in the following example (<I>f<sub>Nyquist</sub></I> = 0.5 / <I>sampling_interval</I>; the desired cutoff frequency is <I>f<sub>CutOff</sub></I>):<BR>&nbsp;</td></tr>
<tr valign="TOP">
<td>Example C/C++:</td><td><font face="courier new">float&nbsp;Coeffs[3] = {1.0, 1.4142135, 1.0}; 
<BR>fVector&nbsp;Flt = <a href="#vector0">VF_vector0</a>( size&nbsp;);
<BR>fVector&nbsp;RealFlt = <a href="#vector">VF_vector</a>( size/2+1&nbsp;);
<BR>fVector&nbsp;Freq = VF_vector( size/2+1&nbsp;);
<BR><a href="#ramp">VF_ramp</a>( Freq, size/2+1, 0, (fNyquist / fCutOff) / (size/2)&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;  /*&nbsp;reduced frequencies from 0 to fNyquist / fCutOff */
<BR><a href="#poly">VF_poly</a>( RealFlt, Freq, size/2+1, Coeffs, 2&nbsp;);
<BR><a href="#inv">VF_inv</a>( RealFlt, RealFlt, size/2+1&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;  /*&nbsp; calc. response from coeffs of this 2nd order filter */
<BR><a href="#RetoC">VF_RetoC</a>( (cfVector)Flt, RealFlt, size/2&nbsp;); 
<BR>&nbsp;&nbsp;&nbsp; /*&nbsp;the imaginary elements remain 0 */
<BR>Flt[1] = RealFlt[ size/2 ];   /*&nbsp;response at Nyquist frequency */
<BR>VF_filter( Y, X, Flt, size );  /*&nbsp;apply the just constructed filter */</font><BR>&nbsp;</td></tr>
<tr valign="TOP">
<td>The same example for Pascal/Delphi:</td><td><font face="courier new">const Coeffs: array[0..2] of Single = (1.0, 1.4142135, 1.0);
<BR>var Flt, RealFlt, Freq: fVector;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;size_2: UIntSize;
<BR>begin
<BR>&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;size_2 := size div 2;
<BR>&nbsp;&nbsp;Flt := <a href="#vector0">VF_vector0</a>( size&nbsp;);
<BR>&nbsp;&nbsp;RealFlt := <a href="#vector">VF_vector</a>( size_2+1&nbsp;);
<BR>&nbsp;&nbsp;Freq := VF_vector( size_2+1&nbsp;);
<BR>&nbsp;&nbsp;<a href="#ramp">VF_ramp</a>( Freq, size_2+1, 0, (fNyquist / fCutOff) / (size_2)&nbsp;); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*&nbsp;reduced frequencies from 0 to fNyquist / fCutOff *)
<BR>&nbsp;&nbsp;<a href="#poly">VF_poly</a>( RealFlt, Freq, size_2+1, @Coeffs, 2&nbsp;);
<BR>&nbsp;&nbsp;<a href="#inv">VF_inv</a>( RealFlt, RealFlt, size_2+1&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*&nbsp; calc. response from coeffs of this 2nd order filter *)
<BR>&nbsp;&nbsp;<a href="#RetoC">VF_RetoC</a>( cfVector(Flt), RealFlt, size_2&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*&nbsp;the imaginary elements remain 0 *)
<BR>&nbsp;&nbsp;<a href="#Pelement">VF_Pelement</a>( Flt, 1&nbsp;)^ := <a href="#element">VF_element</a>( RealFlt, size_2&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*&nbsp;response at Nyquist frequency *)
<BR>&nbsp;&nbsp;VF_filter( Y, X, Flt, size );  (*&nbsp;apply the just constructed filter *)
<BR>end;</font>
<P>If X is non-periodic, both ends of the filtered function may be spoiled by wrap-around. See <I><a href="#convolve">VF_convolve</a></I> about how to avoid end-effects by embedding X in a larger vector or by removing a possible linear trend.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_filter</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a>,&nbsp;&nbsp; <a href="#smooth">VF_smooth</a>,&nbsp;&nbsp; <a href="#biquad">VF_biquad</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="findAxes"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_findAxes</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculate an appropriate scaling and draw a Cartesian coordinate system.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_findAxes( long double Xmin, long double Xmax, long double Ymin, long double Ymax&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_findAxes( xmin, xmax, ymin, ymax:Extended&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function will rarely be called by the user, but is used internally in <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I> and other plotting functions. According to the x- and y ranges given in the parameters Xmin, Xmax, Ymin and Ymax, a linear Cartesian coordinate system is drawn with ten subdivisions both for the abscissa and the ordinate. If necessary, the x and y ranges are enlarged so as to meet the following conditions:
<BR>1. Every subdivision line represents an exact (and not only a rounded) value.
<BR>2. If the range of one axis or both includes zero, zero falls exactly on a subdivision line.
<P>If the automatic scaling is not desired, use <I><a href="#drawAxes">V_drawAxes</a></I> instead.
<BR>Before calling <I>V_findAxes</I>, the plotting routines have to be initialized by either <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#initPlot">V_initPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="floor"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floor</b></font></td><td width="33%"><font size="+1"><b>VD_floor</b></font></td><td><font size="+1"><b>VE_floor</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoI</b></font></td><td><font size="+1"><b>VE_floortoI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoBI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoBI</b></font></td><td><font size="+1"><b>VE_floortoBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoSI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoSI</b></font></td><td><font size="+1"><b>VE_floortoSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoLI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoLI</b></font></td><td><font size="+1"><b>VE_floortoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoQI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoQI</b></font></td><td><font size="+1"><b>VE_floortoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoU</b></font></td><td width="33%"><font size="+1"><b>VD_floortoU</b></font></td><td><font size="+1"><b>VE_floortoU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoUB</b></font></td><td width="33%"><font size="+1"><b>VD_floortoUB</b></font></td><td><font size="+1"><b>VE_floortoUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoUS</b></font></td><td width="33%"><font size="+1"><b>VD_floortoUS</b></font></td><td><font size="+1"><b>VE_floortoUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoUL</b></font></td><td width="33%"><font size="+1"><b>VD_floortoUL</b></font></td><td><font size="+1"><b>VE_floortoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoUQ</b></font></td><td width="33%"><font size="+1"><b>VD_floortoUQ</b></font></td><td><font size="+1"><b>VE_floortoUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoUI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoUI</b></font></td><td><font size="+1"><b>VE_floortoUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Rounding towards minus infinity</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_floor( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VF_floortoI( iVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VF_floortoLI( liVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VF_floortoU( uVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all others)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::floor( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;int&gt;::floortoI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;long&gt;::floortoLI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;unsigned&gt;::floortoU( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_floor( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VF_floortoI( Y:iVector; X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VF_floortoLI( Y:liVector; X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all others)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_floor( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVF_floortoI( iVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_floor( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_floortoI( iVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_floor( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_floortoI( d_Y:iVector; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_floor( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_floortoI( h_Y:iVector; h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is rounded to the nearest whole number that is less than or equal to the input number and the result stored in Y. The functions <I>VF_floortoI,&nbsp;&nbsp; VF_floortoLI,&nbsp;&nbsp; VF_floortoU</I>, etc. convert the result to the various integer data types (in the cases mentioned, to the types int, long int, or unsigned, respectively).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors are handled by setting the result to the extreme value possible. Negative numbers in the versions <I>VF_floortoU,&nbsp;&nbsp; VF_floortoUS,&nbsp;&nbsp; VF_floortoUL</I>, and <I>VF_floortoUI</I> lead to DOMAIN errors; they are handled by setting the result to 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#round">VF_round</a>,&nbsp;&nbsp; <a href="#ceil">VF_ceil</a>,&nbsp;&nbsp; <a href="#chop">VF_chop</a>,&nbsp;&nbsp; <a href="#trunc">VF_trunc</a>,&nbsp;&nbsp; ceil,&nbsp;&nbsp; floor</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="flush0"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_flush0</b></font></td><td width="33%"><font size="+1"><b>VD_flush0</b></font></td><td><font size="+1"><b>VE_flush0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_flush0</b></font></td><td width="33%"><font size="+1"><b>VCD_flush0</b></font></td><td><font size="+1"><b>VCE_flush0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sets vector elements with an absolute value less than a certain threshold to 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_flush0( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;AbsMin&nbsp;);
<BR>void VCF_flush0( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;AbsMin&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::flush0( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;AbsMin&nbsp;);
<BR>void vector&lt;T&gt;::flush0( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, complex&lt;T&gt; AbsMin&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_flush0( Y,&nbsp;X:fVector; size:UIntSize; AbsMin:Single&nbsp;);
<BR>procedure VCF_flush0( Y,&nbsp;X:cfVector; size:UIntSize; AbsMin:fComplex&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_flush0( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;AbsMin&nbsp;);
<BR>int cusdVF_flush0( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_AbsMin&nbsp;);
<BR>void VFcu_flush0( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;AbsMin&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_flush0( d_Y,&nbsp;d_X:fVector; size:UIntSize; AbsMin:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_flush0( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_AbsMin:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_flush0( h_Y,&nbsp;h_X:fVector; size:UIntSize; AbsMin:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub>, if | X<sub>i</sub> | &gt;= AbsMin,
<BR>Y<sub>i</sub> = 0, otherwise
<BR>The complex versions treat the real and imaginary parts separately, using the real and imaginary parts of AbsMin to determine where to cut. If only the imaginary part is to be edited, set the real part of AbsMin to zero, e.g. (for C/C++):
<BR><font face="courier new">VCF_flush0( Y, X, size, fcplx( 0, 1.e-6&nbsp;));</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#limit">VF_limit</a>,&nbsp;&nbsp; <a href="#flushInv">VF_flushInv</a>,&nbsp;&nbsp; <a href="#maxC">VF_maxC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="flushInv"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_flushInv</b></font></td><td width="33%"><font size="+1"><b>VD_flushInv</b></font></td><td><font size="+1"><b>VE_flushInv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_flushInv</b></font></td><td width="33%"><font size="+1"><b>VCD_flushInv</b></font></td><td><font size="+1"><b>VCE_flushInv</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Take the inverse of vector elements with an absolute value larger than a certain threshold, set the result to 0 for those below the threshold</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_flushInv( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;AbsMin&nbsp;);
<BR>void VCF_flushInv( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;AbsMin&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::flushInv( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;AbsMin&nbsp;);
<BR>void vector&lt;T&gt;::flushInv( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, complex&lt;T&gt; AbsMin&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_flushInv( Y,&nbsp;X:fVector; size:UIntSize; AbsMin:Single&nbsp;);
<BR>procedure VCF_flushInv( Y,&nbsp;X:cfVector; size:UIntSize; AbsMin:fComplex&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_flushInv( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;AbsMin&nbsp;);
<BR>int cusdVF_flushInv( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_AbsMin&nbsp;);
<BR>void VFcu_flushInv( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;AbsMin&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_flushInv( d_Y,&nbsp;d_X:fVector; size:UIntSize; AbsMin:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_flushInv( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_AbsMin:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_flushInv( h_Y,&nbsp;h_X:fVector; size:UIntSize; AbsMin:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = 1.0 / X<sub>i</sub>, if | X<sub>i</sub> | &gt;= AbsMin,
<BR>Y<sub>i</sub> = 0, otherwise.
<P>Complex versions:<BR>
Y<sub>i</sub> = 1.0 / X<sub>i</sub>, if | X<sub>i</sub>.Re | &gt;= AbsMin.Re <b>and</b> | X<sub>i</sub>.Im | &gt;= AbsMin.Im,
<BR>&nbsp;&nbsp;&nbsp;1.0 / X<sub>i</sub>.Re, if | X<sub>i</sub>.Re | &gt;= AbsMin.Re <b>and</b> | X<sub>i</sub>.Im | &lt; AbsMin.Im,
<BR>&nbsp;&nbsp;&nbsp;{0.0, -1.0 / X<sub>i</sub>.Im}, if | X<sub>i</sub>.Re | &lt; AbsMin.Re <b>and</b> | X<sub>i</sub>.Im | &gt;= AbsMin.Im,
<BR>&nbsp;&nbsp;&nbsp;0, otherwise.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#flush0">VF_flush0</a>,&nbsp;&nbsp; <a href="#limit">VF_limit</a>,&nbsp;&nbsp; <a href="#maxC">VF_maxC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="fmodC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_fmodC</b></font></td><td width="33%"><font size="+1"><b>VD_fmodC</b></font></td><td><font size="+1"><b>VE_fmodC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_fmodV</b></font></td><td width="33%"><font size="+1"><b>VD_fmodV</b></font></td><td><font size="+1"><b>VE_fmodV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_fmodV</b></font></td><td width="33%"><font size="+1"><b>VDx_fmodV</b></font></td><td><font size="+1"><b>VEx_fmodV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Floating-point modulo division</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_fmodC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VF_fmodV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VFx_fmodV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::fmodC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;T&gt;::fmodV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::x_fmodV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>These functions are not defined. Use <I><a href="#modC">VF_modC</a>,&nbsp;&nbsp; <a href="#modV">VF_modV</a></I>, etc.</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_fmodC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_fmodC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>int cudaVF_fmodV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_fmodV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_fmodV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>void VFcu_fmodC( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFcu_fmodV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);
<BR>void VFxcu_fmodV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions have been included in order to provide consistency with ANSI C function names. They are implemented as macros that call <I><a href="#modC">VF_modC</a>,&nbsp;&nbsp; <a href="#modV">VF_modV</a>,&nbsp;&nbsp; <a href="#modV">VFx_modV</a></I> etc. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="fprint"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_fprint</b></font></td><td width="34%"><font size="+1"><b>VD_fprint</b></font></td><td><font size="+1"><b>VE_fprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_fprint</b></font></td><td width="34%"><font size="+1"><b>VCD_fprint</b></font></td><td><font size="+1"><b>VCE_fprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_fprint</b></font></td><td width="34%"><font size="+1"><b>VPD_fprint</b></font></td><td><font size="+1"><b>VPE_fprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_fprint</b></font></td><td width="17%"><font size="+1"><b>VBI_fprint</b></font></td><td width="17%"><font size="+1"><b>VSI_fprint</b></font></td><td width="17%"><font size="+1"><b>VLI_fprint</b></font></td><td width="17%"><font size="+1"><b>VQI_fprint</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_fprint</b></font></td><td width="17%"><font size="+1"><b>VUB_fprint</b></font></td><td width="17%"><font size="+1"><b>VUS_fprint</b></font></td><td width="17%"><font size="+1"><b>VUL_fprint</b></font></td><td width="17%"><font size="+1"><b>VUQ_fprint</b></font></td><td><font size="+1"><b>VUI_fprint</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>print a vector to a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_fprint( FILE *stream, fVector&nbsp;X, ui&nbsp;size, unsigned nperline, unsigned linewidth&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::fprint( FILE *stream, unsigned nperline, unsigned linewidth&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_fprint( var Stream:Text; X:fVector; size:UIntSize; nperline, linewidth:UInt&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_fprint( FILE&nbsp;*stream, fVector&nbsp;d_X, ui&nbsp;size, unsigned&nbsp;nperline, unsigned&nbsp;linewidth&nbsp;);
<BR>int cudaVF_fprint_buf( FILE&nbsp;*stream, fVector&nbsp;d_X, ui&nbsp;size, unsigned&nbsp;nperline, unsigned&nbsp;linewidth, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_fprint( var&nbsp;Stream:Text; d_X:fVector; size:UIntSize; nperline,&nbsp;linewidth:UInt&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_fprint_buf( var&nbsp;Stream:Text; d_X:fVector; size:UIntSize; nperline,&nbsp;linewidth:UInt; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>size elements of X are written to stream, nperline in each line of linewidth characters.
<P>Printing starts always with a new line. This may lead to an empty line at the beginning. Especially the first line of a file is reserved for a possible headline.
<P>Each line begins with the index of the first element printed into that line. The index is followed by a colon and by the requested nperline elements.
<BR>Cartesian complex numbers are printed in braces, with the real and imaginary parts separated by a komma: {Re,&nbsp;Im}. Polar complex numbers are also written in braces, with the Mag and Arg parts separated by an at-sign: {Mag @ Arg}.
<P>In contrast to <I><a href="#write">VF_write</a></I> and <I><a href="#nwrite">VF_nwrite</a></I>, it is not possible to override the automatic choice of the format used for printing. The number of digits per element is determined by the available space, which depends in turn on the parameters nperline and linewidth.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>if <i>nperline</i> exceeds the maximum number of entries possible for the <i>linewidth</i> chosen, an error message &quot;Cannot use requested format (too many entries per line)!&quot; is generated; in this case, the program chooses the maximum possible number <i>nperline</i>.
<P>CUDA versions only: <i>cudaV?_fprint_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as X. By avoiding the need of <i>cudaV?_fprint</i> to allocate its own buffer memory, <i>cudaV?_fprint_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cprint">VF_cprint</a>,&nbsp;&nbsp; <a href="#print">VF_print</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; fprintf</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="free"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_free</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>De-allocate a single vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_free( void *X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_free( Ptr:Pointer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>int cudaV_free( void *d_X&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function cudaV_free( d_X:Pointer&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is freed (i.e. de-allocated). <I>V_free</I> should be used only for the de-allocation of vectors which have previously be allocated by one of the functions of the <I><a href="#vector">VF_vector</a></I> or <I><a href="#vector0">VF_vector0</a></I> family. To free several vectors simultaneously, use <I><a href="#nfree">V_nfree</a></I> (C/C++ only).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Trying to free a vector that has already been freed, or that has never been allocated memory, leads to a warning message &quot;Cannot free non-existent vector&quot;. Program execution is continued without freeing anything in this case.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#nfree">V_nfree</a>,&nbsp;&nbsp; <a href="#freeAll">V_freeAll</a>,&nbsp;&nbsp; <a href="#pinnedFree">cudaV_pinnedFree</a>,&nbsp;&nbsp; <a href="#vector">VF_vector</a>,&nbsp;&nbsp; <a href="#vector0">VF_vector0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="freeAll"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_freeAll</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>De-allocate all vectors (and matrices)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_freeAll( void&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_freeAll;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>int cudaV_freeAll( void&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function cudaV_freeAll:&nbsp;IntBool;</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>All vectors and matrices previously allocated by one of the functions of the <I><a href="#vector">VF_vector</a>,&nbsp;&nbsp; <a href="#vector0">VF_vector0</a></I>, or <I><a href="MATRIX.HTM#matrix">MF_matrix</a></I> families are freed.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#free">V_free</a>,&nbsp;&nbsp; <a href="#pinnedFreeAll">V_pinnedFreeAll</a>,&nbsp;&nbsp; <a href="#nfree">V_nfree</a>,&nbsp;&nbsp; <a href="#vector">VF_vector</a>,&nbsp;&nbsp; <a href="#vector0">VF_vector0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="frexp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_frexp</b></font></td><td width="33%"><font size="+1"><b>VD_frexp</b></font></td><td><font size="+1"><b>VE_frexp</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Split up the elements of a vector into their mantissa and exponent parts.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_frexp( fVector&nbsp;Mant, iVector&nbsp;Exp, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::frexp( vector&lt;int&gt; Exp, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>These functions are not available for Pascal/Delphi;</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_frexp( fVector&nbsp;d_Mant, iVector&nbsp;d_Exp, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_frexp( fVector&nbsp;h_Mant, iVector&nbsp;h_Exp, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The function is implemented as a macro calling <I><a href="#mantexp">VF_mantexp</a></I>; the name <I>VF_frexp</I> is included only to maintain consistency with the ANSI C function name <i>frexp</i>. For details, see <I><a href="#mantexp">VF_mantexp</a></I> and <I>frexp</I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="fsum"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_fsum</b></font></td><td width="17%"><font size="+1"><b>VBI_fsum</b></font></td><td width="17%"><font size="+1"><b>VSI_fsum</b></font></td><td width="17%"><font size="+1"><b>VLI_fsum</b></font></td><td width="17%"><font size="+1"><b>VQI_fsum</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_fsum</b></font></td><td width="17%"><font size="+1"><b>VUB_fsum</b></font></td><td width="17%"><font size="+1"><b>VUS_fsum</b></font></td><td width="17%"><font size="+1"><b>VUL_fsum</b></font></td><td width="17%"><font size="+1"><b>VUQ_fsum</b></font></td><td><font size="+1"><b>VUI_fsum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>sum of the elements of an integer vector, returned in floating-point</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VIstd.h&gt;
<BR>double VI_fsum( iVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VU_,&nbsp;&nbsp; VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_,&nbsp;&nbsp; VUI_</I>)
<BR><font face="courier new">extended VQI_fsum( qiVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>double vector&lt;int&gt;::fsum();
<BR>extended vector&lt;quad&gt;::fsum();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VIstd;
<BR>function VI_fsum( X:iVector; size:UIntSize&nbsp;):&nbsp;Double;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VU_,&nbsp;&nbsp; VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_</I>)
<BR><font face="courier new">function VQI_fsum( X:qiVector; size:UIntSize&nbsp;):&nbsp;Extended;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVIstd.h&gt;
<BR>int cudaVI_fsum( double&nbsp;*h_RetVal, iVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVI_fsum( double&nbsp;*d_RetVal, iVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>double VIcu_fsum( iVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int cudaVQI_fsum( double&nbsp;*h_RetVal, qiVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVQI_fsum( double&nbsp;*d_RetVal, qiVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>double VQIcu_fsum( qiVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VIstd;
<BR>function cudaVI_fsum( var&nbsp;h_RetVal:Double; d_X:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVI_fsum( d_RetVal:PDouble; d_X:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VIcu_fsum( h_X:iVector; size:UIntSize&nbsp;):&nbsp;Double;
<BR>function cudaVQI_fsum( var&nbsp;h_RetVal:Double; d_X:qiVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVQI_fsum( d_RetVal:PDouble; d_X:qiVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VQIcu_fsum( h_X:qiVector; size:UIntSize&nbsp;):&nbsp;Double;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The elements of X are summed up. In order to avoid possible overflow, the sum is accumulated in a floating-point number. The 8, 16, and 32 bit variants return the result in <B>double</B> precision, whereas the 64 bit variant, <I>VQI_fsum</I>, returns an <B>extended</B>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the sum in floating-point format</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#mean">VF_mean</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="FtoD"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_FtoD</b></font></td><td width="25%"><font size="+1"><b>V_FtoE</b></font></td><td width="25%"><font size="+1"><b>V_CFtoCD</b></font></td><td><font size="+1"><b>V_CFtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_DtoF</b></font></td><td width="25%"><font size="+1"><b>V_DtoE</b></font></td><td width="25%"><font size="+1"><b>V_CDtoCF</b></font></td><td><font size="+1"><b>V_CDtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_EtoF</b></font></td><td width="25%"><font size="+1"><b>V_EtoD</b></font></td><td width="25%"><font size="+1"><b>V_CEtoCF</b></font></td><td><font size="+1"><b>V_CEtoCD</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type interconversions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VDstd.h&gt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(always include the <font face="courier new">&lt;V..std.h&gt;</font> file of the destination data-type!)
<BR><font face="courier new">void V_FtoD( dVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;double&gt;::FtoD( const&nbsp;vector&lt;float&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VDstd;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(always include the unit of the destination data-type!)
<BR><font face="courier new">procedure V_FtoD( Y:dVector; X:fVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVDstd.h&gt;
<BR>int cudaV_FtoD( dVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void Vcu_FtoD( dVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VDstd;
<BR>function cudaV_FtoD( d_Y:dVector; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure Vcu_FtoD( h_Y:dVector; h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is converted from the data type specified for X to the data type specified for Y and stored in Y.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors in the course of the &quot;down-conversions&quot; (e.g., <I>V_EtoF</I>); are silently handled: the extreme value possible for the destination data type is stored in Y with the correct sign. <I>_matherr</I> is not called.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ItoF">V_ItoF</a>,&nbsp;&nbsp; <a href="#round">V_roundtoI</a>,&nbsp;&nbsp; <a href="#round">V_roundtoLI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Gauss"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Gauss</b></font></td><td width="33%"><font size="+1"><b>VD_Gauss</b></font></td><td><font size="+1"><b>VE_Gauss</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Gaussian normal distribution function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_Gauss( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float Wid, float&nbsp;Cent, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::Gauss( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, T Wid, const&nbsp;T&amp;&nbsp;Cent, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_Gauss( Y,&nbsp;X:fVector; size:UIntSize; Wid, Cent, C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVDstd.h&gt;
<BR>int cudaVF_Gauss( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Wid, float&nbsp;Cent, float&nbsp;C&nbsp;);
<BR>int cusdVF_Gauss( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_Wid, float&nbsp;*d_Cent, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_Gauss( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Wid, float&nbsp;Cent, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VDstd;
<BR>function cudaVF_Gauss( d_Y, d_X:fVector; size:UIntSize; Wid,&nbsp;Cent,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_Gauss( d_Y, d_X:fVector; size:UIntSize; d_Wid,&nbsp;d_Cent,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_Gauss( h_Y, h_X:fVector; size:UIntSize; Wid,&nbsp;Cent,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = C / (Wid *&nbsp;sqrt(2*<font face="symbol">p</font>)) *&nbsp;exp( -0.5*((X<sub>i</sub>-Cent) / Wid)<sup>2</sup>&nbsp;)
<BR>Wid = width of the distribution
<BR>Cent = center of the distribution
<BR>C is a scaling factor; for C = 1.0, the distribution is normalized.
<BR>For Wid = 0, the normal distribution is in fact a delta distribution with Y = C *&nbsp;INF at X = Cent and Y = 0 at all other values of X.
<BR>Since infinities are not supported, the existence of a point X = Cent will lead to a SING error in case Wid is zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors may occur only for a Wid of zero. They are handled with the default result set to &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#expmx2">VF_expmx2</a>,&nbsp;&nbsp; <a href="#erf">VF_erf</a>,&nbsp;&nbsp; <a href="#sech2">VF_sech2</a>,&nbsp;&nbsp; <a href="#Lorentz">VF_Lorentz</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="getCoordSystem"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_getCoordSystem</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Store the scalings and position of the current coordinate system used for <I>VectorLib</I> plotting operations</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_getCoordSystem( VCOORDSYSTEM *csys&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_getCoordSystem( var csys: VCOORDSYSTEM&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>If one wants to &quot;hop&quot; between several coordinate systems, displayed in one and the same window, one has to store the specifications (position and scalings) of each coordinate system separately, using this function. 
<BR>The address of a struct VCOORDSYSTEM is needed as the argument. VCOORDSYSTEM is defined in <font face="courier new">&lt;Vgraph.h&gt;</font> (C/C++) or the unit Vgraph (Pascal/Delphi).</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">VCOORDSYSTEM csys1;
<BR>&nbsp;&nbsp;&nbsp;....
<BR>&nbsp;&nbsp;/*&nbsp;create the first plot: */
<BR><a href="#setPlotRegion">V_setPlotRegion</a>( 0, 0, 339, 200&nbsp;);
<BR><a href="#xyAutoPlot">VF_xyAutoPlot</a>( X1, Y1, size1, PS_SOLID, LightGreen&nbsp;);
<BR>V_getCoordSystem( &amp;csys1&nbsp;); /*&nbsp;store for later */
<BR>&nbsp;&nbsp;&nbsp;/*&nbsp;create the second plot: */
<BR>V_setPlotRegion( 340, 0, 679, 200&nbsp;);
<BR>VF_xyAutoPlot( X2, Y2, size2, PS_SOLID, LightRed&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;/*&nbsp;go back to the first plot: */
<BR><a href="#setCoordSystem">VF_setCoordSystem</a>( &amp;csys1&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;/*&nbsp;add an additional DataPlot: */
<BR><a href="#xyDataPlot">VF_xyDataPlot</a>( X1, Z1, size1, PS_SOLID, LightBlue&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Example Pascal/Delphi</td><td><font face="courier new">var cxyx1: VCOORDSYSTEM;
<BR>begin
<BR>&nbsp;&nbsp;&nbsp;....
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;create the first plot: *)
<BR>&nbsp;&nbsp;&nbsp;<a href="#setPlotRegion">V_setPlotRegion</a>( 0, 0, 339, 200&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;<a href="#xyAutoPlot">VF_xyAutoPlot</a>( X1, Y1, size1, PS_SOLID, LightGreen&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;V_getCoordSystem( csys1&nbsp;); (*&nbsp;store for later *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;create the second plot: *)
<BR>&nbsp;&nbsp;&nbsp;V_setPlotRegion( 340, 0, 679, 200&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;VF_xyAutoPlot( X2, Y2, size2, PS_SOLID, LightRed&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;go back to the first plot: *)
<BR>&nbsp;&nbsp;&nbsp;<a href="#setCoordSystem">VF_setCoordSystem</a>( csys1&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;add an additional DataPlot: *)
<BR>&nbsp;&nbsp;&nbsp;<a href="#xyDataPlot">VF_xyDataPlot</a>( X1, Z1, size1, PS_SOLID, LightBlue&nbsp;);
<BR>end;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setCoordSystem">V_setCoordSystem</a>,&nbsp;&nbsp; <a href="#setPlotRegion">V_setPlotRegion</a>,&nbsp;&nbsp; <a href="#continuePlot">V_continuePlot</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="getCudaWorkspace"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_getCudaWorkspace</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Retrieve the currently used <i>OptiVec for CUDA</i> workspace</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>V_CUDAWORKSPACE V_getCudaWorkspace( void&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Delphi</td><td><font face="courier new">uses VecLib;
<BR>function V_getCudaWorkspace: V_CUDAWORKSPACE;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The currently used <i>OptiVec for CUDA</i> workspace is retrieved.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The current workspace of type V_CUDAWORKSPACE</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap5">CudaOptiVec.htm, Chapter 5. Streams and Workspaces</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="getDefaultCudaWorkspace"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_getDefaultCudaWorkspace</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Retrieve the default <i>OptiVec for CUDA</i> workspace of the current host thread</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>V_CUDAWORKSPACE V_getDefaultCudaWorkspace( void&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Delphi</td><td><font face="courier new">uses VecLib;
<BR>function V_getDefaultCudaWorkspace: V_CUDAWORKSPACE;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The default <i>OptiVec for CUDA</i> workspace is retrieved. As described in <a href="CUDAOPTIVEC.HTM#chap5">CudaOptiVec.htm, Chapter 5</a>, the <i>OptiVec for CUDA</i> initialization creates one default workspace for each host thread. <i>V_getDefaultCudaWorkspace</i> can be called to retrieve this default workspace.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The default workspace of type V_CUDAWORKSPACE</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap5">CudaOptiVec.htm, Chapter 5. Streams and Workspaces</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="getElement"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_getElement</b></font></td><td width="34%"><font size="+1"><b>VD_getElement</b></font></td><td><font size="+1"><b>VE_getElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_getElement</b></font></td><td width="34%"><font size="+1"><b>VCD_getElement</b></font></td><td><font size="+1"><b>VCE_getElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_getElement</b></font></td><td width="34%"><font size="+1"><b>VPD_getElement</b></font></td><td><font size="+1"><b>VPE_getElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_getElement</b></font></td><td width="17%"><font size="+1"><b>VBI_getElement</b></font></td><td width="17%"><font size="+1"><b>VSI_getElement</b></font></td><td width="17%"><font size="+1"><b>VLI_getElement</b></font></td><td width="17%"><font size="+1"><b>VQI_getElement</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_getElement</b></font></td><td width="17%"><font size="+1"><b>VUB_getElement</b></font></td><td width="17%"><font size="+1"><b>VUS_getElement</b></font></td><td width="17%"><font size="+1"><b>VUL_getElement</b></font></td><td width="17%"><font size="+1"><b>VUQ_getElement</b></font></td><td><font size="+1"><b>VUI_getElement</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Copies a vector element to a specified location</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_getElement( float *y, fVector&nbsp;X, ui&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::getElement( T *y, ui&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_getElement( var&nbsp;y:Single; X:fVector; pos:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVDstd.h&gt;
<BR>void cudaVF_getElement( float&nbsp;*y, fVector&nbsp;d_X, ui&nbsp;pos&nbsp;);
<BR>void cusdVF_getElement( float&nbsp;*d_y, fVector&nbsp;d_X, ui&nbsp;pos&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VDstd;
<BR>procedure cudaVF_getElement( var&nbsp;y:Single; d_X:fVector; pos:UIntSize&nbsp;);
<BR>procedure cusdVF_getElement( d_y:PSingle; d_X:fVector; pos:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The element at the position pos is copied into the location specified by the pointer Y.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#element">VF_element</a>, &nbsp;&nbsp;<a href="#setElement">VF_setElement</a>, &nbsp;&nbsp;<a href="#Pelement">VF_Pelement</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="getFPAccuracy"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_getFPAccuracy</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Test the actual precision the coprocessor is switched to</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>unsigned  V_getFPAccuracy( void&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function V_getFPAccuracy: UInt;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function reads the FPU Control-Word. If the FPU is set to <B>float / Single</B> precision, 1 is returned. In case of <B>double</B> precision, the return value is 2, and <B>extended</B> precision yields 3. In order to change the coprocessor precision, use the (non-standardized) functions offered by the various compilers, or the <I>OptiVec</I> function <I><a href="#setFPAccuracy">V_setFPAccuracy</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>1, 2, or 3</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setFPAccuracy">V_setFPAccuracy</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="getRspEdit"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_getRspEdit</b></font></td><td width="33%"><font size="+1"><b>VD_getRspEdit</b></font></td><td><font size="+1"><b>VE_getRspEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Read the present threshold for the editing of the filter in <I><a href="#convolve">VF_convolve</a></I> and <I><a href="#deconvolve">VF_deconvolve</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>fComplex VF_getRspEdit( void&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex &lt;T&gt; vector&lt;T&gt;::getRspEdit();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_getRspEdit( var Trunc:fComplex&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>fComplex cudaVF_getRspEdit( void&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VDstd;
<BR>procedure cudaVF_getRspEdit( var Trunc:fComplex&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The threshold for the treatment of round-off errors in the functions for convolution and deconvolution is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>present threshold.
<BR>real part: acts on the real parts of the filter elements<BR>imaginary part: acts on the imaginary parts of the filter elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setRspEdit">VF_setRspEdit</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#deconvolve">VF_deconvolve</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Hann"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Hann</b></font></td><td width="33%"><font size="+1"><b>VD_Hann</b></font></td><td><font size="+1"><b>VE_Hann</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Hann&quot; window for use in spectral analysis</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_Hann( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::Hann();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_Hann( X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_Hann( fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_Hann( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_Hann( d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_Hann( h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = 0.5 *&nbsp;(1 - cos( 2 <font face="symbol">p</font> i / (size-1)&nbsp;))</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Welch">VF_Welch</a>,&nbsp;&nbsp; <a href="#Parzen">VF_Parzen</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="hypC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_hypC</b></font></td><td width="33%"><font size="+1"><b>VD_hypC</b></font></td><td><font size="+1"><b>VE_hypC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Quotient of X<sub>i</sub> over the sum of X<sub>i</sub> and a constant.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_hypC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::hypC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_hypC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVDmath.h&gt;
<BR>int cudaVF_hypC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_hypC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_hypC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VDmath;
<BR>function cudaVF_hypC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_hypC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VF_hypC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = hyp( X<sub>i</sub>, C&nbsp;) = X<sub>i</sub> / (X<sub>i</sub> + C)
<BR>The function calculating Y<sub>i</sub> according to this formula is dubbed &quot;hyp&quot; for its formal similarity to the expression constructing a hyperbola.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#hypV">VF_hypV</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="hypV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_hypV</b></font></td><td width="33%"><font size="+1"><b>VD_hypV</b></font></td><td><font size="+1"><b>VE_hypV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_hypV</b></font></td><td width="33%"><font size="+1"><b>VDx_hypV</b></font></td><td><font size="+1"><b>VEx_hypV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Quotient of X<sub>i</sub> over the sum of X<sub>i</sub> and Y<sub>i</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_hypV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VFx_hypV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::hypV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::x_hypV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_hypV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFx_hypV( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_hypV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVFx_hypV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_hypV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>void VFcu_hypV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFxcu_hypV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_hypV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_hypV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_hypV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_hypV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFxcu_hypV( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = hyp( X<sub>i</sub>, Y<sub>i</sub>&nbsp;) = X<sub>i</sub> / (X<sub>i</sub> + Y<sub>i</sub>)
<BR>expanded versions: Z<sub>i</sub> = hyp( A*X<sub>i</sub>+B), Y<sub>i</sub>&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#hypC">VF_hypC</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="hypotC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_hypotC</b></font></td><td width="33%"><font size="+1"><b>VD_hypotC</b></font></td><td><font size="+1"><b>VE_hypotC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Pythagoras &quot;hypotenuse&quot; function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_hypotC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::hypotC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_hypotC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_hypotC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_hypotC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>int VFcu_hypotC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_hypotC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_hypotC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VF_hypotC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = sqrt( X<sub>i</sub><sup>2</sup> + C<sup>2</sup>&nbsp;)
<BR>This is a variant of the famous Pythagorean theorem for the hypotenuse of a right triangle.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL. Unlike the treatment of the ANSI C function hypot by several compilers, only an overflowing final result is regarded as an error. Intermediate overflows (by the calculation of the square) are avoided by appropriate scaling.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#hypotV">VF_hypotV</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#abs">VCF_abs</a>,&nbsp;&nbsp; hypot</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="hypotV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_hypotV</b></font></td><td width="33%"><font size="+1"><b>VD_hypotV</b></font></td><td><font size="+1"><b>VE_hypotV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_hypotV</b></font></td><td width="33%"><font size="+1"><b>VDx_hypotV</b></font></td><td><font size="+1"><b>VEx_hypotV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Pythagoras &quot;hypotenuse&quot; function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_hypotV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>int VFx_hypotV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::hypotV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>int vector&lt;T&gt;::x_hypotV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_hypotV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_hypotV( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVF_hypotV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVFx_hypotV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_hypotV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>void VFcu_hypotV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFxcu_hypotV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_hypotV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_hypotV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_hypotV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_hypotV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFxcu_hypotV( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: Y<sub>i</sub> = sqrt( X<sub>i</sub><sup>2</sup> + Y<sub>i</sub><sup>2</sup>&nbsp;)
<BR>expanded version: Y<sub>i</sub> = sqrt( (A*X<sub>i</sub>+B)<sup>2</sup> + Y<sub>i</sub><sup>2</sup>&nbsp;)
<BR>These are variants of the Pythagoras formula for the hypotenuse of a right triangle.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL. (Intermediate overflows are avoided by appropriate scaling.)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#redC">VF_redC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#abs">VCF_abs</a>,&nbsp;&nbsp; hypot</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="imag"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_imag</b></font></td><td width="33%"><font size="+1"><b>VCD_imag</b></font></td><td><font size="+1"><b>VCE_imag</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_imag</b></font></td><td width="33%"><font size="+1"><b>VPD_imag</b></font></td><td><font size="+1"><b>VPE_imag</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extracts the imaginary part from a complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VCF_imag( fVector&nbsp;Im, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::imag( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_imag( Im:fVector; X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_imag( fVector&nbsp;d_Im, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VCFcu_imag( fVector&nbsp;h_Im, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_imag( d_Im:fVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VCFcu_imag( h_Im:fVector; h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Identical to the <I><a href="#CtoIm">VF_CtoIm</a></I> and <I><a href="#PtoIm">VF_PtoIm</a></I> families. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ImtoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ImtoC</b></font></td><td width="33%"><font size="+1"><b>VD_ImtoC</b></font></td><td><font size="+1"><b>VE_ImtoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Overwrites the imaginary part of a cartesian-complex vector with a real-valued vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_ImtoC( cfVector&nbsp;Y, fVector&nbsp;Im, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::ImtoC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Im&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_ImtoC( X:cfVector; Im:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVF_ImtoC( cfVector&nbsp;d_Y, fVector&nbsp;d_Im, ui&nbsp;size&nbsp;);
<BR>void VFcu_ImtoC( cfVector&nbsp;h_Y, fVector&nbsp;h_Im, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVF_ImtoC( d_X:cfVector; d_Im:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_ImtoC( h_X:cfVector; h_Im:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The imaginary part of the complex vector Y is overwritten with the elements of the real-valued vector Im. The real part of Y is not affected.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#RetoC">VF_RetoC</a>,&nbsp;&nbsp; <a href="#CtoIm">VF_CtoIm</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="indpick"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_indpick</b></font></td><td width="34%"><font size="+1"><b>VD_indpick</b></font></td><td><font size="+1"><b>VE_indpick</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_indpick</b></font></td><td width="34%"><font size="+1"><b>VCD_indpick</b></font></td><td><font size="+1"><b>VCE_indpick</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_indpick</b></font></td><td width="34%"><font size="+1"><b>VPD_indpick</b></font></td><td><font size="+1"><b>VPE_indpick</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_indpick</b></font></td><td width="17%"><font size="+1"><b>VBI_indpick</b></font></td><td width="17%"><font size="+1"><b>VSI_indpick</b></font></td><td width="17%"><font size="+1"><b>VLI_indpick</b></font></td><td width="17%"><font size="+1"><b>VQI_indpick</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_indpick</b></font></td><td width="17%"><font size="+1"><b>VUB_indpick</b></font></td><td width="17%"><font size="+1"><b>VUS_indpick</b></font></td><td width="17%"><font size="+1"><b>VUL_indpick</b></font></td><td width="17%"><font size="+1"><b>VUQ_indpick</b></font></td><td><font size="+1"><b>VUI_indpick</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Fill a vector with elements &quot;picked&quot; from another one according to their indices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_indpick( fVector&nbsp;Y, uiVector&nbsp;Ind, ui&nbsp;size, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::indpick( const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_indpick( Y:fVector; Ind:uVector; size:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_indpick( fVector&nbsp;d_Y, uiVector&nbsp;d_Ind, ui&nbsp;size, fVector&nbsp;d_X&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_indpick( d_Y:fVector; d_Ind:uVector; size:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;(no <i>VFcu_indpick</i> function available - neither for C/C++ nor for Pascal/Delphi!)
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X[ Ind<sub>i</sub> ],&nbsp;&nbsp;&nbsp;i=0,..size-1
<BR>The vector Y is filled with size elements taken from X according to their indices specified in Ind. The parameter size refers to Y and Ind. The size of X is unimportant, as long as the elements specified in Ind exist.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#indput">VF_indput</a>,&nbsp;&nbsp; <a href="#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#sortind">VF_sortind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="indput"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_indput</b></font></td><td width="34%"><font size="+1"><b>VD_indput</b></font></td><td><font size="+1"><b>VE_indput</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_indput</b></font></td><td width="34%"><font size="+1"><b>VCD_indput</b></font></td><td><font size="+1"><b>VCE_indput</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_indput</b></font></td><td width="34%"><font size="+1"><b>VPD_indput</b></font></td><td><font size="+1"><b>VPE_indput</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_indput</b></font></td><td width="17%"><font size="+1"><b>VBI_indput</b></font></td><td width="17%"><font size="+1"><b>VSI_indput</b></font></td><td width="17%"><font size="+1"><b>VLI_indput</b></font></td><td width="17%"><font size="+1"><b>VQI_indput</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_indput</b></font></td><td width="17%"><font size="+1"><b>VUB_indput</b></font></td><td width="17%"><font size="+1"><b>VUS_indput</b></font></td><td width="17%"><font size="+1"><b>VUL_indput</b></font></td><td width="17%"><font size="+1"><b>VUQ_indput</b></font></td><td><font size="+1"><b>VUI_indput</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Distribute the elements of one vector to the places within another vector specified by their indices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_indput( fVector&nbsp;Y, fVector&nbsp;X, uiVector&nbsp;Ind, ui&nbsp;sizex&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::indput( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;ui&gt;&amp;&nbsp;Ind&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_indput( Y,&nbsp;X:fVector; Ind:uVector; sizex:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_indput( fVector&nbsp;d_Y, fVector&nbsp;d_X, uiVector&nbsp;d_Ind, ui&nbsp;sizex&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_indput( d_Y,&nbsp;d_X:fVector; d_Ind:uVector; sizex:UIntSize&nbsp;):&nbsp;IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;(no <i>VFcu_indput</i> function available - neither for C/C++ nor for Pascal/Delphi!)
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y[ Ind<sub>i</sub> ] = X<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,..sizex-1
<BR>The sizex elements of X are put into the places of Y according to the indices specified in Ind. The parameter sizex refers to X and Ind. The size of Y is unimportant, as long as the elements specified in Ind exist.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#sortind">VF_sortind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="initMT"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_initMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize multi-processor optimized library</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>int  V_initMT( unsigned nProcCores&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function V_initMT( nProcCores:UInt&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function initializes the multi-processor libraries. It takes the number of processor cores as argument and creates the appropriate number of additional worker threads, so that subsequent <i>OptiVec</i> functions can distribute their work-load over the available processor cores. <i>nProcCores</i> can presently take on values of 2, 4, 8, 16, or 32. When Intel, AMD or others shall announce the development of systems with even more processor cores, future versions of <i>OptiVec</i> shall make provisions for as many cores as may become available. At the time of writing, the highest number publicly mentioned as a development project by Intel is 32.
<P><i>V_initMT</i> must be called once (and only once), before any of the <i>OptiVec</i> routines present in the multi-processor libraries can be executed. On the other hand, calling <i>V_initMT</i>, when you are using a general-purpose (non-threaded) <i>OptiVec</i> library, does not harm. <i>V_initMT</i> is present as an empty function also in these libraries. Calling it just does not have any effect. Thereby, switching back and forth between the various versions of <i>OptiVec</i> libraries for testing purposes is facilitated.
<P>In case you use <I><a href="#setFPAccuracy">V_setFPAccuracy</a></I> in order to modify the floating-point accuracy of the FPU, be sure that the call to <i>V_initMT</i> stands <u>after</u> the call to <i>V_setFPAccuracy</i>. The reason is that <i>V_initMT</i> creates the additional threads with the same FPU settings as found at the moment when the function is invoked.
<P><i>nProcCores</i> need not be your actual number of processor cores. For testing purposes, you can enter any of the legal values. Of course, optimum performance will be attained only for the correct value. For applications distributed to others, where you do not have control over the configuration of the systems they will ultimately run on, it is recommended to determine <i>nProcCores</i> either through user input or more elegantly through a system detection routine. Consult the processor documentations by Intel and AMD for details.
<BR>Although it is not absolutely necessary, it is recommended that you delete the extra threads by calling <I><a href="#closeMT">V_closeMT</a></I> at the end of your programme.
<BR><i>V_initMT</i> stores the number of processor cores in the public variable <i>V_nProcCores</i> which is defined as (<b>extern "C"</b>) <b>unsigned</b> in C/C++, and as <b>UInt</b> in Delphi. Reading this variable, one can determine if <i>V_initMT</i> has already been called.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if the threads could be initialized error-free, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#closeMT">V_closeMT</a></I>, <a href="HANDBOOK.HTM#chap1_1_2">chap.&nbsp;1.1.2.</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="initPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_initPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize the global variables used by the plotting functions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>#ifdef _Windows
<BR>&nbsp;&nbsp;&nbsp;&nbsp;void V_initPlot( HWND vwindow, HDC vdc&nbsp;);
<BR>#else
<BR>&nbsp;&nbsp;&nbsp;&nbsp;void V_initPlot( int&nbsp;graphmode&nbsp;);
<BR>#endif</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><u>for Delphi:</u>
<BR><font face="courier new">uses Vgraph;
<BR>procedure V_initPlot( VPaintBox: TPaintBox&nbsp;);</font>
<BR><u>for Borland Pascal:</u>
<BR><font face="courier new">uses Vgraph;
<BR>{$ifdef Windows}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;procedure V_initPlot( vwindow:HWND; vdc:HDC&nbsp;);
<BR>{$else}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;procedure V_initPlot( graphmode:Integer&nbsp;);
<BR>{$endif}</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><i>vwindow</i> is the handle for a window and <i>vdc</i> the handle of a device context. As long as these handles remain valid, future plotting operations (like <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>) will be directed to the window specified by <i>vwindow</i> and use the fonts defined in the device context <i>vdc</i>. Be sure that <i>vwindow</i> and <i>vdc</i> are still valid when a plotting operation is performed; if in doubt, call <I>V_initPlot</I> again.
<BR><u>C++ Builder with OWL:</u> The natural place to call <I>V_initPlot</I> is in the virtual element function <I>Paint</I>. Then, the handle of the actual window is made available as &quot;HWindow&quot; by OWL, and the device context is the same as passed as a parameter to <I>Paint</I>.
<P><u>Delphi programs:</u>
<BR><i>VPaintBox</i> is the paint box into which you wish to get a <I>VectorLib</I> plot. All future <I>VectorLib</I> plotting operations are directed into this paint box, unless you call <I>V_initPlot</I> again, with a new paint box as parameter.
<P><I>V_initPlot</I> reserves the rightmost about 2/3 of the screen for following plotting operations, leaving one line empty at the top of the screen and a few lines at the bottom. To override this, call <I><a href="#setPlotRegion">V_setPlotRegion</a></I> after <I>V_initPlot</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#setPlotRegion">V_setPlotRegion</a>,&nbsp;&nbsp; <a href="#initPrint">V_initPrint</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="initPrint"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_initPrint</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize <I>VectorLib</I> plotting functions for use with a printer</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_initPrint( HDC printdc&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_initPrint( printdc: HDC&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function tells the <I>VectorLib</I> plotting functions to send their output to the printer context specified as <i>printdc</i>. By default, one whole page is reserved for the printout. To change this, call <I><a href="#setPlotRegion">V_setPlotRegion</a></I> after <I>V_initPrint</I>.
<BR>To switch back to screen output, call <I><a href="#initPlot">V_initPlot</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#initPlot">V_initPlot</a>,&nbsp;&nbsp; <a href="#setPlotRegion">V_setPlotRegion</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="insert"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_insert</b></font></td><td width="34%"><font size="+1"><b>VD_insert</b></font></td><td><font size="+1"><b>VE_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_insert</b></font></td><td width="34%"><font size="+1"><b>VCD_insert</b></font></td><td><font size="+1"><b>VCE_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_insert</b></font></td><td width="34%"><font size="+1"><b>VPD_insert</b></font></td><td><font size="+1"><b>VPE_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_insert</b></font></td><td width="17%"><font size="+1"><b>VBI_insert</b></font></td><td width="17%"><font size="+1"><b>VSI_insert</b></font></td><td width="17%"><font size="+1"><b>VLI_insert</b></font></td><td width="17%"><font size="+1"><b>VQI_insert</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_insert</b></font></td><td width="17%"><font size="+1"><b>VUB_insert</b></font></td><td width="17%"><font size="+1"><b>VUS_insert</b></font></td><td width="17%"><font size="+1"><b>VUL_insert</b></font></td><td width="17%"><font size="+1"><b>VUQ_insert</b></font></td><td><font size="+1"><b>VUI_insert</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Insert an element into a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_insert( fVector&nbsp;X, ui&nbsp;size, ui&nbsp;pos, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::insert( ui&nbsp;pos, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_insert( X:fVector; size, pos:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_insert( fVector&nbsp;d_X, ui&nbsp;size, ui&nbsp;pos, float&nbsp;C&nbsp;);
<BR>int cusdVF_insert( fVector&nbsp;d_X, ui&nbsp;size, ui&nbsp;pos, float&nbsp;*d_C&nbsp;);
<BR>void VFcu_insert( fVector&nbsp;h_X, ui&nbsp;size, ui&nbsp;pos, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_insert( d_X:fVector; size,&nbsp;pos:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_insert( d_X:fVector; size,&nbsp;pos:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_insert( h_X:fVector; size,&nbsp;pos:UIntSize; C:Single&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;(no <i>VFcu_indput</i> function available - neither for C/C++ nor for Pascal/Delphi!)
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This is one of the few functions where the input vector is changed itself (instead of being mapped onto an output vector). A new element is inserted at the position <i>pos</i> and has the value C. Elements before <i>pos</i> are unchanged, elements from <i>pos</i> on are shifted one position higher; the last element is lost. (If you wish to save the last element, choose <i>size</i> big enough to have a dummy element at the end of the vector; now it will be the dummy that gets lost.)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#delete">VF_delete</a>,&nbsp;&nbsp; <a href="#rotate">VF_rotate</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="integralC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_integralC</b></font></td><td width="33%"><font size="+1"><b>VD_integralC</b></font></td><td><font size="+1"><b>VE_integralC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Integral of an array plotted over an equally-spaced abscissa.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_integralC( fVector&nbsp;X, ui&nbsp;size, float DeltaT&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::integralC( T DeltaT&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_integralC( X:fVector; size:UIntSize; DeltaT:Single&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_integralC( float *h_RetVal, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_integralC( float *d_RetVal, fVector&nbsp;X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>float VFcu_integralC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_integralC( var h_RetVal:Single; d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_integralC( d_RetVal:PSingle; d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_integralC( h_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is assumed to be a function of a variable t; the t values themselves are equally spaced, so that only the spacing DeltaT is needed. The area under X, i.e. the integral of X over t from t<sub>0</sub> to t<sub>size-1</sub> is calculated. If not only the value of the integral is of interest, but a point-by-point integration has to be performed, <I><a href="#runintegralC">VF_runintegralC</a></I> should be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The value of the integral is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#integralV">VF_integralV</a>,&nbsp;&nbsp; <a href="#runintegralC">VF_runintegralC</a>,&nbsp;&nbsp; <a href="#derivC">VF_derivC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="integralV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_integralV</b></font></td><td width="33%"><font size="+1"><b>VD_integralV</b></font></td><td><font size="+1"><b>VE_integralV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Integral</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_integralV( fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::integralV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_integralV( X,&nbsp;Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_integralV( float *h_RetVal, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>int cusdVF_integralV( float *d_RetVal, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>float VFcu_integralV( fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_integralV( var h_RetVal:Single; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_integralV( d_RetVal:PSingle; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_integralV( h_X, h_Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector Y is assumed to be a function of X; the integral of Y over X is calculated. If the elements of X are regularly spaced with a constant difference between them, the integral is obtained more efficiently by <I><a href="#integralC">VF_integralC</a></I>. If not only the value of the integral is of interest, but a point-by-point integration has to be performed, <I><a href="#runintegralV">VF_runintegralV</a></I> may be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The value of the integral is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#integralC">VF_integralC</a>,&nbsp;&nbsp; <a href="#runintegralV">VF_runintegralV</a>,&nbsp;&nbsp; <a href="#derivV">VF_derivV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="intfrac"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_intfrac</b></font></td><td width="33%"><font size="+1"><b>VD_intfrac</b></font></td><td><font size="+1"><b>VE_intfrac</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Split up the elements of a vector into their integer and fractional parts.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_intfrac( fVector&nbsp;IntPart, fVector&nbsp;FracPart, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::intfrac( vector&lt;T&gt; FracPart, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_intfrac( IntPart,&nbsp;FracPart, X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_intfrac( fVector&nbsp;d_IntPart, fVector&nbsp;d_FracPart, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_intfrac( fVector&nbsp;h_IntPart, fVector&nbsp;h_FracPart, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_intfrac( d_IntPart,&nbsp;d_FracPart, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_intfrac( h_IntPart,&nbsp;h_FracPart, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The integer parts of the elements of X are stored in IntPart, the fractional parts in FracPart. Notice that IntPart is a floating-point vector, even though it contains integer numbers (which might be larger than could be stored in the integer data types).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mantexp">VF_mantexp</a></I>,&nbsp;&nbsp;modf (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="inv"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_inv</b></font></td><td width="33%"><font size="+1"><b>VD_inv</b></font></td><td><font size="+1"><b>VE_inv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_inv</b></font></td><td width="33%"><font size="+1"><b>VDx_inv</b></font></td><td><font size="+1"><b>VEx_inv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_inv</b></font></td><td width="33%"><font size="+1"><b>VCD_inv</b></font></td><td><font size="+1"><b>VCE_inv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_inv</b></font></td><td width="33%"><font size="+1"><b>VCDx_inv</b></font></td><td><font size="+1"><b>VCEx_inv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_inv</b></font></td><td width="33%"><font size="+1"><b>VPD_inv</b></font></td><td><font size="+1"><b>VPE_inv</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Inverse</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_inv( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_inv( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::inv( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_inv( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_inv( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_inv( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_inv( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_inv( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_inv( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int VFcu_inv( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_inv( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_inv( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_inv( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_inv( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_inv( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_inv( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 1.0 / X<sub>i</sub>
<BR>expanded versions: Y<sub>i</sub> = 1.0 / (A*X<sub>i</sub>+B)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING and OVERFLOW errors lead to a result of  &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divrC">VF_divrC</a>,&nbsp;&nbsp; <a href="#divrV">VF_divrV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ipow"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ipow</b></font></td><td width="33%"><font size="+1"><b>VD_ipow</b></font></td><td><font size="+1"><b>VE_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_ipow</b></font></td><td width="33%"><font size="+1"><b>VDx_ipow</b></font></td><td><font size="+1"><b>VEx_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFu_ipow</b></font></td><td width="33%"><font size="+1"><b>VDu_ipow</b></font></td><td><font size="+1"><b>VEu_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFux_ipow</b></font></td><td width="33%"><font size="+1"><b>VDux_ipow</b></font></td><td><font size="+1"><b>VEux_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_ipow</b></font></td><td width="33%"><font size="+1"><b>VCD_ipow</b></font></td><td><font size="+1"><b>VCE_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_ipow</b></font></td><td width="33%"><font size="+1"><b>VCDx_ipow</b></font></td><td><font size="+1"><b>VCEx_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFu_ipow</b></font></td><td width="33%"><font size="+1"><b>VCDu_ipow</b></font></td><td><font size="+1"><b>VCEu_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFux_ipow</b></font></td><td width="33%"><font size="+1"><b>VCDux_ipow</b></font></td><td><font size="+1"><b>VCEux_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_ipow</b></font></td><td width="33%"><font size="+1"><b>VPD_ipow</b></font></td><td><font size="+1"><b>VPE_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPFu_ipow</b></font></td><td width="33%"><font size="+1"><b>VPDu_ipow</b></font></td><td><font size="+1"><b>VPEu_ipow</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Raise each element of a vector to a specified integer power.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ipow( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;Expo&nbsp;);
<BR>int VFx_ipow( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VFu_ipow( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;Expo&nbsp;);
<BR>int VFux_ipow( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ipow( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_ipow( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>int vector&lt;T&gt;::u_ipow( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::ux_ipow( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_ipow( Y,&nbsp;X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFx_ipow( Y,&nbsp;X:fVector; size:UIntSize; Expo:Integer; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VFu_ipow( Y,&nbsp;X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFux_ipow( Y,&nbsp;X:fVector; size:UIntSize; Expo:Integer; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_ipow( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;Expo&nbsp;);
<BR>int cudaVFx_ipow( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_ipow( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;Expo, float&nbsp;*_dA, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int cudaVFu_ipow( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;Expo&nbsp;);
<BR>int cudaVFux_ipow( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFux_ipow( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;Expo, float&nbsp;*_dA, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_ipow( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, int&nbsp;Expo&nbsp;);
<BR>int VFxcu_ipow( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, int&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VFucu_ipow( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, int&nbsp;Expo&nbsp;);
<BR>int VFuxcu_ipow( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, int&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_ipow( d_Y, d_X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_ipow( d_Y, d_X:fVector; size:UIntSize; Expo:Integer; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_ipow( d_Y, d_X:fVector; size:UIntSize; Expo:Integer; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVFu_ipow( d_Y, d_X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVFux_ipow( d_Y, d_X:fVector; size:UIntSize; Expo:Integer; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFux_ipow( d_Y, d_X:fVector; size:UIntSize; Expo:Integer; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_ipow( h_Y, h_X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_ipow( h_Y, h_X:fVector; size:UIntSize; Expo:Integer; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VFucu_ipow( h_Y, h_X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFuxcu_ipow( h_Y, h_X:fVector; size:UIntSize; Expo:Integer; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = X<sub>i</sub><sup>Expo</sup>
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;(A*X<sub>i</sub>+B)<sup>Expo</sup>
<BR>If Expo is larger than a data-type dependent threshold (which will be a very rare occasion), <I>VF_ipow</I> does not calculate the result itself, but calls <I><a href="#pow">VF_pow</a></I>, which is safer and faster in this case.
<BR>The &quot;unprotected&quot; versions (prefix <I>VFu_</I> and <I>VFux_</I>) do not perform any error handling and do not redirect calls to <I><a href="#pow">VF_pow</a></I>. These simplifications make them very fast, but also risky; they should be used very carefully.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors occur, if zero is raised to a negative power; the default result is &#177;HUGE_VAL, as in the case of OVERFLOW errors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a>,&nbsp;&nbsp; <a href="#pow2">VF_pow2</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a></I>,&nbsp;&nbsp;pow</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ipow10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ipow10</b></font></td><td width="33%"><font size="+1"><b>VD_ipow10</b></font></td><td><font size="+1"><b>VE_ipow10</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Integer powers of 10</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ipow10( fVector&nbsp;Y, iVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ipow10( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_ipow10( Y:fVector; X:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_ipow10( fVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_ipow10( fVector&nbsp;h_Y, iVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_ipow10( d_Y:fVector; d_X:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_ipow10( h_Y:fVector; h_X:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = 10<sup>X</sup><font size="-1">i</font>
<BR>Notice: this function (and not <I><a href="#pow10">VF_pow10</a></I> !) is the vectorized form of the function pow10 defined in Borland C/C++.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#pow10">VF_pow10</a>,&nbsp;&nbsp; <a href="#scale10">VF_scale10</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a>,&nbsp;&nbsp; <a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; pow</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ipow2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ipow2</b></font></td><td width="33%"><font size="+1"><b>VD_ipow2</b></font></td><td><font size="+1"><b>VE_ipow2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Integer powers of 2</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ipow2( fVector&nbsp;Y, iVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ipow2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;</font>
<font face="courier new">function VF_ipow2( Y:fVector; X:iVector; size:UIntSize&nbsp;):</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_ipow2( fVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_ipow2( fVector&nbsp;h_Y, iVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_ipow2( d_Y:fVector; d_X:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_ipow2( h_Y:fVector; h_X:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = 2<sup>X</sup><font size="-1">i</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#pow2">VF_pow2</a>,&nbsp;&nbsp; <a href="#scale2">VF_scale2</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; pow</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="iselementC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_iselementC</b></font></td><td width="34%"><font size="+1"><b>VD_iselementC</b></font></td><td><font size="+1"><b>VE_iselementC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_iselementC</b></font></td><td width="34%"><font size="+1"><b>VCD_iselementC</b></font></td><td><font size="+1"><b>VCE_iselementC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_iselementC</b></font></td><td width="34%"><font size="+1"><b>VPD_iselementC</b></font></td><td><font size="+1"><b>VPE_iselementC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_iselementC</b></font></td><td width="17%"><font size="+1"><b>VBI_iselementC</b></font></td><td width="17%"><font size="+1"><b>VSI_iselementC</b></font></td><td width="17%"><font size="+1"><b>VLI_iselementC</b></font></td><td width="17%"><font size="+1"><b>VQI_iselementC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_iselementC</b></font></td><td width="17%"><font size="+1"><b>VUB_iselementC</b></font></td><td width="17%"><font size="+1"><b>VUS_iselementC</b></font></td><td width="17%"><font size="+1"><b>VUL_iselementC</b></font></td><td width="17%"><font size="+1"><b>VUQ_iselementC</b></font></td><td><font size="+1"><b>VUI_iselementC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Test if one or more elements of a table are equal to C.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>int VF_iselementC( fVector&nbsp;Tab, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::iselementC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_iselementC( Tab:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_iselementC( fVector&nbsp;d_Tab, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_iselementC( fVector&nbsp;d_Tab, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_iselementC( fVector&nbsp;h_Tab, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_iselementC( d_Tab:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_iselementC( d_Tab:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_iselementC( h_Tab:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector Tab is searched for the value C. If one or more elements are equal to C, TRUE (+1) is returned, otherwise FALSE (0). No ordering of Tab is assumed and a linear search performed. A related function that finds the table element closest (but not necessarily equal) to C is <I><a href="#searchC">VF_searchC</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>TRUE (+1), if C is an element of X, otherwise FALSE (0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#searchC">VF_searchC</a>,&nbsp;&nbsp; <a href="#iselementV">VF_iselementV</a>,&nbsp;&nbsp; lfind,&nbsp;&nbsp; lsearch</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="iselementV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_iselementV</b></font></td><td width="34%"><font size="+1"><b>VD_iselementV</b></font></td><td><font size="+1"><b>VE_iselementV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_iselementV</b></font></td><td width="34%"><font size="+1"><b>VCD_iselementV</b></font></td><td><font size="+1"><b>VCE_iselementV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_iselementV</b></font></td><td width="34%"><font size="+1"><b>VPD_iselementV</b></font></td><td><font size="+1"><b>VPE_iselementV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_iselementV</b></font></td><td width="17%"><font size="+1"><b>VBI_iselementV</b></font></td><td width="17%"><font size="+1"><b>VSI_iselementV</b></font></td><td width="17%"><font size="+1"><b>VLI_iselementV</b></font></td><td width="17%"><font size="+1"><b>VQI_iselementV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_iselementV</b></font></td><td width="17%"><font size="+1"><b>VUB_iselementV</b></font></td><td width="17%"><font size="+1"><b>VUS_iselementV</b></font></td><td width="17%"><font size="+1"><b>VUL_iselementV</b></font></td><td width="17%"><font size="+1"><b>VUQ_iselementV</b></font></td><td><font size="+1"><b>VUI_iselementV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Test for each element of a vector, if an identical element is present in a table.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>ui VF_iselementV( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;sizex, fVector&nbsp;Tab, ui&nbsp;sizetab&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;T&gt;::iselementV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Tab&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_iselementV( Y,&nbsp;X:fVector; sizex:UIntSize; Tab:fVector; sizetab:UIntSize&nbsp;):&nbsp;UIntSize;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_iselementV( ui&nbsp;*h_nFound, fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;sizex, fVector&nbsp;d_Tab, ui&nbsp;sizetab&nbsp;);
<BR>ui VFcu_iselementV( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;sizex, fVector&nbsp;h_Tab, ui&nbsp;sizetab&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_iselementV( var&nbsp;h_nFound:UIntSize; d_Y,&nbsp;d_X:fVector; sizex:UIntSize; d_Tab:fVector; sizetab:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_iselementV( h_Y,&nbsp;h_X:fVector; sizex:UIntSize; h_Tab:fVector; sizetab:UIntSize&nbsp;):&nbsp;UIntSize;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The table Tab is searched for each of the elements of X. For those elements of X which are found in Tab, the corresponding element of Y is set to +1 (in the complex versions: {1, 0}&nbsp;). No ordering of X and Tab is assumed and a linear search for each X<sub>i</sub> performed. A related function that finds the table element closest (but not necessarily equal) to each element of X is <I><a href="#searchV">VF_searchV</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The number of elements of X for which an element of Tab was found is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#searchV">VF_searchV</a>,&nbsp;&nbsp; <a href="#iselementC">VF_iselementC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ismonoton"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ismonoton</b></font></td><td width="33%"><font size="+1"><b>VD_ismonoton</b></font></td><td><font size="+1"><b>VE_ismonoton</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Test if the elements of a vector are monotonously increasing or decreasing</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>int VF_ismonoton( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ismonoton( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_ismonoton( X:fVector; size:UIntSize&nbsp;):&nbsp;Integer;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_ismonoton( int&nbsp;*h_isSorted, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_ismonoton( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_ismonoton( var h_isSorted:Integer; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_ismonoton( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Integer;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is analyzed. If the elements are in strict descending order, -1 is returned; if they are either constant or in strict ascending order, +1 is returned. Otherwise the return value is 0. If X contains passages that are increasing as well as passages that remain at a constant value, X is regarded as monotonous only if the increasing passage follows the constant passage, but not the other way round. Thus, the series 0, 0, 0, 1, 2, 3 will be accepted as monotonous (return value +1), whereas the series 1, 2, 3, 4, 4, 4 will not (return value 0). Also the initially constant, then falling series 0, 0, 0, -1, -2, -3 will not be regarded as monotonous.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>+1 in case of monotonous rise, or if all elements are identical, -1 in case of monotonously falling values, 0 if neither of these conditions is fulfilled.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sort">VF_sort</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ItoF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_ItoF</b></font></td><td width="33%"><font size="+1"><b>V_ItoD</b></font></td><td><font size="+1"><b>V_ItoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_BItoF</b></font></td><td width="33%"><font size="+1"><b>V_BItoD</b></font></td><td><font size="+1"><b>V_BItoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_SItoF</b></font></td><td width="33%"><font size="+1"><b>V_SItoD</b></font></td><td><font size="+1"><b>V_SItoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_LItoF</b></font></td><td width="33%"><font size="+1"><b>V_LItoD</b></font></td><td><font size="+1"><b>V_LItoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_QItoF</b></font></td><td width="33%"><font size="+1"><b>V_QItoD</b></font></td><td><font size="+1"><b>V_QItoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UtoF</b></font></td><td width="33%"><font size="+1"><b>V_UtoD</b></font></td><td><font size="+1"><b>V_UtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UBtoF</b></font></td><td width="33%"><font size="+1"><b>V_UBtoD</b></font></td><td><font size="+1"><b>V_UBtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UStoF</b></font></td><td width="33%"><font size="+1"><b>V_UStoD</b></font></td><td><font size="+1"><b>V_UStoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_ULtoF</b></font></td><td width="33%"><font size="+1"><b>V_ULtoD</b></font></td><td><font size="+1"><b>V_ULtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UQtoF</b></font></td><td width="33%"><font size="+1"><b>V_UQtoD</b></font></td><td><font size="+1"><b>V_UQtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UItoF</b></font></td><td width="33%"><font size="+1"><b>V_UItoD</b></font></td><td><font size="+1"><b>V_UItoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Convert integer numbers into floating-point data types.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(always the include-file belonging to the destination type!)
<BR><font face="courier new">void V_ItoF( fVector&nbsp;Y, iVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(all other functions of this family are similar)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;float&gt;::ItoF( const&nbsp;vector&lt;int&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(always the unit belonging to the destination type!)
<BR><font face="courier new">procedure V_ItoF( Y:fVector; X:iVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(all other functions of this family are similar)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaV_ItoF( fVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void Vcu_ItoF( fVector&nbsp;h_Y, iVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaV_ItoF( d_Y:fVector; d_X:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure Vcu_ItoF( h_Y:fVector; h_X:iVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is converted from the data type int, byte, short int, long int, quad, unsigned, unsigned byte, unsigned short, unsigned long, or ui, resp., into the data type float, double, or extended, resp., and stored in Y. For the inverse procedure, i.e. the conversion of floating-point numbers to integers, the functions of the <I><a href="#round">VF_roundtoI</a>,&nbsp;&nbsp; <a href="#floor">VF_floortoI</a>,&nbsp;&nbsp; <a href="#ceil">VF_ceiltoI</a></I>, and <I><a href="#chop">VF_choptoI</a></I> families have to be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#round">VF_roundtoI</a>,&nbsp;&nbsp; <a href="#floor">VF_floortoI</a>,&nbsp;&nbsp; <a href="#ceil">VF_ceiltoI</a>,&nbsp;&nbsp; <a href="#chop">VF_choptoI</a>,&nbsp;&nbsp; <a href="#trunc">VF_trunctoI</a>,&nbsp;&nbsp; <a href="#ItoBI">V_ItoLI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ItoBI"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_ItoBI</b></font></td><td width="25%"><font size="+1"><b>V_ItoSI</b></font></td><td width="25%"><font size="+1"><b>V_ItoLI</b></font></td><td><font size="+1"><b>V_ItoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_BItoI</b></font></td><td width="25%"><font size="+1"><b>V_BItoSI</b></font></td><td width="25%"><font size="+1"><b>V_BItoLI</b></font></td><td><font size="+1"><b>V_BItoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_SItoI</b></font></td><td width="25%"><font size="+1"><b>V_SItoBI</b></font></td><td width="25%"><font size="+1"><b>V_SItoLI</b></font></td><td><font size="+1"><b>V_SItoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_LItoI</b></font></td><td width="25%"><font size="+1"><b>V_LItoBI</b></font></td><td width="25%"><font size="+1"><b>V_LItoSI</b></font></td><td><font size="+1"><b>V_LItoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_QItoI</b></font></td><td width="25%"><font size="+1"><b>V_QItoBI</b></font></td><td width="25%"><font size="+1"><b>V_QItoSI</b></font></td><td><font size="+1"><b>V_QItoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_UtoUB</b></font></td><td width="25%"><font size="+1"><b>V_UtoUS</b></font></td><td width="25%"><font size="+1"><b>V_UtoUL</b></font></td><td><font size="+1"><b>V_UtoUI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_UBtoU</b></font></td><td width="25%"><font size="+1"><b>V_UBtoUS</b></font></td><td width="25%"><font size="+1"><b>V_UBtoUL</b></font></td><td><font size="+1"><b>V_UBtoUI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_UStoU</b></font></td><td width="25%"><font size="+1"><b>V_UStoUB</b></font></td><td width="25%"><font size="+1"><b>V_UStoUL</b></font></td><td><font size="+1"><b>V_UStoUI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_ULtoU</b></font></td><td width="25%"><font size="+1"><b>V_ULtoUB</b></font></td><td width="25%"><font size="+1"><b>V_ULtoUS</b></font></td><td><font size="+1"><b>V_ULtoUI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_UItoU</b></font></td><td width="25%"><font size="+1"><b>V_UItoUB</b></font></td><td width="25%"><font size="+1"><b>V_UItoUS</b></font></td><td><font size="+1"><b>V_UItoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_ItoU</b></font></td><td width="25%"><font size="+1"><b>V_BItoUB</b></font></td><td width="25%"><font size="+1"><b>V_SItoUS</b></font></td><td><font size="+1"><b>V_LItoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_UtoI</b></font></td><td width="25%"><font size="+1"><b>V_UBtoBI</b></font></td><td width="25%"><font size="+1"><b>V_UStoSI</b></font></td><td><font size="+1"><b>V_ULtoLI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Interconversion of the integer data types</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VLIstd.h&gt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(or <font face=" courier new">&lt;VIstd.h&gt;, &lt;VUstd.h&gt;</font>,..., resp., depending on the destination data type!)
<BR><font face="courier new">void V_ItoLI( liVector&nbsp;Y, iVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(all other functions of this family are similar)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;long&gt;::ItoLI( const&nbsp;vector&lt;long&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VLIstd;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(always the unit belonging to the destination type!)
<BR><font face="courier new">procedure V_ItoLI( Y:liVector; X:iVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(all other functions of this family are similar)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVLIstd.h&gt;
<BR>int cudaV_ItoLI( liVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void Vcu_ItoLI( liVector&nbsp;h_Y, iVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VLIstd;
<BR>function cudaV_ItoLI( d_Y:liVector; d_X:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure Vcu_ItoLI( h_Y:liVector; h_X:iVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of the vector X is converted into the desired data type and stored in Y.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ItoF">V_ItoF</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Kepler"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Kepler</b></font></td><td width="33%"><font size="+1"><b>VD_Kepler</b></font></td><td><font size="+1"><b>VE_Kepler</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_Kepler</b></font></td><td width="33%"><font size="+1"><b>VDx_Kepler</b></font></td><td><font size="+1"><b>VEx_Kepler</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Angular position of a planet according to Kepler's Second Law</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_Kepler( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;T, float&nbsp;e&nbsp;);
<BR>int VFx_Kepler( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;T, float&nbsp;e, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::Kepler( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, T t, T e&nbsp;);
<BR>int vector&lt;T&gt;::x_Kepler( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, T t, T e, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>function VF_Kepler( Y,&nbsp;X:fVector; size:UIntSize; T,&nbsp;e:Single&nbsp;):&nbsp;IntBool;
<BR>function VFx_Kepler( Y,&nbsp;X:fVector; size:UIntSize; T,&nbsp;e,&nbsp;A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_Kepler( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;T, float&nbsp;e&nbsp;);
<BR>int cusdVF_Kepler( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_T, float&nbsp;*d_e&nbsp;);
<BR>int cudaVFx_Kepler( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;T, float&nbsp;e, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_Kepler( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_T, float&nbsp;*d_e, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int VFcu_Kepler( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;T, float&nbsp;e&nbsp;);
<BR>int VFxcu_Kepler( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;T, float&nbsp;e, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_Kepler( d_Y, d_X:fVector; size:UIntSize; T,&nbsp;e:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_Kepler( d_Y, d_X:fVector; size:UIntSize; d_T,&nbsp;d_e:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_Kepler( d_Y, d_X:fVector; size:UIntSize; T,&nbsp;e,&nbsp;A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_Kepler( d_Y, d_X:fVector; size:UIntSize; d_T,&nbsp;d_e,&nbsp;d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_Kepler( h_Y, h_X:fVector; size:UIntSize; T,&nbsp;e:Single&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_Kepler( h_Y, h_X:fVector; size:UIntSize; T,&nbsp;e,&nbsp;A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = Kepler( X<sub>i</sub>/T, e&nbsp;);
<BR>expanded versions: Y<sub>i</sub> = Kepler( (A*X<sub>i</sub>+B)/T, e&nbsp;);
<BR>The time-dependent angular position of a planet is calculated from its round-trip time T and its eccentricity e.
<BR>T must be non-zero; e may take on values 0 &lt;= e &lt;= 1. While there is no analytic solution to this problem, described by Johannes Kepler's Second Law, an efficient iterative algorithm is known and is used here. This algorithm is fast and stable up to the hyperbolic limit, e = 1.0.
<BR>Rather than treating the problem in terms of the reduced time m = t/T (like it is done in Astronomy textbooks), <I>VF_Kepler</I> expects the real times in X and divides them internally by T.
<P>As there may hardly be any occasions when one might wish to scale the obtained angular position by a constant, no multiplication by C is included in the <I>VFx_</I> version which, consequently, has only A and B as additional arguments (unlike most of the other &quot;expanded versions&quot; of <I>VectorLib</I> math functions).
<P><font color="#ff0000">This function may not be called while the FPU is set to reduced accuracy, or else it might hang in an infinite loop. See <I><a href="#setFPAccuracy">V_setFPAccuracy</a></I>. As seome versions of Windows (from XP x64 on) automatically reduce the FPU to <b>double</b> precision, a call to the VE_ version should be preceded by a call to <font face="courier new">V_setFPAccuracy(&nbsp;3&nbsp;);</font></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>e negative or e greater than 1.0 leads to an &quot;Invalid parameter(s)&quot; error. T = 0 leads to all Y<sub>i</sub> = 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Langevin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Langevin</b></font></td><td width="33%"><font size="+1"><b>VD_Langevin</b></font></td><td><font size="+1"><b>VE_Langevin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_Langevin</b></font></td><td width="33%"><font size="+1"><b>VDx_Langevin</b></font></td><td><font size="+1"><b>VEx_Langevin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Langevin function of dielectric relaxation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_Langevin( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_Langevin( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, 
 float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::Langevin( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_Langevin( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>function VF_Langevin( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_Langevin( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_Langevin( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_Langevin( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_Langevin( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_Langevin( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_Langevin( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_Langevin( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_Langevin( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_Langevin( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_Langevin( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_Langevin( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cot( X<sub>i</sub>&nbsp;) - 1/X<sub>i</sub>;
<BR>expanded versions: x = A *&nbsp;X<sub>i</sub> + B;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y<sub>i</sub> = C *&nbsp;(cot(x) - 1/x);
<BR>The Langevin function has an S-shaped graph and describes, e.g., dielectric relaxation phenomena.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>This function should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0).</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ldexp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ldexp</b></font></td><td width="33%"><font size="+1"><b>VD_ldexp</b></font></td><td><font size="+1"><b>VE_ldexp</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Scale by an integer power of 2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ldexp( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;expo&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ldexp( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>These functions are absent. Use VF_scale2 etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions are implemented as alias names for <I><a href="#scale2">VF_scale2</a></I> etc., in order to maintain consistency with the ANSI C function name <I>ldexp</I>. For details, see <I><a href="#scale2">VF_scale2</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="limit"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_limit</b></font></td><td width="33%"><font size="+1"><b>VD_limit</b></font></td><td><font size="+1"><b>VE_limit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_limit</b></font></td><td width="33%"><font size="+1"><b>VCD_limit</b></font></td><td><font size="+1"><b>VCE_limit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Limit the values of the elements of a vector to a specified range.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_limit( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;Min, float&nbsp;Max&nbsp;);
<BR>void VCF_limit( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;Min, fComplex&nbsp;Max&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::limit( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, T Min, T Max&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::limit( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; Min, complex&lt;T&gt; Max&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_limit( Y,&nbsp;X:fVector; size:UIntSize; Min, Max:Single&nbsp;);
<BR>procedure VCF_limit( Y,&nbsp;X:cfVector; size:UIntSize; Min, Max:fComplex&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_limit( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Min, float&nbsp;Max&nbsp;);
<BR>int cusdVF_limit( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_Min, float&nbsp;*d_Max&nbsp;);
<BR>void VFcu_limit( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Min, float&nbsp;Max&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_limit( d_Y, d_X:fVector; size:UIntSize; Min,&nbsp;Max:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_limit( d_Y, d_X:fVector; size:UIntSize; d_Min,&nbsp;d_Max:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_limit( h_Y, h_X:fVector; size:UIntSize; Min,&nbsp;Max:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><u>Real version:</u><BR>Y<sub>i</sub> = X<sub>i</sub> , if Min &lt;= X<sub>i</sub> &lt;= Max
<BR>Y<sub>i</sub> = Max, if X<sub>i</sub> &gt; Max
<BR>Y<sub>i</sub> = Min, if X<sub>i</sub> &lt; Min
<BR>This function may be seen as a combination of <I><a href="#maxC">VF_maxC</a></I> and <I><a href="#minC">VF_minC</a></I>.
<BR><u>Complex version:</u>
<BR>Similar to the real version, but the real and imaginary parts are limited separately to the ranges specified in the respective parts of Min and Max.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxC">VF_maxC</a>,&nbsp;&nbsp; <a href="#minC">VF_minC</a>,&nbsp;&nbsp; <a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#flush0">VF_flush0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="lincomb"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_lincomb</b></font></td><td width="33%"><font size="+1"><b>VD_lincomb</b></font></td><td><font size="+1"><b>VE_lincomb</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_lincomb</b></font></td><td width="33%"><font size="+1"><b>VCD_lincomb</b></font></td><td><font size="+1"><b>VCE_lincomb</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>linear combination of two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_lincomb( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;CX, float&nbsp;CY&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::lincomb( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;CX, const&nbsp;T&amp;&nbsp;CY&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_lincomb( Z, X,&nbsp;Y:fVector; size:UIntSize; CX, CY:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_lincomb( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;CX, float&nbsp;CY&nbsp;);
<BR>int cusdVF_lincomb( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_CX, float&nbsp;*d_CY&nbsp;);
<BR>void VFcu_lincomb( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;CX, float&nbsp;CY&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_lincomb( d_Z,&nbsp;d_X,&nbsp;d_Y:fVector; size:UIntSize; CX,&nbsp;CY:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_lincomb( d_Z,&nbsp;d_X,&nbsp;d_Y:fVector; size:UIntSize; d_CX,&nbsp;d_CY:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_lincomb( h_Z,&nbsp;h_X,&nbsp;h_Y:fVector; size:UIntSize; CX,&nbsp;CY:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = CX *&nbsp;X<sub>i</sub> + CY *&nbsp;Y<sub>i</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#addV">VFx_addV</a>, &nbsp;&nbsp;<a href="#rotateCoordinates">VF_rotateCoordinates</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="linregress"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_linregress</b></font></td><td width="33%"><font size="+1"><b>VD_linregress</b></font></td><td><font size="+1"><b>VE_linregress</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Linear regression</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_linregress( fVector&nbsp;Param, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::linregress( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_linregress( Param,&nbsp;X,&nbsp;Y:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_linregress( fVector&nbsp;h_Param, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>int cusdVF_linregress( fVector&nbsp;d_Param, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>void VF_linregress( fVector&nbsp;h_Param, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_linregress( h_Param,&nbsp;d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_linregress( d_Param,&nbsp;d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_linregress( h_Param,&nbsp;h_X,&nbsp;h_Y:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The X-Y data are fitted to a straight line y = ax + b; the parameters a and b are determined in such a way that the quantity
<BR>h<sup>2</sup> = sum( (Y<sub>i</sub> - y(x=X<sub>i</sub>)&nbsp;)<sup>2</sup>&nbsp;)
<BR>is minimized. Uncertainties da and db are also determined. On output, Param is filled with the 5 elements {a, da, b, db, h<sup>2</sup>} in the order indicated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#linregresswW">VF_linregresswW</a>,&nbsp;&nbsp; <a href="#corrcoeff">VF_corrcoeff</a>,&nbsp;&nbsp; <a href="#chi2">VF_chi2</a>,&nbsp;&nbsp; <a href="MATRIX.HTM#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="MATRIX.HTM#nonlinfit">VF_nonlinfit</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="linregresswW"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_linregresswW</b></font></td><td width="33%"><font size="+1"><b>VD_linregresswW</b></font></td><td><font size="+1"><b>VE_linregresswW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Linear regression with weights</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_linregresswW( fVector&nbsp;Param, fVector&nbsp;X, fVector&nbsp;Y, fVector&nbsp;InvVar, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::linregresswW( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;InvVar&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_linregresswW( Param, X, Y, InvVar:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_linregresswW( fVector&nbsp;h_Param, fVector&nbsp;d_X, fVector&nbsp;d_Y, fVector&nbsp;d_InvVar, ui&nbsp;size&nbsp;);
<BR>int cusdVF_linregresswW( fVector&nbsp;d_Param, fVector&nbsp;d_X, fVector&nbsp;d_Y, fVector&nbsp;d_InvVar, ui&nbsp;size&nbsp;);
<BR>void VF_linregresswW( fVector&nbsp;h_Param, fVector&nbsp;h_X, fVector&nbsp;h_Y, fVector&nbsp;h_InvVar, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_linregresswW( h_Param,&nbsp;d_X,&nbsp;d_Y,&nbsp;d_InvVar:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_linregresswW( d_Param,&nbsp;d_X,&nbsp;d_Y,&nbsp;d_InvVar:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_linregresswW( h_Param,&nbsp;h_X,&nbsp;h_Y,&nbsp;h_InvVar:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The X-Y data are weighted with the inverse of their variances and fitted to a straight line <I>y = ax + b;</I> the parameters <I>a</I> and <I>b</I> are determined in such a way as to minimize the merit function
<BR><font face="symbol">c</font><sup>2</sup> = sum( (1 / Var<sub>i</sub>) *&nbsp;(Y<sub>i</sub> - y(x=X<sub>i</sub>)&nbsp;)<sup>2</sup>&nbsp;)
<BR>(see also <I><a href="#chi2">VF_chi2</a></I>). The inverse of the variance of each data point has to be passed to the function in the vector InvVar. Uncertainties <I>da</I> and <I>db</I> are also determined. On output, <I>Param</I> is filled with the 5 elements {<I>a, da, b, db, <font face="symbol">c</font><sup>2</sup></I>} in the order indicated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#linregress">VF_linregress</a>,&nbsp;&nbsp; <a href="#corrcoeff">VF_corrcoeff</a>,&nbsp;&nbsp; <a href="#chi2">VF_chi2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="LItoF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_LItoF</b></font></td><td width="33%"><font size="+1"><b>V_LItoD</b></font></td><td><font size="+1"><b>V_LItoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type interconversions. See <I><a href="#ItoF">V_ItoF</a></I>!</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ln"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ln</b></font></td><td width="33%"><font size="+1"><b>VD_ln</b></font></td><td><font size="+1"><b>VE_ln</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_ln</b></font></td><td width="33%"><font size="+1"><b>VCD_ln</b></font></td><td><font size="+1"><b>VCE_ln</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_ln</b></font></td><td width="33%"><font size="+1"><b>VDx_ln</b></font></td><td><font size="+1"><b>VEx_ln</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_ln</b></font></td><td width="33%"><font size="+1"><b>VCDx_ln</b></font></td><td><font size="+1"><b>VCEx_ln</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_lntoC</b></font></td><td width="33%"><font size="+1"><b>VPD_lntoC</b></font></td><td><font size="+1"><b>VPE_lntoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Natural logarithm</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ln( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_ln( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VPF_lntoC( cfVector&nbsp;Y, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ln( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_ln( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>int vector&lt;complex&lt;T&gt;&gt;::lntoC( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_ln( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_ln( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VPF_lntoC( Y:cfVector; X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_ln( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_ln( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_ln( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_ln( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_ln( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_ln( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_ln( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_ln( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_ln( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_ln( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These function names are synonyms for the functions of the <I><a href="#log">VF_log</a></I> family. See <I><a href="#log">VF_log</a></I> for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="localmaxima"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_localmaxima</b></font></td><td width="33%"><font size="+1"><b>VD_localmaxima</b></font></td><td><font size="+1"><b>VE_localmaxima</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the indices of local maxima</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>ui VF_localmaxima( uiVector&nbsp;Ind, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;ui&gt;::localmaxima( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_localmaxima( Ind:uiVector; X:fVector; size:UIntSize&nbsp;):UIntSize;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_localmaxima( ui&nbsp;*h_nFound, uiVector&nbsp;d_Ind, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>ui VFcu_localmaxima( uiVector&nbsp;h_Ind, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_localmaxima( var&nbsp;h_nFound:UIntSize; d_Ind:uiVector; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_localmaxima( h_Ind:uiVector; h_X:fVector; size:UIntSize&nbsp;):&nbsp;UIntSize;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The indices of local maxima in X are stored in Ind and the number of local maxima is returned (this is the number of elements of Ind). A local maximum is defined as one element of X that is greater than both its neighbours to the right and to the left. That means that the zero'th and the last element of X (which have only one neighbour) cannot be local maxima. Also, if two adjacent elements are equal, none of them can be a local maximum.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>number of local maxima found</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxind">VF_maxind</a>,&nbsp;&nbsp; <a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#localminima">VF_localminima</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="localminima"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_localminima</b></font></td><td width="33%"><font size="+1"><b>VD_localminima</b></font></td><td><font size="+1"><b>VE_localminima</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the indices of local minima</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>ui VF_localminima( uiVector&nbsp;Ind, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;ui&gt;::localminima( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Ind&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_localminima( Ind:uiVector; X:fVector; size:UIntSize&nbsp;):UIntSize;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_localminima( ui&nbsp;*h_nFound, uiVector&nbsp;d_Ind, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>ui VFcu_localminima( uiVector&nbsp;h_Ind, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_localminima( var&nbsp;h_nFound:UIntSize; d_Ind:uiVector; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_localminima( h_Ind:uiVector; h_X:fVector; size:UIntSize&nbsp;):&nbsp;UIntSize;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The indices of local minima in X are stored in Ind and the number of local minima is returned (this is the number of elements of Ind). A local minimum is defined as one element of X that is smaller than both its neighbours to the right and to the left. That means that the zero'th and the last element of X (which have only one neighbour) cannot be local minima. Also, if two adjacent elements are equal, none of them can be a local minimum.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>number of local minima found</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minind">VF_minind</a>,&nbsp;&nbsp; <a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#localmaxima">VF_localmaxima</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="log"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_log</b></font></td><td width="33%"><font size="+1"><b>VD_log</b></font></td><td><font size="+1"><b>VE_log</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_log</b></font></td><td width="33%"><font size="+1"><b>VCD_log</b></font></td><td><font size="+1"><b>VCE_log</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_log</b></font></td><td width="33%"><font size="+1"><b>VDx_log</b></font></td><td><font size="+1"><b>VEx_log</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_log</b></font></td><td width="33%"><font size="+1"><b>VCDx_log</b></font></td><td><font size="+1"><b>VCEx_log</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_logtoC</b></font></td><td width="33%"><font size="+1"><b>VPD_logtoC</b></font></td><td><font size="+1"><b>VPE_logtoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Natural logarithm</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_log( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_log( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VPF_logtoC( cfVector&nbsp;Y, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::log( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_log( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>int vector&lt;complex&lt;T&gt;&gt;::logtoC( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_log( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_log( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VPF_logtoC( Y:cfVector; X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_log( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_log( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_log( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_log( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_log( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_log( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_log( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_log( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_log( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_log( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = ln( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;ln( A*X<sub>i</sub>+B&nbsp;)
<BR>The &quot;logarithmus naturalis&quot;, i.e. the logarithm to the basis of Euler's constant <I>e</I> is calculated.
<BR>The logarithm of polar complex numbers is most naturally stored in cartesian format, as log{Mag@Arg} = {Mag,Arg}. Therefore, the <I>VPF_</I> version exists only with the result in a cfVector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real versions: DOMAIN errors occur in the case of negative X<sub>i</sub> (including -0.0), with NAN (&quot;not-a-number&quot;) as the default result. SING errors occur for X<sub>i</sub>= +0.0 and yield a result of -HUGE_VAL. In the complex version, numbers with an imaginary part of zero are always treated as real numbers; therefore, an argument {0, 0} is treated as a real 0, causing a SING error with the default result {-HUGE_VAL, 0}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; log</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="log10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_log10</b></font></td><td width="33%"><font size="+1"><b>VD_log10</b></font></td><td><font size="+1"><b>VE_log10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_log10</b></font></td><td width="33%"><font size="+1"><b>VCD_log10</b></font></td><td><font size="+1"><b>VCE_log10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_log10</b></font></td><td width="33%"><font size="+1"><b>VDx_log10</b></font></td><td><font size="+1"><b>VEx_log10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_log10</b></font></td><td width="33%"><font size="+1"><b>VCDx_log10</b></font></td><td><font size="+1"><b>VCEx_log10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_log10toC</b></font></td><td width="33%"><font size="+1"><b>VPD_log10toC</b></font></td><td><font size="+1"><b>VPE_log10toC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Decadic logarithm</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_log10( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_log10( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VPF_log10toC( cfVector&nbsp;Y, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::log10( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_log10( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>int vector&lt;complex&lt;T&gt;&gt;::log10toC( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_log10( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_log10( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VPF_log10toC( Y:cfVector; X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_log10( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_log10( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_log10( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_log10( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_log10( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_log10( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_log10( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_log10( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_log10( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_log10( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = lg( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;lg( A*X<sub>i</sub>+B&nbsp;)
<BR>The decadic logarithm (to the basis of 10) is calculated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real versions: DOMAIN errors occur in the case of negative X<sub>i</sub> (including -0.0), with NAN (&quot;not-a-number&quot;) as the default result. SING errors occur for X<sub>i</sub>= +0.0 and yield a result of -HUGE_VAL. In the complex version, numbers with an imaginary part of zero are always treated as real numbers; therefore, an argument {0, 0} is treated as a real 0, causing a SING error with the default result {-HUGE_VAL, 0}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#pow10">VF_pow10</a>,&nbsp;&nbsp; <a href="#log">VF_log</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#scal_log10">log10</a></I> (the latter function is defined in ANSI C; for Pascal, it is available in the unit XMATH coming with <I>OptiVec</I>).</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="log2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_log2</b></font></td><td width="33%"><font size="+1"><b>VD_log2</b></font></td><td><font size="+1"><b>VE_log2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_log2</b></font></td><td width="33%"><font size="+1"><b>VCD_log2</b></font></td><td><font size="+1"><b>VCE_log2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_log2</b></font></td><td width="33%"><font size="+1"><b>VDx_log2</b></font></td><td><font size="+1"><b>VEx_log2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_log2</b></font></td><td width="33%"><font size="+1"><b>VCDx_log2</b></font></td><td><font size="+1"><b>VCEx_log2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_log2toC</b></font></td><td width="33%"><font size="+1"><b>VPD_log2toC</b></font></td><td><font size="+1"><b>VPE_log2toC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Binary logarithm</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_log2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_log2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VPF_log2toC( cfVector&nbsp;Y, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::log2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_log2( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>int vector&lt;complex&lt;T&gt;&gt;::log2toC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_log2( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_log2( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VPF_log2toC( Y:cfVector; X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_log2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_log2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_log2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_log2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_log2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_log2( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_log2( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_log2( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_log2( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_log2( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = lb( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;lb( A*X<sub>i</sub>+B&nbsp;)
<BR>The binary logarithm (to the basis 2) is calculated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real versions: DOMAIN errors occur in the case of negative X<sub>i</sub> (including -0.0), with NAN (&quot;not-a-number&quot;) as the default result. SING errors occur for X<sub>i</sub>= +0.0 and yield a result of -HUGE_VAL. In the complex version, numbers with an imaginary part of zero are always treated as real numbers; therefore, an argument {0, 0} is treated as a real 0, causing a SING error with the default result {-HUGE_VAL, 0}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#pow2">VF_pow2</a>,&nbsp;&nbsp; <a href="#log">VF_log</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#scal_log2">log2</a></I> (the latter function is neither defined in ANSI C nor in Pascal/Delphi, but an addition contained in &lt;xmath.h&gt; or in the unit XMATH).</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Lorentz"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Lorentz</b></font></td><td width="33%"><font size="+1"><b>VD_Lorentz</b></font></td><td><font size="+1"><b>VE_Lorentz</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Lorentzian lineshape function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_Lorentz( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float Wid, float&nbsp;Cent, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::Lorentz( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, T Wid, const&nbsp;T&amp;&nbsp;Cent, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_Lorentz( Y,&nbsp;X:fVector; size:UIntSize; Wid, Cent, C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_Lorentz( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Wid, float&nbsp;Cent, float&nbsp;C&nbsp;);
<BR>int cusdVF_Lorentz( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_Wid, float&nbsp;*d_Cent, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_Lorentz( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Wid, float&nbsp;Cent, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_Lorentz( d_Y,&nbsp;d_X:fVector; size:UIntSize; Wid,&nbsp;Cent,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_Lorentz( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_Wid,&nbsp;d_Cent,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_Lorentz( h_Y,&nbsp;h_X:fVector; size:UIntSize; Wid,&nbsp;Cent&nbsp; C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = C *&nbsp;Wid<sup>2</sup> / ( (X<sub>i</sub> - Cent)<sup>2</sup> + Wid<sup>2</sup>&nbsp;)
<BR>Wid = width of the resonance line
<BR>Cent = centre of the line
<BR>C is a scaling factor; at the center of the line (X<sub>i</sub>=Cent), the amplitude Y<sub>i</sub> equals C. This is even true for a width of zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>This function should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Gauss">VF_Gauss</a>,&nbsp;&nbsp; <a href="#sech2">VF_sech2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="MagArgtoP"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_MagArgtoP</b></font></td><td width="33%"><font size="+1"><b>VD_MagArgtoP</b></font></td><td><font size="+1"><b>VE_MagArgtoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct a polar complex vector from separate vectors for magnitude and argument</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_MagArgtoP( pfVector&nbsp;Y, fVector&nbsp;Mag, fVector&nbsp;Arg, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::MagArgtoP( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Mag, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Arg&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_MagArgtoP( X:pfVector; Mag, Arg:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_MagArgtoP( cfVector&nbsp;d_Y, fVector&nbsp;d_Mag, fVector&nbsp;d_Arg, ui&nbsp;size&nbsp;);
<BR>void VFcu_MagArgtoP( cfVector&nbsp;h_Y, fVector&nbsp;h_Mag, fVector&nbsp;h_Arg, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_MagArgtoP( d_X:cfVector; d_Mag,&nbsp;d_Arg:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_MagArgtoP( h_X:cfVector; h_Mag,&nbsp;h_Arg:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar complex vector Y is constructed from the two real vectors Mag and Arg.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoMagArg">VF_PtoMagArg</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#MagtoP">VF_MagtoP</a>,&nbsp;&nbsp; <a href="#ArgtoP">VF_ArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="MagArgtoPrincipal"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_MagArgtoPrincipal</b></font></td><td width="33%"><font size="+1"><b>VD_MagArgtoPrincipal</b></font></td><td><font size="+1"><b>VE_MagArgtoPrincipal</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct a polar complex vector from separate vectors for magnitude and argument, reducing to the principal value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_MagArgtoPrincipal( pfVector&nbsp;Y, fVector&nbsp;Mag, fVector&nbsp;Arg, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::MagArgtoPrincipal( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Mag, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Arg&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_MagArgtoPrincipal( X:pfVector; Mag, Arg:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_MagArgtoPrincipal( cfVector&nbsp;d_Y, fVector&nbsp;d_Mag, fVector&nbsp;d_Arg, ui&nbsp;size&nbsp;);
<BR>void VFcu_MagArgtoPrincipal( cfVector&nbsp;h_Y, fVector&nbsp;h_Mag, fVector&nbsp;h_Arg, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_MagArgtoPrincipal( d_X:cfVector; d_Mag,&nbsp;d_Arg:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_MagArgtoPrincipal( h_X:cfVector; h_Mag,&nbsp;h_Arg:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar complex vector Y is constructed from the two real vectors Mag and Arg. The arguments are reduced to the principal value,  -<font face="symbol">p</font> &lt; Arg &lt;= +<font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#principal">VPF_principal</a>,&nbsp;&nbsp; <a href="#MagArgtoP">VF_MagArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="MagtoP"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_MagtoP</b></font></td><td width="33%"><font size="+1"><b>VD_MagtoP</b></font></td><td><font size="+1"><b>VE_MagtoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Overwrite the Mag part of a polar complex vector with a real vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_MagtoP( pfVector&nbsp;Y, fVector&nbsp;Mag, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::MagtoP( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Mag&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_MagtoP( X:pfVector; Mag:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_MagtoP( pfVector&nbsp;d_Y, fVector&nbsp;d_Mag, ui&nbsp;size&nbsp;);
<BR>void VFcu_MagtoP( pfVector&nbsp;h_Y, fVector&nbsp;h_Mag, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_MagtoP( d_X:pfVector; d_Mag:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_MagtoP( h_X:pfVector; h_Mag:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The Mag part of the polar complex vector Y is overwritten with the elements of the real-valued vector Mag. The Arg part of Y is not affected.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoMagArg">VF_PtoMagArg</a>,&nbsp;&nbsp; <a href="#MagArgtoP">VF_MagArgtoP</a>,&nbsp;&nbsp; <a href="#ArgtoP">VF_ArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="mantexp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mantexp</b></font></td><td width="33%"><font size="+1"><b>VD_mantexp</b></font></td><td><font size="+1"><b>VE_mantexp</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Split up the elements of a vector into their mantissa and exponent parts</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_mantexp( fVector&nbsp;MantPart, iVector&nbsp;ExpPart, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::mantexp( vector&lt;int&gt; ExpPart, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_mantexp( MantPart:fVector; ExpPart:iVector; X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_mantexp( fVector&nbsp;d_MantPart, iVector&nbsp;d_ExpPart, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_mantexp( fVector&nbsp;h_MantPart, iVector&nbsp;h_ExpPart, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_mantexp( d_MantPart:fVector; d_ExpPart:iVector; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_mantexp( h_MantPart:fVector; h_ExpPart:iVector; h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The elements of X are split up into their mantissa, stored in MantPart, and exponent, stored as ints in ExpPart.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#scale2">VF_scale2</a>,&nbsp;&nbsp; <a href="#intfrac">VF_intfrac</a>,&nbsp;&nbsp; frexp</I> (only C/C++),&nbsp;&nbsp;<I>ldexp</I> (only C/C++)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="max"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_max</b></font></td><td width="34%"><font size="+1"><b>VD_max</b></font></td><td><font size="+1"><b>VE_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_max</b></font></td><td width="17%"><font size="+1"><b>VBI_max</b></font></td><td width="17%"><font size="+1"><b>VSI_max</b></font></td><td width="17%"><font size="+1"><b>VLI_max</b></font></td><td width="17%"><font size="+1"><b>VQI_max</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_max</b></font></td><td width="17%"><font size="+1"><b>VUB_max</b></font></td><td width="17%"><font size="+1"><b>VUS_max</b></font></td><td width="17%"><font size="+1"><b>VUL_max</b></font></td><td width="17%"><font size="+1"><b>VUQ_max</b></font></td><td><font size="+1"><b>VUI_max</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the largest element of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_max( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::_max();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_max( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_max( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_max( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_max( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_max( var&nbsp;h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_max( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_max( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is searched for its largest element, whose value is returned. In order to avoid confusion with the macro "max" in C/C++, the VecObj version of this function is written with a leading underbar as "_max".</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>maximum value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#minmax">VF_minmax</a>,&nbsp;&nbsp; <a href="#stats">VF_min_max_mean_stddev</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#maxexp">VF_maxexp</a>,&nbsp;&nbsp; <a href="#runmax">VF_runmax</a>,&nbsp;&nbsp; <a href="#maxind">VF_maxind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="maxC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_maxC</b></font></td><td width="34%"><font size="+1"><b>VD_maxC</b></font></td><td><font size="+1"><b>VE_maxC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_maxC</b></font></td><td width="17%"><font size="+1"><b>VBI_maxC</b></font></td><td width="17%"><font size="+1"><b>VSI_maxC</b></font></td><td width="17%"><font size="+1"><b>VLI_maxC</b></font></td><td width="17%"><font size="+1"><b>VQI_maxC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_maxC</b></font></td><td width="17%"><font size="+1"><b>VUB_maxC</b></font></td><td width="17%"><font size="+1"><b>VUS_maxC</b></font></td><td width="17%"><font size="+1"><b>VUL_maxC</b></font></td><td width="17%"><font size="+1"><b>VUQ_maxC</b></font></td><td><font size="+1"><b>VUI_maxC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compare each element of a vector to a constant and take the larger of the two.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_maxC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::maxC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_maxC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVDmath.h&gt;
<BR>int cudaVF_maxC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_maxC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_maxC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VDmath;
<BR>function cudaVF_maxC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_maxC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VF_maxC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub>, if X<sub>i</sub> &gt; C
<BR>Y<sub>i</sub> = C, if X<sub>i</sub> &lt;= C</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxV">VF_maxV</a>,&nbsp;&nbsp; <a href="#minC">VF_minC</a>,&nbsp;&nbsp; <a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#limit">VF_limit</a>,&nbsp;&nbsp; <a href="#flush0">VF_flush0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="maxexp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_maxexp</b></font></td><td width="33%"><font size="+1"><b>VD_maxexp</b></font></td><td><font size="+1"><b>VE_maxexp</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Largest exponent within one vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>int VF_maxexp( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::maxexp();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_maxexp( X:fVector; size:UIntSize&nbsp;):&nbsp;Integer;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_maxexp( int&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_maxexp( int&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_maxexp( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_maxexp( var&nbsp;h_RetVal:Integer; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_maxexp( d_RetVal:PInteger; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_maxexp( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Integer;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Considering that each number can be represented as a product, <I>mantissa *&nbsp;2<sup>exponent</sup></I>, where 1.0 &lt;= <I>mantissa</I> &lt; 2.0, the largest <I>exponent</I> occurring in a vector is returned. If the vector consisted of nothing but zeros, the <I>exponent</I> is returned as -2<sup>31</sup> (32-bit models) or -2<sup>15</sup> (16-bit models).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>maximum exponent encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minexp">VF_minexp</a>,&nbsp;&nbsp; <a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#runmax">VF_runmax</a>,&nbsp;&nbsp; <a href="#absmaxind">VF_absmaxind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="maxind"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_maxind</b></font></td><td width="34%"><font size="+1"><b>VD_maxind</b></font></td><td><font size="+1"><b>VE_maxind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_maxind</b></font></td><td width="17%"><font size="+1"><b>VBI_maxind</b></font></td><td width="17%"><font size="+1"><b>VSI_maxind</b></font></td><td width="17%"><font size="+1"><b>VLI_maxind</b></font></td><td width="17%"><font size="+1"><b>VQI_maxind</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_maxind</b></font></td><td width="17%"><font size="+1"><b>VUB_maxind</b></font></td><td width="17%"><font size="+1"><b>VUS_maxind</b></font></td><td width="17%"><font size="+1"><b>VUL_maxind</b></font></td><td width="17%"><font size="+1"><b>VUQ_maxind</b></font></td><td><font size="+1"><b>VUI_maxind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the largest element of a vector and its index.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_maxind( ui&nbsp;*Ind, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::maxind( ui&nbsp;*Ind&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_maxind( var Ind:UIntSize; X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_maxind( float&nbsp;*h_RetVal, ui&nbsp;*h_Ind, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_maxind( float&nbsp;*d_RetVal, ui&nbsp;*h_Ind, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_maxind( ui&nbsp;*h_Ind, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_maxind( var&nbsp;h_RetVal:Single; var&nbsp;h_Ind:UIntSize; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_maxind( d_RetVal:PSingle; var&nbsp;h_Ind:UIntSize; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_maxind( var&nbsp;h_Ind:UIntSize; h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is searched for its largest element; its value is returned. At the address passed as Ind, the index of this element is stored.In the case of several maxima of equal height, the first one is chosen (i.e., the smallest index is stored in Ind).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>maximum value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#minind">VF_minind</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#runmax">VF_runmax</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="maxReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_maxReIm</b></font></td><td width="33%"><font size="+1"><b>VCD_maxReIm</b></font></td><td><font size="+1"><b>VCE_maxReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the largest real and imaginary parts occurring in a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>fComplex VCF_maxReIm( cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex&lt;T&gt; vector&lt;complex&lt;T&gt;&gt;::maxReIm();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function VCF_maxReIm( X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
<BR>Alternative syntax (obsolete, but still supported):<font face="courier new">
<BR>procedure VCF_maxReIm( var RetVal:fComplex; X:cfVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_maxReIm( fComplex *h_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVCF_maxReIm( fComplex *d_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>fComplex VCFcu_maxReIm( cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_maxReIm( var h_RetVal:fComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVCF_maxReIm( d_RetVal:PfComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VCFcu_maxReIm( h_X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is separately searched for its largest real and imaginary parts. These are packed together and either returned as an fComplex (in C/C++) or stored in Max (in Pascal/Delphi):
<BR>Max.Re: largest real part encountered,
<BR>Max.Im: largest imaginary part encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td><u>C/C++:</u>
<BR>struct or class instance of type fComplex (dComplex, eComplex, resp.), in which the maxima of the real and imaginary parts of X are packed together.
<BR><u>Pascal/Delphi:</u>
<BR>since Pascal does not allow complex return values, the result is stored in the variable Max.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minReIm">VCF_minReIm</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a>,&nbsp;&nbsp; <a href="#absmax">VCF_absmax</a>,&nbsp;&nbsp; <a href="#absmaxind">VCF_absmaxind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="maxV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_maxV</b></font></td><td width="34%"><font size="+1"><b>VD_maxV</b></font></td><td><font size="+1"><b>VE_maxV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_maxV</b></font></td><td width="17%"><font size="+1"><b>VBI_maxV</b></font></td><td width="17%"><font size="+1"><b>VSI_maxV</b></font></td><td width="17%"><font size="+1"><b>VLI_maxV</b></font></td><td width="17%"><font size="+1"><b>VQI_maxV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_maxV</b></font></td><td width="17%"><font size="+1"><b>VUB_maxV</b></font></td><td width="17%"><font size="+1"><b>VUS_maxV</b></font></td><td width="17%"><font size="+1"><b>VUL_maxV</b></font></td><td width="17%"><font size="+1"><b>VUQ_maxV</b></font></td><td><font size="+1"><b>VUI_maxV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compare each element of a vector to the corresponding element of another vector and take the larger of the two.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_maxV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::maxV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_maxV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_maxV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>void VFcu_maxV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_maxV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_maxV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = X<sub>i</sub>, if X<sub>i</sub> &gt; Y<sub>i</sub>
<BR>Z<sub>i</sub> = Y<sub>i</sub>, if X<sub>i</sub> &lt;= Y<sub>i</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minV">VF_minV</a>,&nbsp;&nbsp; <a href="#maxC">VF_maxC</a>,&nbsp;&nbsp; <a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="mean"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mean</b></font></td><td width="34%"><font size="+1"><b>VD_mean</b></font></td><td><font size="+1"><b>VE_mean</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mean</b></font></td><td width="34%"><font size="+1"><b>VCD_mean</b></font></td><td><font size="+1"><b>VCE_mean</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_mean</b></font></td><td width="17%"><font size="+1"><b>VBI_mean</b></font></td><td width="17%"><font size="+1"><b>VSI_mean</b></font></td><td width="17%"><font size="+1"><b>VLI_mean</b></font></td><td width="17%"><font size="+1"><b>VQI_mean</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_mean</b></font></td><td width="17%"><font size="+1"><b>VUB_mean</b></font></td><td width="17%"><font size="+1"><b>VUS_mean</b></font></td><td width="17%"><font size="+1"><b>VUL_mean</b></font></td><td width="17%"><font size="+1"><b>VUQ_mean</b></font></td><td><font size="+1"><b>VUI_mean</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean of a one-dimensional distribution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_mean( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VCF_,&nbsp;&nbsp; VCD_,&nbsp;&nbsp; VCE_</I>)
<BR><font face="courier new">double VI_mean( iVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VU_,&nbsp;&nbsp; VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_,&nbsp;&nbsp; VUI_</I>)
<BR><font face="courier new">extended VQI_mean( qiVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::mean();
<BR>double vector&lt;int&gt;::mean();
<BR>extended vector&lt;quad&gt;::mean();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_mean( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new"><BR>function VCF_mean( X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
<BR>Alternative syntax (obsolete, but still supported):<font face="courier new">
procedure VCF_mean( var Mean:fComplex; X:cfVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)
<BR><font face="courier new">function VI_mean( X:iVector; size:UIntSize&nbsp;); Double;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VU_,&nbsp;&nbsp; VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_</I>)
<BR><font face="courier new">function VQI_mean( X:qiVector; size:UIntSize&nbsp;); Extended;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_mean( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_mean( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_mean( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_mean( var&nbsp;h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_mean( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_mean( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>mean = (1 / size) *&nbsp;sum( X<sub>i</sub>&nbsp;)
<BR>Integer versions: the mean of a distribution consisting of whole numbers generally is a fractional, i.e. a floating-point number. Therefore, the return value of the 8, 16, and 32-bit integer versions is a double. For the 64-bit integer version, <I>VQI_mean</I>, the return value is an extended.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Mean of the vector elements (except complex versions in Pascal/Delphi)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#median">VF_median</a>,&nbsp;&nbsp; <a href="#meanvar">VF_meanvar</a>,&nbsp;&nbsp; <a href="#stats">VF_min_max_mean_stddev</a>,&nbsp;&nbsp; <a href="#fsum">VI_fsum</a>,&nbsp;&nbsp; <a href="#varianceC">VF_varianceC</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="meanabs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_meanabs</b></font></td><td width="33%"><font size="+1"><b>VD_meanabs</b></font></td><td><font size="+1"><b>VE_meanabs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean of the absolute values of a one-dimensional distribution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_meanabs( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::meanabs();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_meanabs( X:fVector; size: UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_meanabs( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_meanabs( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_meanabs( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_meanabs( var&nbsp;h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_meanabs( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_meanabs( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>meanabs = (1 / size) *&nbsp;sum(| X<sub>i</sub> |)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Mean of the absolute values of all vector elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#sumabs">VF_sumabs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="meanvar"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_meanvar</b></font></td><td width="33%"><font size="+1"><b>VD_meanvar</b></font></td><td><font size="+1"><b>VE_meanvar</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean and variance of a one-dimensional distribution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_meanvar( float *Var, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::meanvar( T *Var&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_meanvar( var Variance:Single; X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_meanvar( float&nbsp;*h_RetValMean, float&nbsp;*h_RetValVariance, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_meanvar( float&nbsp;*d_RetValMean, float&nbsp;*d_RetValVariance, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_meanvar( float&nbsp;*h_RetValVariance, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_meanvar( var&nbsp;h_RetValMean,&nbsp;h_RetValVariance:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_meanvar( d_RetValMean,&nbsp;d_RetValVariance:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_meanvar( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>mean = (1 / size) *&nbsp;sum( X<sub>i</sub>&nbsp;)
<BR>var = (1 / (size-1)) *&nbsp;sum( (X<sub>i</sub> - mean)<sup>2</sup>&nbsp;)
<BR>Note that the denominator in the definition of var is size-1, whereas, in the routine <I><a href="#varianceC">VF_varianceC</a></I>, it is simply size.The reason for that difference is that here the mean is calculated first and then the variance is determined using this value, whereas in <I><a href="#varianceC">VF_varianceC</a></I>, the parameter C is pre-set. The mean is returned and the variance stored at the address passed as &quot;Var&quot; (C/C++), or in the variable &quot;variance&quot; (Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>mean of the vector elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#stats">VF_min_max_mean_stddev</a>,&nbsp;&nbsp; <a href="#varianceC">VF_varianceC</a>,&nbsp;&nbsp; <a href="#varianceV">VF_varianceV</a>,&nbsp;&nbsp; <a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="meanvarwW"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_meanvarwW</b></font></td><td width="33%"><font size="+1"><b>VD_meanvarwW</b></font></td><td><font size="+1"><b>VE_meanvarwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean and variance with weights</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>float VF_meanvarwW( float *Var, fVector&nbsp;X, fVector&nbsp;Wt, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::meanvarwW( T *Var, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Wt&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_meanvarwW( var variance:Single; X, Wt:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_meanvarwW( float&nbsp;*h_RetValMean, float&nbsp;*h_RetValVariance, fVector&nbsp;d_X, fVector&nbsp;d_Wt, ui&nbsp;size&nbsp;);
<BR>int cusdVF_meanvarwW( float&nbsp;*d_RetValMean, float&nbsp;*d_RetValVariance, fVector&nbsp;d_X, fVector&nbsp;d_Wt, ui&nbsp;size&nbsp;);
<BR>float VFcu_meanvarwW( float&nbsp;*h_RetValVariance, fVector&nbsp;h_X, fVector&nbsp;h_Wt, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_meanvarwW( var&nbsp;h_RetValMean,&nbsp;h_RetValVariance:Single; d_X,&nbsp;d_Wt:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_meanvarwW( d_RetValMean,&nbsp;d_RetValVariance:PSingle; d_X,&nbsp;d_Wt:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_meanvarwW( h_X,&nbsp;h_Wt:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>mean = (1 / sum( Wt<sub>i</sub>&nbsp;)) *&nbsp;sum( X<sub>i</sub> *&nbsp;Wt<sub>i</sub>&nbsp;)
<BR>var = (1 / sum( Wt<sub>i</sub>&nbsp;)) *&nbsp;sum( Wt<sub>i</sub> *&nbsp;(X<sub>i</sub> - mean)<sup>2</sup>&nbsp;) 
<BR>The weighted mean is returned and the variance stored at the address passed as &quot;Var&quot; (C/C++) or in the variable &quot;variance&quot; (Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>mean of the vector elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#varianceCwW">VF_varianceCwW</a>,&nbsp;&nbsp; <a href="#varianceVwW">VF_varianceVwW</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="meanwW"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_meanwW</b></font></td><td width="33%"><font size="+1"><b>VD_meanwW</b></font></td><td><font size="+1"><b>VE_meanwW</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_meanwW</b></font></td><td width="33%"><font size="+1"><b>VCD_meanwW</b></font></td><td><font size="+1"><b>VCE_meanwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean with weights</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_meanwW( fVector&nbsp;X, fVector&nbsp;Wt, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">fComplex VCF_meanwW( cfVector&nbsp;X, fVector&nbsp;Wt, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::meanwW( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Wt&nbsp;);
<BR>fComplex vector&lt;complex&lt;T&gt;&gt;::meanwW( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Wt&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_meanwW( X, Wt:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new"><BR>function VCF_meanwW( X:cfVector; Wt:fVector; size:UIntSize&nbsp;):fComplex;</font>
<BR>Alternative syntax (obsolete, but still supported):<font face="courier new">
procedure VCF_meanwW( var Mean:fComplex; X:cfVector; Wt:fVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_meanwW( float&nbsp;*h_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Wt, ui&nbsp;size&nbsp;);
<BR>int cusdVF_meanwW( float&nbsp;*d_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Wt, ui&nbsp;size&nbsp;);
<BR>float VFcu_meanwW( fVector&nbsp;h_X, fVector&nbsp;h_Wt, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_meanwW( var&nbsp;h_RetVal:Single; d_X,&nbsp;d_Wt:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_meanwW( d_RetVal:PSingle; d_X,&nbsp;d_Wt:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_meanwW( h_X,&nbsp;h_Wt:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>meanwW = (1 / sum( Wt<sub>i</sub>&nbsp;)) *&nbsp;sum( X<sub>i</sub> *&nbsp;Wt<sub>i</sub>&nbsp;)
<BR>Notice that, also in the complex version, the weights are always real rather than complex.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>weighted mean of the vector elements (except complex versions in Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#median">VF_median</a>,&nbsp;&nbsp; <a href="#meanvarwW">VF_meanvarwW</a>,&nbsp;&nbsp; <a href="#linregresswW">VF_linregresswW</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="median"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_median</b></font></td><td width="33%"><font size="+1"><b>VD_median</b></font></td><td><font size="+1"><b>VE_median</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Median of a one-dimensional distribution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>float VF_median( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::median();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_median( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_median( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_median( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_median( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_median( var&nbsp;h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_median( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_median( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The median of a distribution is defined as the value for which values above and below are equally probable, i.e., for which the number of elements greater and less than the median is equal. If the table X is ordered, the median is simply the element with the index (size+1)/2 (if size is odd) or the mean of the two central elements (if size is even). If a table is not ordered, <I>VF_median</I> finds its median by repeatedly scanning the table through, without actually sorting it.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The median is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#sum">VF_sum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="min"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_min</b></font></td><td width="34%"><font size="+1"><b>VD_min</b></font></td><td><font size="+1"><b>VE_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_min</b></font></td><td width="17%"><font size="+1"><b>VBI_min</b></font></td><td width="17%"><font size="+1"><b>VSI_min</b></font></td><td width="17%"><font size="+1"><b>VLI_min</b></font></td><td width="17%"><font size="+1"><b>VQI_min</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_min</b></font></td><td width="17%"><font size="+1"><b>VUB_min</b></font></td><td width="17%"><font size="+1"><b>VUS_min</b></font></td><td width="17%"><font size="+1"><b>VUL_min</b></font></td><td width="17%"><font size="+1"><b>VUQ_min</b></font></td><td><font size="+1"><b>VUI_min</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Finds the smallest (or the most negative) element of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_min( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::_min();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_min( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_min( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_min( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_min( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_min( var&nbsp;h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_min( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_min( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is searched for its smallest (or most negative) element. In order to avoid confusion with the macro "min" in C/C++, the VecObj version of this function is written with a leading underbar as "_min".</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Minimum value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#minmax">VF_minmax</a>,&nbsp;&nbsp; <a href="#minexp">VF_minexp</a>,&nbsp;&nbsp; <a href="#runmin">VF_runmin</a>,&nbsp;&nbsp; <a href="#minind">VF_minind</a>,&nbsp;&nbsp; <a href="#stats">VF_min_max_mean_stddev</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="minC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_minC</b></font></td><td width="34%"><font size="+1"><b>VD_minC</b></font></td><td><font size="+1"><b>VE_minC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_minC</b></font></td><td width="17%"><font size="+1"><b>VBI_minC</b></font></td><td width="17%"><font size="+1"><b>VSI_minC</b></font></td><td width="17%"><font size="+1"><b>VLI_minC</b></font></td><td width="17%"><font size="+1"><b>VQI_minC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_minC</b></font></td><td width="17%"><font size="+1"><b>VUB_minC</b></font></td><td width="17%"><font size="+1"><b>VUS_minC</b></font></td><td width="17%"><font size="+1"><b>VUL_minC</b></font></td><td width="17%"><font size="+1"><b>VUQ_minC</b></font></td><td><font size="+1"><b>VUI_minC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compare each element of a vector to a constant and take the smaller of the two.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_minC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::minC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_minC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVDmath.h&gt;
<BR>int cudaVF_minC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_minC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_minC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VDmath;
<BR>function cudaVF_minC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_minC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VF_minC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub>,&nbsp;&nbsp;if X<sub>i</sub> &lt;= C
<BR>Y<sub>i</sub> = C,&nbsp;&nbsp;if X<sub>i</sub> &gt; C</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minV">VF_minV</a>,&nbsp;&nbsp; <a href="#maxC">VF_maxC</a>,&nbsp;&nbsp; <a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#limit">VF_limit</a>,&nbsp;&nbsp; <a href="#flush0">VF_flush0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="minexp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_minexp</b></font></td><td width="33%"><font size="+1"><b>VD_minexp</b></font></td><td><font size="+1"><b>VE_minexp</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Smallest exponent within one vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>int VF_minexp( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::minexp();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_minexp( X:fVector; size:UIntSize&nbsp;):&nbsp;Integer;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_minexp( int&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_minexp( int&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_minexp( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_minexp( var&nbsp;h_RetVal:Integer; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_minexp( d_RetVal:PInteger; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_minexp( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Integer;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Considering that each number can be represented as a product, <I>mantissa *&nbsp;2<sup>exponent</sup></I>, where 1.0 &lt;= <I>mantissa</I> &lt; 2.0, the smallest or most negative <I>exponent</I> occurring in a vector is returned. If the absolutely smallest number was zero, the <I>exponent</I> is returned as -2<sup>31</sup> (32-bit models) or -2<sup>15</sup> (16-bit models).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>minimum exponent encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxexp">VF_maxexp</a>,&nbsp;&nbsp; <a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#runmin">VF_runmin</a>,&nbsp;&nbsp; <a href="#absminind">VF_absminind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="minind"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_minind</b></font></td><td width="34%"><font size="+1"><b>VD_minind</b></font></td><td><font size="+1"><b>VE_minind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_minind</b></font></td><td width="17%"><font size="+1"><b>VBI_minind</b></font></td><td width="17%"><font size="+1"><b>VSI_minind</b></font></td><td width="17%"><font size="+1"><b>VLI_minind</b></font></td><td width="17%"><font size="+1"><b>VQI_minind</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_minind</b></font></td><td width="17%"><font size="+1"><b>VUB_minind</b></font></td><td width="17%"><font size="+1"><b>VUS_minind</b></font></td><td width="17%"><font size="+1"><b>VUL_minind</b></font></td><td width="17%"><font size="+1"><b>VUQ_minind</b></font></td><td><font size="+1"><b>VUI_minind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the smallest (or the most negative) element of a vector and its index.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_minind( ui&nbsp;*Ind, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::minind( ui&nbsp;*Ind&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_minind( var Ind:UIntSize; X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_minind( float&nbsp;*h_RetVal, ui&nbsp;*h_Ind, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_minind( float&nbsp;*d_RetVal, ui&nbsp;*h_Ind, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_minind( ui&nbsp;*h_Ind, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_minind( var&nbsp;h_RetVal:Single; var&nbsp;h_Ind:UIntSize; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_minind( d_RetVal:PSingle; var&nbsp;h_Ind:UIntSize; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_minind( var&nbsp;h_Ind:UIntSize; h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is searched for its smallest (or most negative) element; its value is returned. At the address passed as Ind, the index of this element is stored. In the case of several mimima of equal depth, the first one is chosen (i.e., the smallest of their indices is stored in Ind).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>minimum value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#maxind">VF_maxind</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#runmin">VF_runmin</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="minmax"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_minmax</b></font></td><td width="34%"><font size="+1"><b>VD_minmax</b></font></td><td><font size="+1"><b>VE_minmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_minmax</b></font></td><td width="17%"><font size="+1"><b>VBI_minmax</b></font></td><td width="17%"><font size="+1"><b>VSI_minmax</b></font></td><td width="17%"><font size="+1"><b>VLI_minmax</b></font></td><td width="17%"><font size="+1"><b>VQI_minmax</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_minmax</b></font></td><td width="17%"><font size="+1"><b>VUB_minmax</b></font></td><td width="17%"><font size="+1"><b>VUS_minmax</b></font></td><td width="17%"><font size="+1"><b>VUL_minmax</b></font></td><td width="17%"><font size="+1"><b>VUQ_minmax</b></font></td><td><font size="+1"><b>VUI_minmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Finds both the smallest and the largest element of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_minmax( float&nbsp;*xmax, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::minmax(T&nbsp;*xmax);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_minmax( var&nbsp;xmax:Single; X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_minmax( float&nbsp;*h_xmin, float&nbsp;*h_xmax, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_minmax( float&nbsp;*d_xmin, float&nbsp;*d_xmax, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_minmax( float&nbsp;*xmax, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_minmax( var&nbsp;h_xmin, h_xmax:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_minmax( d_xmin, d_xmax:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_minmax( var&nbsp;h_xmax:Single; h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is searched for its smallest (or most negative) and its largest element. The latter is stored as <i>xmax</i>, the smallest element is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Minimum value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#absminmax">VF_absminmax</a>,&nbsp;&nbsp; <a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#stats">VF_min_max_mean_stddev</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="stats"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_min_max_mean_stddev</b></font></td><td width="33%"><font size="+1"><b>VD_min_max_mean_stddev</b></font></td><td><font size="+1"><b>VE_min_max_mean_stddev</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>simultaneous calculation of the minimum, maximum, mean, and standard deviation of a one-dimensional distribution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_min_max_mean_stddev( fVector&nbsp;Stats, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::min_max_mean_stddev( vector&lt;T&gt; X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_min_max_mean_stddev( Stats, X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_min_max_mean_stddev( fVector&nbsp;h_Stats, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_min_max_mean_stddev( fVector&nbsp;d_Stats, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_min_max_mean_stddev( fVector&nbsp;h_Stats, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_min_max_mean_stddev( h_Stats, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_min_max_mean_stddev( d_Stats, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_min_max_mean_stddev( h_Stats, h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The four basic descriptive statistics functions for a one-dimensional distribution are calculated simultaneously. They are returned in the vector <i>Stats</i>: <br>
Stats[0] = Minimum;<BR>
Stats[1] = Maximum;<BR>
Stats[2] = Mean;<BR>
Stats[3] = Standard Deviation;
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#meanvar">VF_meanvar</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="minReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_minReIm</b></font></td><td width="33%"><font size="+1"><b>VCD_minReIm</b></font></td><td><font size="+1"><b>VCE_minReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the smallest (or most negative) real and imaginary parts occurring in a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_minReIm( cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex&lt;T&gt; vector&lt;complex&lt;T&gt;&gt;::minReIm();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function VCF_minReIm( X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
<BR>Alternative syntax (obsolete, but still supported):<font face="courier new">
<BR>procedure VCF_minReIm( var RetVal:fComplex; X:cfVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_minReIm( fComplex *h_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVCF_minReIm( fComplex *d_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>fComplex VCFcu_minReIm( cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_minReIm( var h_RetVal:fComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVCF_minReIm( d_RetVal:PfComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VCFcu_minReIm( h_X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is separately searched for its smallest real and imaginary parts. These are packed together and either returned as an fComplex (in C/C++) or stored in Min (in Pascal/Delphi):
<BR>Min.Re: smallest real part encountered,
<BR>Min.Im: smallest imaginary part encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td><u>C/C++:</u>
<BR>struct or class instance of type fComplex (dComplex, eComplex, resp.), in which the minima of the real and imaginary parts of X are packed together.
<BR><u>Pascal/Delphi:</u>
<BR>since Pascal does not allow complex return values, the result is stored in the variable Min.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxReIm">VCF_maxReIm</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a>,&nbsp;&nbsp; <a href="#absmin">VCF_absmin</a>,&nbsp;&nbsp; <a href="#absminind">VCF_absminind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="minV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_minV</b></font></td><td width="34%"><font size="+1"><b>VD_minV</b></font></td><td><font size="+1"><b>VE_minV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_minV</b></font></td><td width="17%"><font size="+1"><b>VBI_minV</b></font></td><td width="17%"><font size="+1"><b>VSI_minV</b></font></td><td width="17%"><font size="+1"><b>VLI_minV</b></font></td><td width="17%"><font size="+1"><b>VQI_minV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_minV</b></font></td><td width="17%"><font size="+1"><b>VUB_minV</b></font></td><td width="17%"><font size="+1"><b>VUS_minV</b></font></td><td width="17%"><font size="+1"><b>VUL_minV</b></font></td><td width="17%"><font size="+1"><b>VUQ_minV</b></font></td><td><font size="+1"><b>VUI_minV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compare each element of a vector to the corresponding element of another vector and take the smaller of the two.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_minV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::minV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_minV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_minV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>void VFcu_minV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_minV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_minV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = X<sub>i</sub>,&nbsp;&nbsp;if X<sub>i</sub> &lt;= Y<sub>i</sub>
<BR>Z<sub>i</sub> = Y<sub>i</sub>,&nbsp;&nbsp;if X<sub>i</sub> &gt; Y<sub>i</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxV">VF_maxV</a>,&nbsp;&nbsp; <a href="#minC">VF_minC</a>,&nbsp;&nbsp; <a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="modC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_modC</b></font></td><td width="34%"><font size="+1"><b>VD_modC</b></font></td><td><font size="+1"><b>VE_modC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_modC</b></font></td><td width="17%"><font size="+1"><b>VBI_modC</b></font></td><td width="17%"><font size="+1"><b>VSI_modC</b></font></td><td width="17%"><font size="+1"><b>VLI_modC</b></font></td><td width="17%"><font size="+1"><b>VQI_modC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_modC</b></font></td><td width="17%"><font size="+1"><b>VUB_modC</b></font></td><td width="17%"><font size="+1"><b>VUS_modC</b></font></td><td width="17%"><font size="+1"><b>VUL_modC</b></font></td><td width="17%"><font size="+1"><b>VUQ_modC</b></font></td><td><font size="+1"><b>VUI_modC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Modulus, i.e. the remainder of a division by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_modC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::modC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_modC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVDmath.h&gt;
<BR>int cudaVF_modC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_modC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_modC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VDmath;
<BR>function cudaVF_modC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_modC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VF_modC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> mod C
<BR>Floating-point versions: a constant C = 0.0 leads to all Y<sub>i</sub> being 0.0, independently of the X<sub>i</sub> values (as in the ANSI C math function <I>fmod </I>).
<BR>Integer versions: a constant C = 0 leads to a ZERODIVIDE error (as in the intrinsic &quot;%&quot; operation of ANSI C).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none (also the floating-point versions are treated as basic arithmetic rather than mathematical functions, despite their relation to the math function <I>fmod</I>).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#modV">VF_modV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="modf"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_modf</b></font></td><td width="33%"><font size="+1"><b>VD_modf</b></font></td><td><font size="+1"><b>VE_modf</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Split up into integer and fractional parts.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_modf( fVector&nbsp;IntPart, fVector&nbsp;FracPart, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::modf( vector&lt;T&gt; FracPart, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>These functions are absent. Use VF_intfrac etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions are implemented as alias names for <I><a href="#intfrac">VF_intfrac</a></I> etc., in order to maintain consistency with the ANSI C function name <I>modf</I>. For details, see <I><a href="#intfrac">VF_intfrac</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="modV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_modV</b></font></td><td width="34%"><font size="+1"><b>VD_modV</b></font></td><td><font size="+1"><b>VE_modV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_modV</b></font></td><td width="34%"><font size="+1"><b>VDx_modV</b></font></td><td><font size="+1"><b>VEx_modV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_modV</b></font></td><td width="17%"><font size="+1"><b>VBI_modV</b></font></td><td width="17%"><font size="+1"><b>VSI_modV</b></font></td><td width="17%"><font size="+1"><b>VLI_modV</b></font></td><td width="17%"><font size="+1"><b>VQI_modV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_modV</b></font></td><td width="17%"><font size="+1"><b>VUB_modV</b></font></td><td width="17%"><font size="+1"><b>VUS_modV</b></font></td><td width="17%"><font size="+1"><b>VUL_modV</b></font></td><td width="17%"><font size="+1"><b>VUQ_modV</b></font></td><td><font size="+1"><b>VUI_modV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Modulus, i.e. the remainder of a division of corresponding vector elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_modV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VFx_modV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::modV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::x_modV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_modV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFx_modV( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_modV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVFx_modV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_modV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>void VFcu_modV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFxcu_modV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_modV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_modV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_modV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_modV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFxcu_modV( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = X<sub>i</sub> mod Y<sub>i</sub>
<BR>expanded versions: Z<sub>i</sub> = (A *&nbsp;X<sub>i</sub> + B) mod Y<sub>i</sub>
<BR>Floating-point versions: an argument X<sub>i</sub> = 0.0 leads to Z<sub>i</sub> being 0.0, independently of Y<sub>i</sub> (as in the ANSI C math function <I>fmod</I>).
<BR>Integer versions: an argument X<sub>i</sub> = 0 leads to a ZERODIVIDE error (as in the intrinsic &quot;%&quot; operation of ANSI C).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none (also the floating-point versions are treated as basic arithmetic rather than mathematical functions, despite their relation to the math function <I>fmod</I>).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#modC">VF_modC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="mulC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulC</b></font></td><td width="34%"><font size="+1"><b>VD_mulC</b></font></td><td><font size="+1"><b>VE_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mulC</b></font></td><td width="34%"><font size="+1"><b>VCD_mulC</b></font></td><td><font size="+1"><b>VCE_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mulReC</b></font></td><td width="34%"><font size="+1"><b>VCD_mulReC</b></font></td><td><font size="+1"><b>VCE_mulReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_mulC</b></font></td><td width="34%"><font size="+1"><b>VPD_mulC</b></font></td><td><font size="+1"><b>VPE_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_mulReC</b></font></td><td width="34%"><font size="+1"><b>VPD_mulReC</b></font></td><td><font size="+1"><b>VPE_mulReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_mulC</b></font></td><td width="17%"><font size="+1"><b>VBI_mulC</b></font></td><td width="17%"><font size="+1"><b>VSI_mulC</b></font></td><td width="17%"><font size="+1"><b>VLI_mulC</b></font></td><td width="17%"><font size="+1"><b>VQI_mulC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_mulC</b></font></td><td width="17%"><font size="+1"><b>VUB_mulC</b></font></td><td width="17%"><font size="+1"><b>VUS_mulC</b></font></td><td width="17%"><font size="+1"><b>VUL_mulC</b></font></td><td width="17%"><font size="+1"><b>VUQ_mulC</b></font></td><td><font size="+1"><b>VUI_mulC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Multiply all vector elements by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_mulC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">void VCF_mulC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>void VCF_mulReC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::mulC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::mulC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::mulReC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;CRe&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_mulC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VCF_mulC( Y,&nbsp;X:cfVector; size:UIntSize; C:fComplex&nbsp;);
<BR>procedure VCF_mulReC( Y,&nbsp;X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_mulC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_mulC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_mulC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVCF_mulReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);
<BR>int cusdVCF_mulReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_CRe&nbsp;);
<BR>void VCFcu_mulReC( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_mulC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_mulC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_mulC( h_Y, h_X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>function cudaVCF_mulReC( d_Y, d_X:cfVector; size:UIntSize; CRe:Single&nbsp;);
<BR>function cusdVCF_mulReC( d_Y, d_X:cfVector; size:UIntSize; d_CRe:PSingle&nbsp;);
<BR>procedure VCFcu_mulReC( h_Y, h_X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = C *&nbsp;X<sub>i</sub>
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe by which the complex vector is multiplied.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#divrC">VF_divrC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="mulV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulV</b></font></td><td width="34%"><font size="+1"><b>VD_mulV</b></font></td><td><font size="+1"><b>VE_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mulV</b></font></td><td width="34%"><font size="+1"><b>VCD_mulV</b></font></td><td><font size="+1"><b>VCE_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mulReV</b></font></td><td width="34%"><font size="+1"><b>VCD_mulReV</b></font></td><td><font size="+1"><b>VCE_mulReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mulVconj</b></font></td><td width="34%"><font size="+1"><b>VCD_mulVconj</b></font></td><td><font size="+1"><b>VCE_mulVconj</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFs_mulV</b></font></td><td width="34%"><font size="+1"><b>VDs_mulV</b></font></td><td><font size="+1"><b>VEs_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_mulV</b></font></td><td width="34%"><font size="+1"><b>VDx_mulV</b></font></td><td><font size="+1"><b>VEx_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_mulV</b></font></td><td width="34%"><font size="+1"><b>VCDx_mulV</b></font></td><td><font size="+1"><b>VCEx_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_mulReV</b></font></td><td width="34%"><font size="+1"><b>VCDx_mulReV</b></font></td><td><font size="+1"><b>VCEx_mulReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_mulVconj</b></font></td><td width="34%"><font size="+1"><b>VCDx_mulVconj</b></font></td><td><font size="+1"><b>VCEx_mulVconj</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_mulV</b></font></td><td width="34%"><font size="+1"><b>VPD_mulV</b></font></td><td><font size="+1"><b>VPE_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_mulReV</b></font></td><td width="34%"><font size="+1"><b>VPD_mulReV</b></font></td><td><font size="+1"><b>VPE_mulReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_mulV</b></font></td><td width="17%"><font size="+1"><b>VBI_mulV</b></font></td><td width="17%"><font size="+1"><b>VSI_mulV</b></font></td><td width="17%"><font size="+1"><b>VLI_mulV</b></font></td><td width="17%"><font size="+1"><b>VQI_mulV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_mulV</b></font></td><td width="17%"><font size="+1"><b>VUB_mulV</b></font></td><td width="17%"><font size="+1"><b>VUS_mulV</b></font></td><td width="17%"><font size="+1"><b>VUL_mulV</b></font></td><td width="17%"><font size="+1"><b>VUQ_mulV</b></font></td><td><font size="+1"><b>VUI_mulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Multiply corresponding vector elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_mulV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VFs_mulV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFx_mulV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>void VCF_mulV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCF_mulReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCF_mulVconj( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCFx_mulV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFx_mulReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFx_mulVconj( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::mulV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::s_mulV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;T&gt;::x_mulV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::mulV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::mulReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::mulVconj( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_mulV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_mulReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_mulVconj( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_mulV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFs_mulV( Z, X,&nbsp;Y:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VFx_mulV( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);
<BR>procedure VCF_mulV( Z, X,&nbsp;Y:cfVector; size:UIntSize&nbsp;);
<BR>procedure VCF_mulReV( Z, X:cfVector; Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCF_mulVconj( Z, X,&nbsp;Y:cfVector; size:UIntSize&nbsp;);
<BR>procedure VCFx_mulV( Z, X,&nbsp;Y:cfVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);
<BR>procedure VCFx_mulReV( Z, X:cfVector; Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);
<BR>procedure VCFx_mulVconj( Z, X,&nbsp;Y:cfVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVF_mulV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVFs_mulV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVFs_mulV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>int cudaVFx_mulV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_mulV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int cudaVCF_mulReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>int cudaVCF_mulVconj( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, cfVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>int cudaVCFx_mulReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>int cusdVCFx_mulReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;*d_A, fComplex&nbsp;*d_B&nbsp;);
<BR>int cudaVCFx_mulVconj( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, cfVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>int cusdVCFx_mulVconj( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, cfVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;*d_A, fComplex&nbsp;*d_B&nbsp;);
<BR>void VFcu_mulV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFscu_mulV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFxcu_mulV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>void VCFcu_mulReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);
<BR>void VCFcu_mulVconj( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, cfVector&nbsp;h_Y, ui&nbsp;size&nbsp;);
<BR>void VCFxcu_mulV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, cfVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFxcu_mulReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFxcu_mulVconj( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, cfVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_mulV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFs_mulV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFs_mulV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_mulV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_mulV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVCF_mulReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVCF_mulVconj( d_Z, d_X,&nbsp;d_Y:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVCFx_mulReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;):&nbsp;IntBool;
<BR>function cusdVCFx_mulReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PfComplex&nbsp;):&nbsp;IntBool;
<BR>function cudaVCFx_mulVconj( d_Z, d_X,&nbsp;d_Y:cfVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;):&nbsp;IntBool;
<BR>function cusdVCFx_mulVconj( d_Z, d_X,&nbsp;d_Y:cfVector; size:UIntSize; d_A,&nbsp;d_B:PfComplex&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_mulV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFscu_mulV( h_Z, h_X, h_Y:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VFxcu_mulV( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);
<BR>procedure VCFcu_mulReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCFcu_mulVconj( h_Z, h_X, h_Y:cfVector; size:UIntSize&nbsp;);
<BR>procedure VCFxcu_mulReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);
<BR>procedure VCFxcu_mulVconj( h_Z, h_X, h_Y:cfVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = X<sub>i</sub> *&nbsp;Y<sub>i</sub>
<BR>scaled versions (<i>VFs_</i> etc.): Z<sub>i</sub> = C *&nbsp;(X<sub>i</sub> *&nbsp;Y<sub>i</sub>)
<BR>expanded versions (<i>VFx_</i> etc.): Z<sub>i</sub> = (A *&nbsp;X<sub>i</sub> + B) *&nbsp;Y<sub>i</sub>
<BR>The complex floating-point versions exist in three variants: in the first variant (e.g. <I>VCF_mulV,&nbsp;&nbsp; VCFx_mulV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g. <I>VCF_mulReV</I> - &quot;multiply by a real vector&quot;); in the third variant, finally (e.g. <I>VCF_mulVconj,&nbsp;&nbsp; VCFx_mulVconj</I>), X is multiplied by the complex conjugate of Y instead of Y itself.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a>,&nbsp;&nbsp; <a href="#mulVI">VF_mulVI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="mulVI"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulVI</b></font></td><td width="33%"><font size="+1"><b>VD_mulVI</b></font></td><td><font size="+1"><b>VE_mulVI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulVBI</b></font></td><td width="33%"><font size="+1"><b>VD_mulVBI</b></font></td><td><font size="+1"><b>VE_mulVBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulVSI</b></font></td><td width="33%"><font size="+1"><b>VD_mulVSI</b></font></td><td><font size="+1"><b>VE_mulVSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulVLI</b></font></td><td width="33%"><font size="+1"><b>VD_mulVLI</b></font></td><td><font size="+1"><b>VE_mulVLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulVQI</b></font></td><td width="33%"><font size="+1"><b>VD_mulVQI</b></font></td><td><font size="+1"><b>VE_mulVQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulVU</b></font></td><td width="33%"><font size="+1"><b>VD_mulVU</b></font></td><td><font size="+1"><b>VE_mulVU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulVUB</b></font></td><td width="33%"><font size="+1"><b>VD_mulVUB</b></font></td><td><font size="+1"><b>VE_mulVUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulVUS</b></font></td><td width="33%"><font size="+1"><b>VD_mulVUS</b></font></td><td><font size="+1"><b>VE_mulVUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulVUL</b></font></td><td width="33%"><font size="+1"><b>VD_mulVUL</b></font></td><td><font size="+1"><b>VE_mulVUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulVUQ</b></font></td><td width="33%"><font size="+1"><b>VD_mulVUQ</b></font></td><td><font size="+1"><b>VE_mulVUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulVUI</b></font></td><td width="33%"><font size="+1"><b>VD_mulVUI</b></font></td><td><font size="+1"><b>VE_mulVUI</b></font></td></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Element-wise multiplication of a floating-point vector by an integer vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_mulVI( fVector&nbsp;Z, fVector&nbsp;X, iVector&nbsp;Y,ui&nbsp;size&nbsp;);
<BR>void VF_mulVUB( fVector&nbsp;Z, fVector&nbsp;X, ubVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::mulVI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;int&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::mulVUS( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;unsigned short&gt;&amp;&nbsp;Y,&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_mulVI( Z, X:fVector; Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VF_mulVUL( Z, X:fVector; Y:ulVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_mulVI( fVector&nbsp;d_Z, fVector&nbsp;d_X, iVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVF_mulVUB( fVector&nbsp;d_Z, fVector&nbsp;d_X, ubVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>void VFcu_mulVI( fVector&nbsp;h_Z, fVector&nbsp;h_X, iVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFcu_mulVUB( fVector&nbsp;h_Z, fVector&nbsp;h_X, ubVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_mulVI( d_Z, d_X:fVector; d_Y:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_mulVUL( d_Z, d_X:fVector; d_Y:ulVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_mulVI( h_Z, h_X:fVector; h_Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VFcu_mulVUL( h_Z, h_X:fVector; h_Y:ulVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = X<sub>i</sub> *&nbsp;Y<sub>i</sub>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#divVI">VF_divVI</a>,&nbsp;&nbsp; <a href="#addVI">VF_addVI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="natCubSplineInterpol"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_natCubSplineInterpol</b></font></td><td width="33%"><font size="+1"><b>VD_natCubSplineInterpol</b></font></td><td><font size="+1"><b>VE_natCubSplineInterpol</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Natural cubic-spline interpolation of X-Y-table values</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_natCubSplineInterpol(
 fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;sizex, fVector&nbsp;XTab, fVector&nbsp;YTab, ui&nbsp;sizetab&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::natCubSplineInterpol( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;XTab, const&nbsp;vector&lt;T&gt;&amp;&nbsp;YTab&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_natCubSplineInterpol( Y,&nbsp;X:fVector; sizex:UIntSize; XTab,&nbsp;YTab:fVector; sizetab:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_natCubSplineInterpol( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;sizex, fVector&nbsp;d_XTab, fVector&nbsp;d_YTab, ui&nbsp;sizetab&nbsp;);
<BR>void VFcu_natCubSplineInterpol( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;sizex, fVector&nbsp;h_XTab, fVector&nbsp;h_YTab, ui&nbsp;sizetab&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_natCubSplineInterpol( d_Y, d_X:fVector; sizex:UIntSize; d_XTab,&nbsp;d_YTab:fVector; sizetab:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_natCubSplineInterpol( h_Y, h_X:fVector; sizex:UIntSize; h_XTab,&nbsp;h_YTab:fVector; sizetab:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each of the sizex elements of X, the corresponding element of Y is interpolated from the XTab-YTab value pairs. XTab must be ordered (either ascending or descending). All values of XTab must be distinct; otherwise a division by zero may occur and lead to a program abort. sizetab must be greater than or equal to 3.
<BR>This function calculates the "natural" cubic-spline interpolation. For general cubic-spline interpolation with specified second derivatives of the YTab values with respect to XTab, call <I><a href="#splineinterpol">VF_splineinterpol</a></I>.
<BR>The CUDA version of this function is comparably slow, as it has to use the CPU for the calculation of the derivative table.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (you have to take care yourself that the XTab values are distinct and that the YTab values are not near the limit of overflowing).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#splineinterpol">VF_splineinterpol</a>,&nbsp;&nbsp; <a href="#ratinterpol">VF_ratinterpol</a>,&nbsp;&nbsp; <a href="#polyinterpol">VF_polyinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="neg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_neg</b></font></td><td width="33%"><font size="+1"><b>VD_neg</b></font></td><td><font size="+1"><b>VE_neg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_neg</b></font></td><td width="33%"><font size="+1"><b>VCD_neg</b></font></td><td><font size="+1"><b>VCE_neg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_neg</b></font></td><td width="33%"><font size="+1"><b>VPD_neg</b></font></td><td><font size="+1"><b>VPE_neg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_neg</b></font></td><td width="20%"><font size="+1"><b>VBI_neg</b></font></td><td width="20%"><font size="+1"><b>VSI_neg</b></font></td><td width="20%"><font size="+1"><b>VLI_neg</b></font></td><td><font size="+1"><b>VQI_neg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Negation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_neg( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::neg( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_neg( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_neg( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_neg( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_neg( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_neg( h_Y, h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = - (X<sub>i</sub>)
<BR><I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VI_</I>, and <I>VLI_</I> versions only: the negation of the most negative number possible (-128 for byte/ByteInt, -32768 for short/SmallInt, -2147483648 for long/LongInt) is again the same - negative! - number. This is due to the implicit modulo-2<sup>n</sup> arithmetics, where the overflowing byte/ByteInt, +128, is stored as -128, the overflowing short/SmallInt, +32768, is stored as -32768, and the overflowing long/LongInt, +2147483648, is stored as -2147483648.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>By analogy with <I><a href="#abs">VF_abs</a></I>, the floating-point versions are treated as math functions. Therefore, they have a return value which, since no errors can occur, is always FALSE (0). The integer versions have no return value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#abs">VF_abs</a>,&nbsp;&nbsp; <a href="#conj">VCF_conj</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="nfree"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_nfree</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>De-allocate memory occupied by one or more vectors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_nfree( unsigned numfree, ...&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>This function is absent.</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>void cudaV_nfree( unsigned numfree, ...&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The parameter numfree &quot;tells&quot; the function how many vectors it has to free. These vectors follow in the parameter list after numfree. De-allocation of vectors not allocated by one of the functions of the <I><a href="#vector">VF_vector</a></I> or <I><a href="#vector0">VF_vector0</a></I> family is discouraged, especially in Windows programs.
<BR>Pascal/Delphi: since a variable number of parameters is not supported in Pascal language, this function is missing.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">V_nfree( 3, X, Y, Z&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#free">V_free</a>,&nbsp;&nbsp; <a href="#freeAll">V_freeAll</a>,&nbsp;&nbsp; <a href="#vector">VF_vector</a>,&nbsp;&nbsp; <a href="#vector0">VF_vector0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="noise"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_noise</b></font></td><td width="33%"><font size="+1"><b>VD_noise</b></font></td><td><font size="+1"><b>VE_noise</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize a vector with &quot;white&quot; noise</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>long VF_noise( fVector&nbsp;X, ui&nbsp;size, long seed, float&nbsp;Amp&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>long vector&lt;T&gt;::noise( long seed, const&nbsp;T&amp;&nbsp;Amp&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_noise( X:fVector; size:UIntSize; Seed:LongInt; Amp:Single&nbsp;):&nbsp;LongInt;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_noise( fVector&nbsp;X, ui&nbsp;size, long seed, float&nbsp;Amp&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_noise( X:fVector; size:UIntSize; Seed:LongInt; Amp:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>White noise is generated with the amplitude Amp, i.e., the output values are between -Amp/2 and +Amp/2 (both extrema included). "seed" may be chosen completely arbitrary. Successive calls with the same seed yield identical results; for different values of seed, the obtained results are uncorrelated.
<P>Internally, these functions employ a 32-bit integer random number generator by H.W.Lewis, with additional steps (so-called &quot;Bays-Durham shuffle&quot;) to break sequential correlations. 
<BR>A 32-bit integer suitable for use as a new seed value for another call is returned. That other call would, however, not simply continue the series, as a new "state" of the random-number generator needs to be built up. If you wish to be able to break off and continue the series in multiple sequential function calls, use <a href="#noiseLC">VF_noiseLC</a> instead.
<BR>Because the random numbers are only 32-bit, there is some granularity in the VD_ and VE_ versions. If higher resolution is desired, use <a href="#random">VD_random</a> instead.
<P>A long value is returned which may be used as new seed for subsequent calls. Only the CUDA versions of this function do not return a new seed value, but the usual CUDA error flag.
<BR>There is no <i>VFcu_</i> version of this function, as the random numbers are generated on the CPU anyway.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>last 32-bit random number internally generated; may be used as new seed value for future calls.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I>rand,&nbsp;&nbsp; random,&nbsp;&nbsp; <a href="#random">VF_random</a>,&nbsp;&nbsp; <a href="#noiseLC">VF_noiseLC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="noiseLC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_noiseLC</b></font></td><td width="33%"><font size="+1"><b>VD_noiseLC</b></font></td><td><font size="+1"><b>VE_noiseLC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize a vector with &quot;white&quot; noiseLC</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_noiseLC( fVector&nbsp;X, ui&nbsp;size, long&nbsp;seed, float&nbsp;Amp,&nbsp;V_RANDOMLCSTATE&nbsp;*state&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::noiseLC( long seed, const&nbsp;T&amp;&nbsp;Amp, &nbsp;V_RANDOMLCSTATE&nbsp;*state);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_noiseLC( X:fVector; size:UIntSize; Seed:LongInt; Amp:Single;&nbsp;state:PV_RANDOMLCSTATE&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_noiseLC( fVector&nbsp;X, ui&nbsp;size, long seed, float&nbsp;Amp,&nbsp;V_RANDOMLCSTATE&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_noiseLC( X:fVector; size:UIntSize; Seed:LongInt; Amp:Single;&nbsp;state:PV_RANDOMLCSTATE&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>White noise is generated with the amplitude Amp, i.e., the output values are between -Amp/2 and +Amp/2 (both extrema included). "seed" may be completely arbitrary. A non-zero value of <i>seed</i> leads to the start of a new series, whereas <i>seed</i>=0 leads to the series whose state is stored in the variable <i>state</i> to be continued.
<P>Internally, these functions employ a linear-congruential (hence the name component "LC") 32-bit integer random number generator by H.W.Lewis, with additional steps (so-called &quot;Bays-Durham shuffle&quot;) to break sequential correlations. 
<BR>A simplified form of this function is available as <a href="#noise">VF_noise</a>.
<BR>Because the random numbers are only 32-bit, there is some granularity in the VD_ and VE_ versions. If higher resolution is desired, use <a href="#randomLC">VD_randomLC</a> instead.
<P>There is no <i>VFcu_</i> version of this function, as the random numbers are generated on the CPU anyway.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I>rand,&nbsp;&nbsp; random,&nbsp;&nbsp; <a href="#randomLC">VF_randomLC</a>,&nbsp;&nbsp; <a href="#noise">VF_noise</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="norm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_norm</b></font></td><td width="33%"><font size="+1"><b>VCD_norm</b></font></td><td><font size="+1"><b>VCE_norm</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_normtoC</b></font></td><td width="33%"><font size="+1"><b>VCD_normtoC</b></font></td><td><font size="+1"><b>VCE_normtoC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_norm</b></font></td><td width="33%"><font size="+1"><b>VPD_norm</b></font></td><td><font size="+1"><b>VPE_norm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Norm (square of the magnitude) of complex numbers.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd&gt;
<BR>void VCF_norm( fVector&nbsp;Norm, cfVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>void VPF_norm( fVector&nbsp;Norm, pfVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>void VCF_normtoC( cfVector&nbsp;Norm, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::norm( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::normtoC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd, VPFstd;
<BR>procedure VCF_norm( Norm:fVector; X:cfVector; size:UIntSize&nbsp;);
<BR>procedure VPF_norm( Norm:fVector; X:pfVector; size:UIntSize&nbsp;);
<BR>procedure VCF_normtoC( Norm, X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVCF_norm( fVector&nbsp;d_Norm, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVPF_norm( fVector&nbsp;d_Norm, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVCF_normtoC( cfVector&nbsp;d_Norm, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VCFcu_norm( fVector&nbsp;h_Norm, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>void VPFcu_norm( fVector&nbsp;h_Norm, pfVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>void VCFcu_normtoC( cfVector&nbsp;h_Norm, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_norm( d_Norm:fVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVPF_norm( d_Norm:fVector; d_X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVCF_normtoC( d_Norm, d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VCFcu_norm( h_Norm:fVector; h_X:cfVector; size:UIntSize&nbsp;);
<BR>procedure VPFcu_norm( h_Norm:fVector; h_X:pfVector; size:UIntSize&nbsp;);
<BR>procedure VCFcu_normtoC( h_Norm, h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><i>VCF_norm</i> is identical to <I><a href="#CtoNorm">VF_CtoNorm</a></I>, and <i>VPF_norm</i> is identical to <I><a href="#PtoNorm">VF_PtoNorm</a></I>. See those functions for details.
<BR><I>VCF_normtoC</I> calculates the norm of a cartesian complex vector and stores it as a complex vector (with all imaginary parts equal to 0).</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="not"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_not</b></font></td><td width="17%"><font size="+1"><b>VBI_not</b></font></td><td width="17%"><font size="+1"><b>VSI_not</b></font></td><td width="17%"><font size="+1"><b>VLI_not</b></font></td><td width="17%"><font size="+1"><b>VQI_not</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_not</b></font></td><td width="17%"><font size="+1"><b>VUB_not</b></font></td><td width="17%"><font size="+1"><b>VUS_not</b></font></td><td width="17%"><font size="+1"><b>VUL_not</b></font></td><td width="17%"><font size="+1"><b>VUQ_not</b></font></td><td><font size="+1"><b>VUI_not</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Bit-wise complement</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_not( iVector&nbsp;Y, iVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::not( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_not( Y,&nbsp;X:iVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVImath.h&gt;
<BR>int cudaVI_not( iVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VIcu_not( iVector&nbsp;h_Y, iVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>function cudaVI_not( d_Y, d_X:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VIcu_not( h_Y, h_X:iVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = ~(X<sub>i</sub>)
<BR>Each single bit of the element X<sub>i</sub> is inverted (i.e., it is 0 in Y<sub>i</sub>, if it was 1 in X<sub>i</sub>, and vice versa).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#and">VI_and</a>,&nbsp;&nbsp; <a href="#or">VI_or</a>,&nbsp;&nbsp; <a href="#neg">VI_neg</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="noteError"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_noteError</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct and print an error message</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_noteError( char *fname, unsigned why&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_noteError( fname:PChar; why:UInt&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>In case of an error, the math functions of <I>VectorLib</I> invoke the following steps:
<BR><u>C/C++:</u> First call <I>_matherr</I> (or <I>_matherrl</I>), then inspect the return value of <I>_matherr</I> (or <I>_matherrl</I>) and call <I>V_noteError</I> in case this return value was 0.
<P><u>Pascal/Delphi:</u> Call <I>V_noteError</I> if <I><a href="#setFPErrorHandling">V_FPErrorHandlingMode</a></I> contains fpErrorNote for the type of error that occurred. <I>V_noteError</I> then constructs the appropriate error message and passes it to <I><a href="#printErrorMsg">V_printErrorMsg</a></I>, which is the function in charge of actually printing the error message.
<P>By default, output is directed to the screen. This may be changed by a call to <I><a href="#setErrorEventFile">V_setErrorEventFile</a></I> (see <a href="HANDBOOK.HTM#chap5_3">chapter&nbsp;5.3</a>).
<P>&quot;fname&quot; is the name of the &quot;complaining&quot; function, and &quot;why&quot; specifies the reason for the complaint.
<BR><u>C/C++: </u>see the description of <I>_matherr</I> in your compiler's documentation for error codes.
<BR>How to call <I>V_noteError</I> from a user-defined <I>_matherr</I> function is described in <a href="HANDBOOK.HTM#chap5_3">chapter&nbsp;5.3.</a>.
<P><u>Pascal/Delphi:</u> The parameter &quot;why&quot; may take on the following values:
<BR>1 for DOMAIN errors
<BR>2 for SING errors
<BR>3 for OVERFLOW errors
<BR>4 for UNDERFLOW errors
<BR>5 for TLOSS errors
<P>This function will not be included in versions of <I>OptiVec</I> for compilers that do already offer the possibility of printing error messages simultaneously to the screen and to an event file.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setErrorEventFile">V_setErrorEventFile</a>,&nbsp;&nbsp; <a href="#printErrorMsg">V_printErrorMsg</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="nread"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nread</b></font></td><td width="34%"><font size="+1"><b>VD_nread</b></font></td><td><font size="+1"><b>VE_nread</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_nread</b></font></td><td width="34%"><font size="+1"><b>VCD_nread</b></font></td><td><font size="+1"><b>VCE_nread</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_nread</b></font></td><td width="34%"><font size="+1"><b>VPD_nread</b></font></td><td><font size="+1"><b>VPE_nread</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_nread</b></font></td><td width="17%"><font size="+1"><b>VBI_nread</b></font></td><td width="17%"><font size="+1"><b>VSI_nread</b></font></td><td width="17%"><font size="+1"><b>VLI_nread</b></font></td><td width="17%"><font size="+1"><b>VQI_nread</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_nread</b></font></td><td width="17%"><font size="+1"><b>VUB_nread</b></font></td><td width="17%"><font size="+1"><b>VUS_nread</b></font></td><td width="17%"><font size="+1"><b>VUL_nread</b></font></td><td width="17%"><font size="+1"><b>VUQ_nread</b></font></td><td><font size="+1"><b>VUI_nread</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Read the columns of a table from a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_nread( unsigned n, ui&nbsp;size, FILE *stream, ...&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_nread( VecList:^fVector; n:Word; size:UIntSize; var stream:Text&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description C/C++</td><td><i>n</i> columns of a table are read into the vectors passed to <I>VF_nread</I>. The number of lines is specified as the number of elements of each vector, which is <i>size</i>.
<P>The entries of each line should be separated by spaces (' ') or tab characters ('\t').
<P>Each line must be terminated by a line-feed character ('\n'). The length of the lines is limited according the following rules:
<BR>- Either all lines have the same length. In this case, the length is determined automatically and might in principle be as large as 65535 characters.
<BR>- Or the maximum length is given by the number <i>n</i> of vectors to be read and by the data type:<br>&nbsp;
<table border width="100%">
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VF_</I></td><td>&nbsp;24*n</td></tr></table></td>
<td><table width="100%"><tr><td width="20%"><I>VBI_,&nbsp;&nbsp; VUB_</I></td><td>13*n</td></tr></table></td></tr>
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VD_</I></td><td>&nbsp;32*n</td></tr></table></td>
<td><table width="100%"><tr><td width="20%"><I>VSI_,&nbsp;&nbsp; VUS_</I></td><td>21*n</td></tr></table></td></tr>
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VE_</I></td><td>&nbsp;40*n</td></tr></table></td>
<td><table width="100%"><tr><td width="20%"><I>VLI_,&nbsp;&nbsp; VUL_</I></td><td>37*n</td></tr></table></td></tr>
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VCF_,&nbsp;&nbsp; VPF_</I></td><td>&nbsp;48*n</td></tr></table></td>
<td><table width="100%"><tr><td width="20%"><I>VQI_,&nbsp;&nbsp; VUQ_</I></td><td>32*n</td></tr></table></td></tr>
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VCD_,&nbsp;&nbsp; VPD_</I></td><td>&nbsp;64*n</td></tr></table></td>
<td><table width="100%"><tr valign="top"><td width="20%"><I>VI_,&nbsp;&nbsp; VU_</I></td><td>as <I>VLI_,&nbsp;&nbsp; VUL_</I></td></tr></table></td></tr>
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VCE_,&nbsp;&nbsp; VPE_</I></td><td>&nbsp;80*n</td></tr></table></td><td>&nbsp;</TD></tr></table>
<P>It is possible to read fewer vectors than there are columns in a table. In this case, the trailing columns are neglected. If, however, you try to read more vectors than there are columns, the result is undefined and might lead to an error.
<P>Complex versions (both cartesian and polar):
<BR>Real und imaginary (or Mag and Arg) parts may, but need not, be enclosed in braces { }. However, you must be consequent: Either all or no element may be written with braces.
<P>Whole-number versions except <I>VQI_nread</I>:
<BR>By default, the numbers to be read are interpreted as decimal numbers. You may use <I><a href="#setRadix">V_setRadix</a></I> to define any radix between 2 and 36.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">VF_nread( 3, 100, DataFile, X, Y, Z&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Description Pascal/Delphi</td><td>n columns of a table are read into the vectors passed as the list VecList to <I>VF_nread</I>. The number of lines is specified as the number of elements of each vector, which is size.
<P>The entries of each line should be separated by spaces (' ') or tab characters (#9). Other separators are not allowed. Each line must be terminated by a line-feed character (#13).
<P>It is possible to read fewer vectors than there are columns in a table. In this case, the trailing columns are neglected. If, however, you try to read more vectors than there are columns, the result is undefined and might lead to an error.
<P>Complex versions (both cartesian and polar):
<BR>Real und imaginary (or Mag and Arg) parts may (but need not) be enclosed in braces { }. However, you must be consequent: Either all or no element may be written with braces.
<P>Whereas the C version of these functions follows the conventions of the C functions <I>strtod,&nbsp;&nbsp; strtol</I>, etc., the Pascal version has to follow the rules applying to the Pascal function <I>Read</I>. This makes the Pascal version much less flexible than the C version:
<BR>- no separation characters allowed other than ' ' and #9,
<BR>- no automatic truncation of overflowing numbers,
<BR>- no function <I><a href="#setRadix">V_setRadix</a></I></td></tr>
<tr valign="TOP">
<td>Example Pascal/Delphi</td><td><font face="courier new">var MyFile: Text;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;X, Y1, Y2: fVector;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VList: array[0..2] of fVector;
<BR>begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;X := <a href="#vector">VF_vector</a>( 100&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Y1 := VF_vector( 100&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Y2 := VF_vector( 100&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VList[0] := X; VList[1] := Y1; VList[2] := Y2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Assign( MyFile, 'Myfile.DAT'&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Reset( MyFile&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VF_nread( @VList, 3, 100, MyFile&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;...
<BR>end;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td><u>C/C++:</u>
<BR>Real, complex and quad versions:
<BR>Overflowing numbers are silently truncated to &#177;HUGE_VAL.
<BR>Whole-number versions except <I>VQI_nread</I>:
<BR>As long as the numbers can be represented as long or unsigned long, overflowing bits are ignored in the 16-bit versions.
<BR>Numbers beyond the long range yield -1 (signed types) or +HUGE_VAL (unsigned types).
<BR><u>Pascal/Delphi:</u>
<BR>Overflowing numbers or numbers otherwise not conforming to the format requirements lead to an I/O error.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#nwrite">VF_nwrite</a>,&nbsp;&nbsp; <a href="#read">VF_read</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; <a href="#recall">VF_recall</a></I>, strtod,&nbsp;&nbsp;strtol (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="nwrite"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nwrite</b></font></td><td width="34%"><font size="+1"><b>VD_nwrite</b></font></td><td><font size="+1"><b>VE_nwrite</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_nwrite</b></font></td><td width="34%"><font size="+1"><b>VCD_nwrite</b></font></td><td><font size="+1"><b>VCE_nwrite</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_nwrite</b></font></td><td width="34%"><font size="+1"><b>VPD_nwrite</b></font></td><td><font size="+1"><b>VPE_nwrite</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_nwrite</b></font></td><td width="17%"><font size="+1"><b>VBI_nwrite</b></font></td><td width="17%"><font size="+1"><b>VSI_nwrite</b></font></td><td width="17%"><font size="+1"><b>VLI_nwrite</b></font></td><td width="17%"><font size="+1"><b>VQI_nwrite</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_nwrite</b></font></td><td width="17%"><font size="+1"><b>VUB_nwrite</b></font></td><td width="17%"><font size="+1"><b>VUS_nwrite</b></font></td><td width="17%"><font size="+1"><b>VUL_nwrite</b></font></td><td width="17%"><font size="+1"><b>VUQ_nwrite</b></font></td><td><font size="+1"><b>VUI_nwrite</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Write vectors as the columns of a table into a stream.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_nwrite( FILE *stream, unsigned n, ui&nbsp;size, ...&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_nwrite( var stream:Text; VecList:^fVector; n:UInt; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description C/C++</td><td>n vectors are written in ASCII format as the columns of a table into stream. The number of lines is given by the number of elements of each vector: size.
<P>The default format and separation may be changed using <I><a href="#setWriteFormat">VF_setWriteFormat</a></I> and <I><a href="#setNWriteSeparate">VF_setNWriteSeparate</a></I>, respectively.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">VF_nwrite( DataFile, 3, 100, X, Y, Z&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;generates a table with 3 columns and 100 lines;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the columns are given by X, Y and Z. */</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>n vectors, passed as the list VecList, are written in ASCII format as the columns of a table into stream. The number of lines is given by the number of elements of each vector: size.
<P>The separation character(s) between columns may be changed using <I><a href="#setNWriteSeparate">VF_setNWriteSeparate</a></I>. By default, it is a tab character (#9).
<P>Please note that the Pascal version of these functions does not allow a free definition of the output format. Therefore, the function <I><a href="#setWriteFormat">VF_setWriteFormat</a></I> does not exist in the Pascal/Delphi version.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#nread">VF_nread</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; <a href="#recall">VF_recall</a>,&nbsp;&nbsp; fprintf</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="OD"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_OD</b></font></td><td width="33%"><font size="+1"><b>VD_OD</b></font></td><td><font size="+1"><b>VE_OD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VU_ODtoD</b></font></td><td><font size="+1"><b>VU_ODtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUB_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VUB_ODtoD</b></font></td><td><font size="+1"><b>VUB_ODtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUS_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VUS_ODtoD</b></font></td><td><font size="+1"><b>VUS_ODtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VUL_ODtoD</b></font></td><td><font size="+1"><b>VUL_ODtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUQ_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VUQ_ODtoD</b></font></td><td><font size="+1"><b>VUQ_ODtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUI_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VUI_ODtoD</b></font></td><td><font size="+1"><b>VUI_ODtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VQI_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VQI_ODtoD</b></font></td><td><font size="+1"><b>VQI_ODtoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Optical Density</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_OD( fVector&nbsp;OD, fVector&nbsp;X, fVector&nbsp;X0, ui&nbsp;size&nbsp;);
<BR>int VUS_ODtoF( fVector&nbsp;OD, usVector&nbsp;X, usVector&nbsp;X0, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::OD( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X0&nbsp;);
<BR>int vector&lt;flot&gt;::ODtoF( const&nbsp;vector&lt;unsigned&gt;&amp;&nbsp;X, const&nbsp;vector&lt;unsigned&gt;&amp;&nbsp;X0&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_OD( OD, X, X0:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VUS_ODtoF( OD:fVector; X, X0:usVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_OD( fVector&nbsp;d_OD, fVector&nbsp;d_X, fVector&nbsp;d_X0, ui&nbsp;size&nbsp;);
<BR>int cudaVUS_ODtoF( fVector&nbsp;d_OD, usVector&nbsp;d_X, usVector&nbsp;d_X0, ui&nbsp;size&nbsp;);
<BR>int VFcu_OD( fVector&nbsp;h_OD, fVector&nbsp;h_X, fVector&nbsp;h_X0, ui&nbsp;size&nbsp;);
<BR>int VUScu_ODtoF( fVector&nbsp;h_OD, usVector&nbsp;h_X, usVector&nbsp;h_X0, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_OD( d_OD, d_X, d_X0:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVUS_ODtoF( d_OD:fVector; d_X,&nbsp;d_X0:usVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_OD( h_OD, h_X, h_X0:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VUScu_ODtoF( h_OD:fVector; h_X,&nbsp;h_X0:usVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>OD<sub>i</sub> = log10( X0<sub>i</sub>/X<sub>i</sub>&nbsp;) for (X0<sub>i</sub> &gt;= ODThresh0 &amp;&nbsp;X<sub>i</sub> &gt;= ODThresh),
<BR>OD<sub>i</sub> = 0.0 otherwise
<BR>The &quot;optical density&quot; is calculated for positive, non-zero input numbers. By default, ODThresh and ODThresh0 are 0.001 for the versions with floating-point input vectors (<I>VF_OD,&nbsp;&nbsp; VD_OD</I>, and <I>VE_OD</I>), and 1 for the versions with unsigned-integer input vectors.
<BR>The typical application of these functions would be an absorption measurement with a spectrometer, where each element of X corresponds to the light intensity at one specific wavelength, transmitted through the sample, and each element of X0 corresponds to the light intensity measured through air or through a reference sample. Normally, the intensity data will have been digitized with 12-bit or 16-bit precision. In this case, <I>VUS_ODtoF</I> or <I>VUS_ODtoD</I> will be the appropriate functions. For the rare cases of 8-bit, 32-bit, or even 64-bit digitization, use the <I>VUB_</I>, <I>VUL_</I> or <I>VUQ_</I> versions.
<BR>You might wish to accumulate several measurements before calculating the OD. For example, repeated measurements in a usVector&nbsp;may be accumulated into a ulVector&nbsp;by <I><a href="#accV">VUL_accVUS</a></I>, before the OD is calculated by <I>VUL_ODtoD</I>. Similarly, you might accumulate 32-bit data into a uqVector&nbsp;by <I><a href="#accV">VUQ_accVUL</a></I> and call then, e.g., <I>VUQ_ODtoD</I>.
<P>In order to cut off experimental noise, the input-number threshold below which the OD is corrected to 0.0 may be set to arbitrary positive values by <I><a href="#setODThresh">VF_setODThresh</a>,&nbsp;&nbsp; <a href="#setODThresh">VUS_setODThresh</a></I>, etc.
<P>If background values have to be taken into account, please use the functions of the <I><a href="#ODwDark">VF_ODwDark</a></I> family.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ODwDark">VF_ODwDark</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ODwDark"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ODwDark</b></font></td><td width="33%"><font size="+1"><b>VD_ODwDark</b></font></td><td><font size="+1"><b>VE_ODwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VU_ODtoDwDark</b></font></td><td><font size="+1"><b>VU_ODtoEwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUB_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VUB_ODtoDwDark</b></font></td><td><font size="+1"><b>VUB_ODtoEwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUS_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VUS_ODtoDwDark</b></font></td><td><font size="+1"><b>VUS_ODtoEwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VUL_ODtoDwDark</b></font></td><td><font size="+1"><b>VUL_ODtoEwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUQ_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VUQ_ODtoDwDark</b></font></td><td><font size="+1"><b>VUQ_ODtoEwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUI_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VUI_ODtoDwDark</b></font></td><td><font size="+1"><b>VUI_ODtoEwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VQI_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VQI_ODtoDwDark</b></font></td><td><font size="+1"><b>VQI_ODtoEwDark</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Optical Density with background subtraction</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ODwDark( fVector&nbsp;OD, fVector&nbsp;X, fVector&nbsp;XDark, fVector&nbsp;X0, fVector&nbsp;X0Dark, ui&nbsp;size&nbsp;);
<BR>int VUS_ODtoFwDark( fVector&nbsp;OD, usVector&nbsp;X, usVector&nbsp;XDark, usVector&nbsp;X0, usVector&nbsp;X0Dark, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ODwDark( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;XDark, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X0, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X0Dark&nbsp;);
<BR>int vector&lt;float&gt;::ODtoFwDark( const&nbsp;vector&lt;unsigned&gt;&amp;&nbsp;X, const&nbsp;vector&lt;unsigned&gt;&amp;&nbsp;XDark, const&nbsp;vector&lt;unsigned&gt;&amp;&nbsp;X0, const&nbsp;vector&lt;unsigned&gt;&amp;&nbsp;X0Dark&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_ODwDark( OD, X, XDark, X0, X0Dark:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VUS_ODtoFwDark( OD:fVector; X, XDark, X0, X0Dark:usVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_ODwDark( fVector&nbsp;d_OD, fVector&nbsp;d_X, fVector&nbsp;d_XDark, fVector&nbsp;d_X0, fVector&nbsp;d_X0Dark, ui&nbsp;size&nbsp;);
<BR>int cudaVUS_ODtoFwDark( fVector&nbsp;d_OD, usVector&nbsp;d_X, usVector&nbsp;d_XDark, usVector&nbsp;d_X0, usVector&nbsp;d_X0Dark, ui&nbsp;size&nbsp;);
<BR>int VFcu_ODwDark( fVector&nbsp;h_OD, fVector&nbsp;h_X, fVector&nbsp;h_XDark, fVector&nbsp;h_X0, fVector&nbsp;h_X0Dark, ui&nbsp;size&nbsp;);
<BR>int VUScu_ODtoFwDark( fVector&nbsp;h_OD, usVector&nbsp;h_X, usVector&nbsp;h_XDark, usVector&nbsp;h_X0, usVector&nbsp;h_X0Dark, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_ODwDark( d_OD,&nbsp;d_X,&nbsp;d_ XDark,&nbsp;d_X0,&nbsp;d_X0Dark:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVUS_ODtoFwDark( d_OD:fVector; d_X,&nbsp;d_XDark,&nbsp;d_X0,&nbsp;d_X0Dark:usVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_ODwDark( h_OD,&nbsp;h_X,&nbsp;h_XDark,&nbsp;h_X0,&nbsp;h_X0Dark:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VUScu_ODtoFwDark( h_OD:fVector; h_X,&nbsp;h_XDark,&nbsp;h_X0,&nbsp;h_X0Dark:usVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>xx<sub>i</sub> = X<sub>i</sub> - X<sub>i</sub>Dark
<BR>x0<sub>i</sub> = X0<sub>i</sub> - X0<sub>i</sub>Dark
<BR>OD<sub>i</sub> = log10( x0<sub>i</sub>/xx<sub>i</sub>&nbsp;),&nbsp;&nbsp;(x0<sub>i</sub> &gt;= ODThresh0 &amp;&nbsp;xx<sub>i</sub> &gt;= ODThresh),
<BR>OD<sub>i</sub> = 0.0&nbsp;&nbsp;otherwise
<P>Dark currents XDark, X0Dark are subtracted from measured intensity data X, X0. The optical density is calculated for the resulting corrected data. If these happen to become negative or at least smaller than the thresholds ODThresh, ODThresh0, the OD is set to 0.0.
<P>In order to cut off experimental noise, these thresholds may be set to arbitrary positive values by <I><a href="#setODThresh">VF_setODThresh</a>,&nbsp;&nbsp; <a href="#setODThresh">VU_setODThresh</a></I>, etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#OD">VF_OD</a>,&nbsp;&nbsp; <a href="#setODThresh">VF_setODThresh</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="or"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_or</b></font></td><td width="17%"><font size="+1"><b>VBI_or</b></font></td><td width="17%"><font size="+1"><b>VSI_or</b></font></td><td width="17%"><font size="+1"><b>VLI_or</b></font></td><td width="17%"><font size="+1"><b>VQI_or</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_or</b></font></td><td width="17%"><font size="+1"><b>VUB_or</b></font></td><td width="17%"><font size="+1"><b>VUS_or</b></font></td><td width="17%"><font size="+1"><b>VUL_or</b></font></td><td width="17%"><font size="+1"><b>VUQ_or</b></font></td><td><font size="+1"><b>VUI_or</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Bit-wise &quot;OR&quot; operation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_or( iVector&nbsp;Y, iVector&nbsp;X, ui&nbsp;size, int&nbsp;C);
<BR>void VUL_or( ulVector&nbsp;Y, ulVector&nbsp;X, ui&nbsp;size, unsigned long C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::or( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_or( Y,&nbsp;X:iVector; size:UIntSize; C:Integer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVImath.h&gt;
<BR>int cudaVI_or( iVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size, int&nbsp;C&nbsp;);
<BR>int cusdVI_or( iVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size, int&nbsp;*d_C&nbsp;);
<BR>void VIcu_or( iVector&nbsp;h_Y, iVector&nbsp;h_X, ui&nbsp;size, int&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>function cudaVI_or( d_Y, d_X:iVector; size:UIntSize; C:Integer&nbsp;):&nbsp;IntBool;
<BR>function cusdVI_or( d_Y, d_X:iVector; size:UIntSize; d_C:PInteger&nbsp;):&nbsp;IntBool;
<BR>procedure VIcu_or( h_Y, h_X:iVector; size:UIntSize; C:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = (X<sub>i</sub>) | C
<BR>The bit-wise &quot;inclusive OR&quot; operation is performed on each element X<sub>i</sub> with the bit-mask given by C. A bit is 1 in Y<sub>i</sub>, if it was not simultaneously 0 in X<sub>i</sub> and in C, i.e., if it was 1 at least in one of them.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#not">VI_not</a>,&nbsp;&nbsp; <a href="#and">VI_and</a>,&nbsp;&nbsp; <a href="#xor">VI_xor</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Parzen"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Parzen</b></font></td><td width="33%"><font size="+1"><b>VD_Parzen</b></font></td><td><font size="+1"><b>VE_Parzen</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Parzen&quot; window for spectral analyses</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_Parzen( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::Parzen();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_Parzen( X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_Parzen( fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_Parzen( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_Parzen( d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_Parzen( h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = 1 - |(i - 0.5*(size - 1)) / 0.5*(size + 1)|</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Welch">VF_Welch</a>,&nbsp;&nbsp; <a href="#Hann">VF_Hann</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Pelement"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Pelement</b></font></td><td width="34%"><font size="+1"><b>VD_Pelement</b></font></td><td><font size="+1"><b>VE_Pelement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_Pelement</b></font></td><td width="34%"><font size="+1"><b>VCD_Pelement</b></font></td><td><font size="+1"><b>VCE_Pelement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_Pelement</b></font></td><td width="17%"><font size="+1"><b>VBI_Pelement</b></font></td><td width="17%"><font size="+1"><b>VSI_Pelement</b></font></td><td width="17%"><font size="+1"><b>VLI_Pelement</b></font></td><td width="17%"><font size="+1"><b>VQI_Pelement</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_Pelement</b></font></td><td width="17%"><font size="+1"><b>VUB_Pelement</b></font></td><td width="17%"><font size="+1"><b>VUS_Pelement</b></font></td><td width="17%"><font size="+1"><b>VUL_Pelement</b></font></td><td width="17%"><font size="+1"><b>VUQ_Pelement</b></font></td><td><font size="+1"><b>VUI_Pelement</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Pointer to a vector element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>(float *) VF_Pelement( fVector&nbsp;X, ui&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T *&nbsp;vector&lt;T&gt;::Pelement( ui&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_Pelement( X:fVector; pos:UIntSize&nbsp;):&nbsp;PSingle;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>(float *) cudaVF_Pelement( fVector&nbsp;d_X, ui&nbsp;pos&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_Pelement( d_X:fVector; pos:UIntSize&nbsp;):&nbsp;PSingle;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function returns the pointer X+pos = &amp;( X[pos]&nbsp;).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>C/C++:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X+pos
<BR>Pascal/Delphi: @( X[pos]&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#element">VF_element</a></I>, &nbsp;&nbsp;<I><a href="#setElement">VF_setElement</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PDtoPF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_PDtoPF</b></font></td><td><font size="+1"><b>V_PDtoPE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_PEtoPF</b></font></td><td><font size="+1"><b>V_PEtoPD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_PFtoPD</b></font></td><td><font size="+1"><b>V_PFtoPE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type conversions. See <I><a href="#FtoD">V_FtoD</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pinnedFree"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>cudaV_pinnedFree</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td><i>cudaOptiVec</i> only: De-allocate a single pinned host-memory vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>int cudaV_pinnedFree( void *h_X&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function cudaV_pinnedFree( h_X:Pointer&nbsp;):&nbsp;IntBool;
</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The pinned host-memory vector X is freed (i.e. de-allocated). This function needs the host address (not the device address!) of the pinned vector as an argument. To free several pinned vectors simultaneously, use <I><a href="#pinnedNfree">cudaV_pinnedNfree</a></I> (C/C++ only).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Trying to free a pinned vector that has already been freed, or that has never been allocated memory, leads to a warning message &quot;Cannot free non-existent vector&quot;. Program execution is continued without freeing anything in this case.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0) in case of success, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a>, &nbsp;&nbsp;<I><a href="#pinnedNfree">cudaV_pinnedNfree</a>,&nbsp;&nbsp; <a href="#pinnedFreeAll">cudaV_pinnedFreeAll</a>,&nbsp;&nbsp; <a href="#pinnedVector">cudaVF_pinnedVector</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pinnedFreeAll"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>cudaV_pinnedFreeAll</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td><i>cudaOptiVec</i> only: De-allocate all pinned host-memory vectors (and matrices)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>int cudaV_pinnedFreeAll( void&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function cudaV_pinnedFreeAll:&nbsp;IntBool;</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>All pinned host-memory vectors and matrices previously allocated by one of the functions of the <I><a href="#pinnedVector">cudaVF_pinnedVector</a></I>,&nbsp;&nbsp; or <I><a href="MATRIX.HTM#matrix">cudaMF_pinnedMatrix</a></I> families are freed.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), in case of success, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a>, &nbsp;&nbsp;<I><a href="#pinnedFree">cudaV_pinnedFree</a>,&nbsp;&nbsp; <a href="#pinnedNfree">cudaV_pinnedNfree</a>,&nbsp;&nbsp; <a href="#pinnedVector">cudaVF_pinnedVector</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pinnedNfree"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>cudaV_pinnedNfree</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>De-allocate pinned host memory occupied by one or more vectors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>int cudaV_pinnedNfree( unsigned numfree, ...&nbsp;);</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The parameter numfree &quot;tells&quot; the function how many vectors it has to free. The host pointers of these vectors follow in the parameter list after numfree. Only vectors which have been allocated by one of the functions of the <I><a href="#pinnedVector">cudaVF_pinnedVector</a></I> or <I><a href="#pinnedVector0">cudaVF_pinnedVector0</a></I> family can be de-allocated by <i>cudaV_pinnedNfree</i>.
<BR>If device pointers are mistakenly used rather than the host pointers, an error message is displayed.
<BR>Pascal/Delphi: since a variable number of parameters is not supported in Pascal language, this function is missing.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">cudaV_pinnedNfree( 3, h_X, h_Y, h_Z&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0) in case of success, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a>, &nbsp;&nbsp;<I><a href="#pinnedFree">cudaV_pinnedFree</a>,&nbsp;&nbsp; <a href="#pinnedFreeAll">cudaV_pinnedFreeAll</a>,&nbsp;&nbsp; <a href="#pinnedVector">cudaVF_pinnedVector</a>,&nbsp;&nbsp; <a href="#pinnedVector0">cudaVF_pinnedVector0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pinnedVector"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaVF_pinnedVector</b></font></td><td width="34%"><font size="+1"><b>cudaVD_pinnedVector</b></font></td><td><font size="+1"><b>cudaVE_pinnedVector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaVCF_pinnedVector</b></font></td><td width="34%"><font size="+1"><b>cudaVCD_pinnedVector</b></font></td><td><font size="+1"><b>cudaVCE_pinnedVector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaVPF_pinnedVector</b></font></td><td width="34%"><font size="+1"><b>cudaVPD_pinnedVector</b></font></td><td><font size="+1"><b>cudaVPE_pinnedVector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaVI_pinnedVector</b></font></td><td width="34%"><font size="+1"><b>cudaVBI_pinnedVector</b></font></td><td><font size="+1"><b>cudaVSI_pinnedVector</b></font></td></tr>
<tr valign="TOP"><td width="33%"><font size="+1"><b>cudaVLI_pinnedVector</b></font></td><td width="34%"><font size="+1"><b>cudaVQI_pinnedVector</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaVU_pinnedVector</b></font></td><td width="34%"><font size="+1"><b>cudaVUB_pinnedVector</b></font></td><td><font size="+1"><b>cudaVUS_pinnedVector</b></font></td></tr>
<tr valign="TOP"><td width="33%"><font size="+1"><b>cudaVUL_pinnedVector</b></font></td><td width="34%"><font size="+1"><b>cudaVUQ_pinnedVector</b></font></td><td><font size="+1"><b>cudaVUI_pinnedVector</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Allocation of pinned host memory</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>fVector&nbsp;cudaVF_pinnedVector( fVector&nbsp;*h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function cudaVF_pinnedVector( var&nbsp;h_X:fVector; size:UIntSize&nbsp;):&nbsp;fVector;</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Pinned host memory is allocated. The device pointer is returned, and the host pointer is stored as h_X. In order to release the memory thus allocated, use <I><a href="#pinnedFree">cudaV_pinnedFree</a>,&nbsp;&nbsp; <a href="#pinnedFreeAll">cudaV_pinnedFreeAll</a></I>, or <I><a href="#pinnedNfree">cudaV_pinnedNfree</a></I> (the latter only in C/C++).
<BR>See <a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a> for a description of the various memory types of <i>cudaOptiVec</i> routines.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Device pointer to the allocated memory</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a>, &nbsp;&nbsp;<I><a href="#pinnedVector0">cudaVF_pinnedVector0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pinnedVector0"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaVF_pinnedVector0</b></font></td><td width="34%"><font size="+1"><b>cudaVD_pinnedVector0</b></font></td><td><font size="+1"><b>cudaVE_pinnedVector0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaVCF_pinnedVector0</b></font></td><td width="34%"><font size="+1"><b>cudaVCD_pinnedVector0</b></font></td><td><font size="+1"><b>cudaVCE_pinnedVector0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaVPF_pinnedVector0</b></font></td><td width="34%"><font size="+1"><b>cudaVPD_pinnedVector0</b></font></td><td><font size="+1"><b>cudaVPE_pinnedVector0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaVI_pinnedVector0</b></font></td><td width="34%"><font size="+1"><b>cudaVBI_pinnedVector0</b></font></td><td><font size="+1"><b>cudaVSI_pinnedVector0</b></font></td></tr>
<tr valign="TOP"><td width="33%"><font size="+1"><b>cudaVLI_pinnedVector0</b></font></td><td width="34%"><font size="+1"><b>cudaVQI_pinnedVector0</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaVU_pinnedVector0</b></font></td><td width="34%"><font size="+1"><b>cudaVUB_pinnedVector0</b></font></td><td><font size="+1"><b>cudaVUS_pinnedVector0</b></font></td></tr>
<tr valign="TOP"><td width="33%"><font size="+1"><b>cudaVUL_pinnedVector0</b></font></td><td width="34%"><font size="+1"><b>cudaVUQ_pinnedVector0</b></font></td><td><font size="+1"><b>cudaVUI_pinnedVector0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Allocation of pinned host memory and initialisation with 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>fVector&nbsp;cudaVF_pinnedVector0( fVector&nbsp;*h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function cudaVF_pinnedVector0( var&nbsp;h_X:fVector; size:UIntSize&nbsp;):&nbsp;fVector;</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Pinned host memory is allocated and initialized with 0. The device pointer is returned, and the host pointer is stored as h_X. In order to release the memory thus allocated, use <I><a href="#pinnedFree">cudaV_pinnedFree</a>,&nbsp;&nbsp; <a href="#pinnedFreeAll">cudaV_pinnedFreeAll</a></I>, or <I><a href="#pinnedNfree">cudaV_pinnedNfree</a></I> (the latter only in C/C++).
<BR>See <a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a> for a description of the various memory types of <i>cudaOptiVec</i> routines.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Device pointer to the allocated memory</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a>, &nbsp;&nbsp;<I><a href="#pinnedVector">cudaVF_pinnedVector</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="polar"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_polar</b></font></td><td width="33%"><font size="+1"><b>VCD_polar</b></font></td><td><font size="+1"><b>VCE_polar</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_polar</b></font></td><td width="33%"><font size="+1"><b>VPD_polar</b></font></td><td><font size="+1"><b>VPE_polar</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct a Cartesian or polar complex vector from polar coordinates given as separate vectors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd&gt;
<BR>void VCF_polar( cfVector&nbsp;X, fVector&nbsp;Mag, fVector&nbsp;Arg, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::polar( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Mag, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Arg&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_polar( X:cfVector; Mag, Arg:fVector; size:UIntSize);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_polar( cfVector&nbsp;d_X, fVector&nbsp;d_Mag, fVector&nbsp;d_Arg, ui&nbsp;size&nbsp;);
<BR>void VCFcu_polar( cfVector&nbsp;h_X, fVector&nbsp;h_Mag, fVector&nbsp;h_Arg, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_polar( d_X:cfVector; d_Mag,&nbsp;d_Arg:fVector; size:UIntSize):&nbsp;IntBool;
<BR>procedure VCFcu_polar( h_X:cfVector; h_Mag,&nbsp;h_Arg:fVector; size:UIntSize);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Identical to <I><a href="#PolartoC">VF_PolartoC</a></I> etc. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PolartoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PolartoC</b></font></td><td width="33%"><font size="+1"><b>VD_PolartoC</b></font></td><td><font size="+1"><b>VE_PolartoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct Cartesian complex numbers from polar coordinates, entered as separate vectors for Mag and Arg.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_PolartoC( cfVector&nbsp;X, fVector&nbsp;Mag, fVector&nbsp;Arg, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::PolartoC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Mag, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Arg&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_PolartoC( X:cfVector; Mag,&nbsp;Arg:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVF_PolartoC( cfVector&nbsp;d_X, fVector&nbsp;d_Mag, fVector&nbsp;d_Arg, ui&nbsp;size&nbsp;);
<BR>void VFcu_PolartoC( cfVector&nbsp;h_X, fVector&nbsp;h_Mag, fVector&nbsp;h_Arg, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVF_PolartoC( d_X:cfVector; d_Mag,&nbsp;d_Arg:fVector; size:UIntSize):&nbsp;IntBool;
<BR>procedure VFcu_PolartoC( h_X:cfVector; h_Mag,&nbsp;h_Arg:fVector; size:UIntSize);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar coordinates Mag (magnitude, absolute value) and Arg (argument, angle) of each element are used to construct the Cartesian complex vector X.
<BR>The difference between this function and <I><a href="#PtoC">VF_PtoC</a></I> is that, in the latter, the input consists of one vector of type pfVector, rather than of two real-valued vectors for Mag and Arg.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>The total loss of precision for very large values of Arg is treated tacitly (without an error message); if it occurs, the result is set to {Mag, 0}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoC">VF_PtoC</a>,&nbsp;&nbsp; <a href="#CtoPolar">VF_CtoPolar</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#CtoArg">VF_CtoArg</a>,&nbsp;&nbsp; <a href="#CtoNorm">VF_CtoNorm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="poly"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_poly</b></font></td><td width="33%"><font size="+1"><b>VD_poly</b></font></td><td><font size="+1"><b>VE_poly</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_poly</b></font></td><td width="33%"><font size="+1"><b>VDx_poly</b></font></td><td><font size="+1"><b>VEx_poly</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Polynomial</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_poly( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, fVector&nbsp;Coeff, unsigned&nbsp;deg&nbsp;);
<BR>int VFx_poly( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, fVector&nbsp;Coeff, unsigned&nbsp;deg, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int VFu_poly( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, fVector&nbsp;Coeff, unsigned&nbsp;deg&nbsp;);
<BR>int VFux_poly( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, fVector&nbsp;Coeff, unsigned&nbsp;deg, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::poly( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Coeff, unsigned&nbsp;deg&nbsp;);
<BR>int vector&lt;T&gt;::x_poly( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Coeff, unsigned&nbsp;deg, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_poly( Y,&nbsp;X:fVector; size:UIntSize; Coeff:fVector; deg:UInt&nbsp;):&nbsp;IntBool;
<BR>function VFx_poly( Y,&nbsp;X:fVector; size:UIntSize; Coeff:fVector; deg:UInt; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function VFu_poly( Y,&nbsp;X:fVector; size:UIntSize; Coeff:fVector; deg:UInt&nbsp;):&nbsp;IntBool;
<BR>function VFux_poly( Y,&nbsp;X:fVector; size:UIntSize; Coeff:fVector; deg:UInt; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_poly( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;h_Coeff, unsigned&nbsp;deg&nbsp;);
<BR>int cusdVF_poly( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;d_Coeff, unsigned&nbsp;deg&nbsp;);
<BR>int cudaVFx_poly( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;h_Coeff, unsigned&nbsp;deg, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_poly( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;d_Coeff, unsigned&nbsp;deg, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int cudaVFu_poly( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;h_Coeff, unsigned&nbsp;deg&nbsp;);
<BR>int cusdVFu_poly( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;d_Coeff, unsigned&nbsp;deg&nbsp;);
<BR>int cudaVFux_poly( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;h_Coeff, unsigned&nbsp;deg, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFux_poly( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;d_Coeff, unsigned&nbsp;deg, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int VFcu_poly( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, fVector&nbsp;h_Coeff, unsigned&nbsp;deg&nbsp;);
<BR>int VFxcu_poly( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, fVector&nbsp;h_Coeff, unsigned&nbsp;deg, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int VFucu_poly( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, fVector&nbsp;h_Coeff, unsigned&nbsp;deg&nbsp;);
<BR>int VFuxcu_poly( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, fVector&nbsp;h_Coeff, unsigned&nbsp;deg, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_poly( d_Y,&nbsp;d_X:fVector; size:UIntSize; h_Coeff:fVector; deg:UInt&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_poly( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_Coeff:fVector; deg:UInt&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_poly( d_Y,&nbsp;d_X:fVector; size:UIntSize; h_Coeff:fVector; deg:UInt; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_poly( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_Coeff:fVector; deg:UInt; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVFu_poly( d_Y,&nbsp;d_X:fVector; size:UIntSize; h_Coeff:fVector; deg:UInt&nbsp;):&nbsp;IntBool;
<BR>function cusdVFu_poly( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_Coeff:fVector; deg:UInt&nbsp;):&nbsp;IntBool;
<BR>function cudaVFux_poly( d_Y,&nbsp;d_X:fVector; size:UIntSize; h_Coeff:fVector; deg:UInt; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFux_poly( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_Coeff:fVector; deg:UInt; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_poly( h_Y,&nbsp;h_X:fVector; size:UIntSize; h_Coeff:fVector; deg:UInt&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_poly( h_Y,&nbsp;h_X:fVector; size:UIntSize; h_Coeff:fVector; deg:UInt; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function VFucu_poly( h_Y,&nbsp;h_X:fVector; size:UIntSize; h_Coeff:fVector; deg:UInt&nbsp;):&nbsp;IntBool;
<BR>function VFuxcu_poly( h_Y,&nbsp;h_X:fVector; size:UIntSize; h_Coeff:fVector; deg:UInt; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions:
<BR>Y<sub>i</sub> = c<sub>0</sub> + c<sub>1</sub> *&nbsp;X<sub>i</sub> + c<sub>2</sub> *&nbsp;X<sub>i</sub><sup>2</sup> + ... + c<sub>n</sub> *&nbsp;X<sub>i</sub><sup>n</sup>
<BR>expanded versions:
<BR>xi = (A*X<sub>i</sub> + B),
<BR>Y<sub>i</sub> = c<sub>0</sub> + c<sub>1</sub> *&nbsp;xi + c<sub>2</sub> *&nbsp;xi<sup>2</sup> + ... + c<sub>n</sub> *&nbsp;xi<sup>n</sup>
<P>A polynomial of degree <I>deg</I> is generated for every element of X, using the coefficients contained in the vector Coeff. The coefficients in Coeff have to be ordered in such a way that the constant term is the zero'th element, the linear coefficient the first element etc., up to the <I>deg</I>'th element which is the coefficient for the highest power used in the polynomial. (Beware a frequent source of errors: for a polynomial of <I>deg</I> = 4, there are 5 (!) coefficients; do not forget the constant term).
<P>&quot;unprotected&quot; versions (prefix <I>VFu_,&nbsp;&nbsp; VFux_</I>, etc.):
<BR>These functions do not perform any error handling, which makes them much faster (up to 50%) than the standard versions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to &#177;HUGE_VAL as the default result. In contrast to the ANSI C function <I>poly</I> (where <I>deg</I> is declared as int), the declaration of <I>deg</I> as unsigned precludes DOMAIN errors (which would occur for negative <I>deg</I>).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; poly</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="polyinterpol"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_polyinterpol</b></font></td><td width="33%"><font size="+1"><b>VD_polyinterpol</b></font></td><td><font size="+1"><b>VE_polyinterpol</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Polynomial interpolation of X-Y-table values</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_polyinterpol( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;sizex, fVector&nbsp;XTab, fVector&nbsp;YTab, ui&nbsp;sizetab, unsigned&nbsp;deg&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::polyinterpol( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;XTab, const&nbsp;vector&lt;T&gt;&amp;&nbsp;YTab, unsigned&nbsp;deg&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_polyinterpol( Y,&nbsp;X:fVector; sizex:UIntSize; XTab,&nbsp;YTab:fVector; sizetab:UIntSize; deg:UInt&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_polyinterpol( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;sizex, fVector&nbsp;d_XTab, fVector&nbsp;d_YTab, ui&nbsp;sizetab, unsigned&nbsp;deg&nbsp;);
<BR>void VFcu_polyinterpol( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;sizex, fVector&nbsp;h_XTab, fVector&nbsp;h_YTab, ui&nbsp;sizetab, unsigned&nbsp;deg&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_polyinterpol( d_Y,&nbsp;d_X:fVector; sizex:UIntSize; d_XTab,&nbsp;d_YTab:fVector; sizetab:UIntSize; deg:UInt&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_polyinterpol( h_Y,&nbsp;h_X:fVector; sizex:UIntSize; h_XTab,&nbsp;h_YTab:fVector; sizetab:UIntSize; deg:UInt&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each of the sizex elements of X, the corresponding element of Y is interpolated from the XTab-YTab value pairs. XTab must be ordered (either ascending or descending). All values of XTab must be distinct; otherwise a division by zero may occur and lead to a program abort. For each element of X, the routine first locates the appropriate place in the table from which to start the interpolation. The parameter <i>deg</i> denotes the number of points that will be taken into account for the interpolation (this is not the degree of the interpolating polynomial!). Any value between 0 and 2 will be interpreted as meaning linear interpolation. A maximum of 10-point interpolation is possible. <i>deg</i> may not be larger than <i>sizetab-1</i>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Trying to use too many elements for the interpolation (deg &gt; 10) leads to an error message &quot;Not possible with more than 10 elements&quot; and to a program abort. If deg exceeds sizetab-1, an error message &quot;Invalid parameter(s)&quot; is displayed and the program aborted.
<BR>No other errors are detected (you have to take care yourself that the XTab values are distinct and that the YTab values are not near the limit of overflowing).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ratinterpol">VF_ratinterpol</a>,&nbsp;&nbsp; <a href="#splineinterpol">VF_splineinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pow"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_pow</b></font></td><td width="33%"><font size="+1"><b>VD_pow</b></font></td><td><font size="+1"><b>VE_pow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_pow</b></font></td><td width="33%"><font size="+1"><b>VCD_pow</b></font></td><td><font size="+1"><b>VCE_pow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_pow</b></font></td><td width="33%"><font size="+1"><b>VDx_pow</b></font></td><td><font size="+1"><b>VEx_pow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_pow</b></font></td><td width="33%"><font size="+1"><b>VCDx_pow</b></font></td><td><font size="+1"><b>VCEx_pow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_powReExpo</b></font></td><td width="33%"><font size="+1"><b>VCD_powReExpo</b></font></td><td><font size="+1"><b>VCE_powReExpo</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_powReExpo</b></font></td><td width="33%"><font size="+1"><b>VCDx_powReExpo</b></font></td><td><font size="+1"><b>VCEx_powReExpo</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_powReExpo</b></font></td><td width="33%"><font size="+1"><b>VPD_powReExpo</b></font></td><td><font size="+1"><b>VPE_powReExpo</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Raise each element of a vector to a specified power</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_pow( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;Expo&nbsp;);
<BR>int VFx_pow( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VCF_pow( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex Expo&nbsp;);
<BR>int VCFx_pow( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex Expo, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);
<BR>int VCF_powReExpo( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, float&nbsp;Expo&nbsp;);
<BR>int VCFx_powReExpo( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, float&nbsp;Expo, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::pow( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;Expo&nbsp;);
<BR>int vector&lt;T&gt;::x_pow( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;Expo, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>int vector&lt;complex&lt;T&gt;&gt;::pow( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; Expo&nbsp;);
<BR>int vector&lt;complex&lt;T&gt;&gt;::x_pow( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; Expo, complex&lt;T&gt; A, complex&lt;T&gt; B, complex&lt;T&gt; C&nbsp;);
<BR>int vector&lt;complex&lt;T&gt;&gt;::powReExpo( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;Expo&nbsp;);
<BR>int vector&lt;complex&lt;T&gt;&gt;::x_powReExpo( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;Expo, complex&lt;T&gt; A, complex&lt;T&gt; B, complex&lt;T&gt; C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_pow( Y,&nbsp;X:fVector; size:UIntSize; Expo:Single&nbsp;):&nbsp;IntBool;
<BR>function VFx_pow( Y,&nbsp;X:fVector; size:UIntSize; Expo,&nbsp;A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VCF_pow( Y,&nbsp;X:cfVector; size:UIntSize; Expo:fComplex&nbsp;):&nbsp;IntBool;
<BR>function VCF_powReExpo( Y,&nbsp;X:cfVector; size:UIntSize; Expo:Single&nbsp;):&nbsp;IntBool;
<BR>function VCFx_powReExpo( Y,&nbsp;X:cfVector; size:UIntSize; Expo:Single; A,&nbsp;B,&nbsp;C:fComplex&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_pow( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo&nbsp;);
<BR>int cudaVFx_pow( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_pow( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo, float&nbsp;*_dA, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_pow( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Expo&nbsp;);
<BR>int VFxcu_pow( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>&nbsp;<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVCF_pow( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, fComplex&nbsp;Expo&nbsp;);
<BR>int cudaVCFx_pow( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, fComplex&nbsp;Expo, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);
<BR>int cusdVCFx_pow( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, fComplex&nbsp;Expo, fComplex&nbsp;*d_A, fComplex&nbsp;*d_B, fComplex&nbsp;*d_C&nbsp;);
<BR>int cudaVCF_powReExpo( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo&nbsp;);
<BR>int cudaVCFx_powReExpo( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);
<BR>int cusdVCFx_powReExpo( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo, fComplex&nbsp;*d_A, fComplex&nbsp;*d_B, fComplex&nbsp;*d_C&nbsp;);
<BR>int VCFcu_pow( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, fComplex&nbsp;Expo&nbsp;);
<BR>int VCFxcu_pow( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, fComplex&nbsp;Expo, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);
<BR>int VCFcu_powReExpo( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Expo&nbsp;);
<BR>int VCFxcu_powReExpo( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Expo, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_pow( d_Y, d_X:fVector; size:UIntSize; Expo:Single&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_pow( d_Y, d_X:fVector; size:UIntSize; Expo:Single; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_pow( d_Y, d_X:fVector; size:UIntSize; Expo:Single; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_pow( h_Y, h_X:fVector; size:UIntSize; Expo:Single&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_pow( h_Y, h_X:fVector; size:UIntSize; Expo:Single; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>&nbsp;<BR>uses VCFmath;
<BR>int cudaVCF_pow( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, fComplex&nbsp;Expo&nbsp;);
<BR>int cudaVCFx_pow( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, fComplex&nbsp;Expo, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);
<BR>int cusdVCFx_pow( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, fComplex&nbsp;Expo, fComplex&nbsp;*d_A, fComplex&nbsp;*d_B, fComplex&nbsp;*d_C&nbsp;);
<BR>int cudaVCF_powReExpo( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo&nbsp;);
<BR>int cudaVCFx_powReExpo( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);
<BR>int cusdVCFx_powReExpo( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo, fComplex&nbsp;*d_A, fComplex&nbsp;*d_B, fComplex&nbsp;*d_C&nbsp;);
<BR>int VCFcu_pow( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, fComplex&nbsp;Expo&nbsp;);
<BR>int VCFxcu_pow( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, fComplex&nbsp;Expo, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);
<BR>int VCFcu_powReExpo( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Expo&nbsp;);
<BR>int VCFxcu_powReExpo( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Expo, fComplex&nbsp;A, fComplex&nbsp;B, fComplex&nbsp;C&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = X<sub>i</sub> <sup>Expo</sup>
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;((A*X<sub>i</sub>+B) <sup>Expo</sup>)
<BR>If Expo is a moderately small integer number, the functions of this family pass the job to the appropriate routine of the <I><a href="#ipow">VF_ipow</a></I> family. More efficiently, the user could do just that himself.
<BR>The complex version exists in two variants: one for complex exponents, the other for complex numbers raised to a real exponent.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>DOMAIN errors occur, if negative numbers are raised to fractional powers; the default result is NAN (&quot;not-a-number&quot;). SING errors occur, if zero is raised to a negative power; the default result is &#177;HUGE_VAL, which is true for OVERFLOW errors as well.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a>,&nbsp;&nbsp; <a href="#pow2">VF_pow2</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#powexp">VF_powexp</a>,&nbsp;&nbsp; pow</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pow10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_pow10</b></font></td><td width="33%"><font size="+1"><b>VD_pow10</b></font></td><td><font size="+1"><b>VE_pow10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_pow10</b></font></td><td width="33%"><font size="+1"><b>VDx_pow10</b></font></td><td><font size="+1"><b>VEx_pow10</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Real powers of 10</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_pow10( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_pow10( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::pow10( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_pow10( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_pow10( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_pow10( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_pow10( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_pow10( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_pow10( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_pow10( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_pow10( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_pow10( d_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_pow10( d_Y,&nbsp;d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_pow10( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_pow10( h_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_pow10( h_Y,&nbsp;h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 10.0 <sup>X</sup><font size="-1">i</font>
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;10.0<sup>A*X</sup><font size="-1">i</font><sup>+B</sup>
<BR>This is an exponential function to the basis of 10.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ipow10">VF_ipow10</a>,&nbsp;&nbsp; <a href="#scale10">VF_scale10</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; pow10</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pow2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_pow2</b></font></td><td width="33%"><font size="+1"><b>VD_pow2</b></font></td><td><font size="+1"><b>VE_pow2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_pow2</b></font></td><td width="33%"><font size="+1"><b>VDx_pow2</b></font></td><td><font size="+1"><b>VEx_pow2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Real powers of 2</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_pow2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_pow2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::pow2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_pow2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_pow2( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_pow2( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_pow2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_pow2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_pow2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_pow2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_pow2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_pow2( d_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_pow2( d_Y,&nbsp;d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_pow2( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_pow2( h_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_pow2( h_Y,&nbsp;h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 2.0 <sup>X</sup><font size="-1">i</font>
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;2.0<sup>A*X</sup><font size="-1">i</font><sup>+B</sup>
<BR>This is an exponential function to the basis of 2.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ipow2">VF_ipow2</a>,&nbsp;&nbsp; <a href="#scale2">VF_scale2</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; pow</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="powexp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_powexp</b></font></td><td width="33%"><font size="+1"><b>VD_powexp</b></font></td><td><font size="+1"><b>VE_powexp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_powexp</b></font></td><td width="33%"><font size="+1"><b>VDx_powexp</b></font></td><td><font size="+1"><b>VEx_powexp</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Power function, multiplied by exponential function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_powexp( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;Expo&nbsp;);
<BR>int VFx_powexp( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::powexp( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;Expo&nbsp;);
<BR>int vector&lt;T&gt;::x_powexp( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;Expo, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_powexp( Y,&nbsp;X:fVector; size:UIntSize; Expo:Single&nbsp;):&nbsp;IntBool;
<BR>function VFx_powexp( Y,&nbsp;X:fVector; size:UIntSize; Expo,&nbsp;A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_powexp( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo&nbsp;);
<BR>int cudaVFx_powexp( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_powexp( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Expo, float&nbsp;*_dA, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_powexp( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Expo&nbsp;);
<BR>int VFxcu_powexp( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Expo, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_powexp( d_Y, d_X:fVector; size:UIntSize; Expo:Single&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_powexp( d_Y, d_X:fVector; size:UIntSize; Expo:Single; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_powexp( d_Y, d_X:fVector; size:UIntSize; Expo:Single; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_powexp( h_Y, h_X:fVector; size:UIntSize; Expo:Single&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_powexp( h_Y, h_X:fVector; size:UIntSize; Expo:Single; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = X<sub>i</sub><sup>Expo</sup>&nbsp;*&nbsp;exp(X<sub>i</sub>)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;(X<sub>i</sub><sup>Expo</sup>) *&nbsp;exp(A*X<sub>i</sub>+B)
<P>Note for the expanded versions that (A*X<sub>i</sub>+B) is taken only as the argument of the exponential function, whereas the power function is calculated for (X<sub>i</sub>). 
<BR>The implementation of this function guarantees the correct cancellation of potential simultaneous overflow and underflow of the two constituting factors (for large X<sub>i</sub>, if either Expo or A*X<sub>i</sub> &#x2013;&nbsp;but not both &#x2013; are negative, so that either the power function or the exponential function would yield a very small result, while the other would yield an overflowing result). 
<BR>In contrast to <a href="#pow">VF_pow</a>, negative X values in the power function always lead to a DOMAIN error, even if Expo is an integer.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>DOMAIN errors are caused by negative X<sub>i</sub>; the default result is NAN (&quot;not-a-number&quot;). SING errors occur, if zero is raised to a negative power; the default result is &#177;HUGE_VAL, which is true for OVERFLOW errors as well.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; pow,&nbsp; exp</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="principal"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_principal</b></font></td><td width="33%"><font size="+1"><b>VPD_principal</b></font></td><td><font size="+1"><b>VPE_principal</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reduce polar complex numbers to principal value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VPF_principal( pfVector&nbsp;Y, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::principal( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VPF_principal( Y,&nbsp;X:pfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVPF_principal( pfVector&nbsp;d_Y, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VPFcu_principal( pfVector&nbsp;d_Y, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVPF_principal( h_Y,&nbsp;h_X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VPFcu_principal( h_Y,&nbsp;h_X:pfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The argument, i.e. the angle of each element is reduced to the range -<font face="symbol">p</font> &lt; Arg &lt;= +<font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#MagArgtoPrincipal">VF_MagArgtoPrincipal</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="print"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_print</b></font></td><td width="34%"><font size="+1"><b>VD_print</b></font></td><td><font size="+1"><b>VE_print</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_print</b></font></td><td width="34%"><font size="+1"><b>VCD_print</b></font></td><td><font size="+1"><b>VCE_print</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_print</b></font></td><td width="17%"><font size="+1"><b>VBI_print</b></font></td><td width="17%"><font size="+1"><b>VSI_print</b></font></td><td width="17%"><font size="+1"><b>VLI_print</b></font></td><td width="17%"><font size="+1"><b>VQI_print</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_print</b></font></td><td width="17%"><font size="+1"><b>VUB_print</b></font></td><td width="17%"><font size="+1"><b>VUS_print</b></font></td><td width="17%"><font size="+1"><b>VUL_print</b></font></td><td width="17%"><font size="+1"><b>VUQ_print</b></font></td><td><font size="+1"><b>VUI_print</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Print a vector as ASCII numbers to <I>stdout</I>, assuming a linewidth of 80 characters. Only for console applications.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_print( fVector&nbsp;X, ui&nbsp;size, unsigned nperline&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::print( unsigned nperline&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_print( X:fVector; size:UIntSize; nperline:UInt&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_print( fVector&nbsp;d_X, ui&nbsp;size, unsigned&nbsp;nperline&nbsp;);
<BR>int cudaVF_print_buf( fVector&nbsp;d_X, ui&nbsp;size, unsigned&nbsp;nperline, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_print( d_X:fVector; size:UIntSize; nperline:UInt&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_print_buf( d_X:fVector; size:UIntSize; nperline:UInt; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><i>size</i> elements of <i>X</i> are printed to stdout, <i>nperline</i> in each line. The available linewidth is assumed to be 80 characters. Each line begins with the index of the first element printed into that line. The index is followed by a colon and by the requested <i>nperline</i> elements.
<P>Cartesian complex numbers are printed in braces, with the real and imaginary parts separated by a komma: {Re,&nbsp;Im}. Polar complex numbers are also written in braces, with the Mag and Arg parts separated by an at-sign: {Mag @ Arg}.
<P>In contrast to <I><a href="#cprint">VF_cprint</a></I>, no paging is performed.
<BR>The number of digits per element is determined by the available space, which depends in turn on <i>nperline</i>.
<P>This family of functions can be used only for console applications.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If <i>nperline</i> exceeds the maximum number of entries possible within 80 characters, an error message &quot;Cannot use requested format (too many entries per line)&quot; is generated; in this case, the program chooses the maximum number <i>nperline</i> possible.
<P>CUDA versions only: <i>cudaV?_print_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as X. By avoiding the need of <i>cudaV?_print</i> to allocate its own buffer memory, <i>cudaV?_print_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cprint">VF_cprint</a>,&nbsp;&nbsp; <a href="#fprint">VF_fprint</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; printf</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="printErrorMsg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_printErrorMsg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Print an error message.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_printErrorMsg( char *ErrMsg&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_printErrMsg( ErrMsg: PChar&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>As described in connection with <I><a href="#noteError">V_noteError</a></I>, this function is in charge of printing error messages. By default, output is directed to the screen. The function <I><a href="#setErrorEventFile">V_setErrorEventFile</a></I> may be used to redirect the output into an event file (exclusively or in addition to the screen message). <I>V_printErrorMsg</I> may be called from user-defined routines in which error conditions are detected. If the message is longer than one line, carriage returns (&quot;\n&quot; or &quot;\r\n&quot; for C/C++, #13 for Pascal/Delphi) have to be included at the desired place.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setErrorEventFile">V_setErrorEventFile</a>,&nbsp;&nbsp; <a href="#noteError">V_noteError</a>,&nbsp;&nbsp; _matherr</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="prod"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_prod</b></font></td><td width="33%"><font size="+1"><b>VD_prod</b></font></td><td><font size="+1"><b>VE_prod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_prod</b></font></td><td width="33%"><font size="+1"><b>VCD_prod</b></font></td><td><font size="+1"><b>VCE_prod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_prod</b></font></td><td width="33%"><font size="+1"><b>VPD_prod</b></font></td><td><font size="+1"><b>VPE_prod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculates the product of all the elements of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_prod( fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>fComplex VCF_prod( cfVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>fPolar VPF_prod( pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::prod();
<BR>complex&lt;T&gt; vector&lt;complex&lt;T&gt;&gt;::prod();
<BR>polar&lt;T&gt; vector&lt;polar&lt;T&gt;&gt;::prod();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_prod( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;
<BR>function VCF_prod( X:cfVector; size:UIntSize&nbsp;):fComplex;
<BR>function VPF_prod( X:pfVector; size:UIntSize&nbsp;):fPolar;</font>
<BR>Alternative syntax for the complex types (obsolete, but still supported):<font face="courier new">
<BR>procedure VCF_prod( var Prod:fComplex; X:cfVector; size:UIntSize);
<BR>procedure VPF_prod( var Prod:fPolar; X:pfVector; size:UIntSize);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_prod( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_prod( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_prod( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_prod( var&nbsp;h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_prod( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_prod( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The product of all elements of a vector is calculated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but be careful: this function may easily overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the product of the vector elements (except complex versions in Pascal/Delphi)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#runprod">VF_runprod</a>,&nbsp;&nbsp; <a href="#sum">VF_sum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoAbs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoAbs</b></font></td><td width="33%"><font size="+1"><b>VD_PtoAbs</b></font></td><td><font size="+1"><b>VE_PtoAbs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Absolute value (magnitude) of polar complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoAbs( fVector&nbsp;Abs, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoAbs( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoAbs( Abs:fVector; X:pfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_PtoAbs( fVector&nbsp;d_Abs, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_PtoAbs( fVector&nbsp;h_Abs, pfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_PtoAbs( d_Abs:fVector; d_X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VF_PtoAbs( h_Abs:fVector; h_X:pfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute value, i.e. the magnitude of each element of the polar complex vector X is extracted. This function is identical to <I><a href="#abs">VPF_abs</a></I> and <I><a href="#PtoMag">VF_PtoMag</a></I>. For historical reasons, all three names have been preserved.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#abs">VPF_abs</a>,&nbsp;&nbsp; <a href="#PtoMagArg">VF_PtoMagArg</a>,&nbsp;&nbsp; <a href="#PtoArg">VF_PtoArg</a>,&nbsp;&nbsp; <a href="#PtoNorm">VF_PtoNorm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoArg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoArg</b></font></td><td width="33%"><font size="+1"><b>VD_PtoArg</b></font></td><td><font size="+1"><b>VE_PtoArg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Argument (angle) of complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoArg( fVector&nbsp;Arg, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoArg( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoArg( Arg:fVector; X:pfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_PtoArg( fVector&nbsp;d_Arg, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_PtoArg( fVector&nbsp;h_Arg, pfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_PtoArg( d_Arg:fVector; d_X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VF_PtoArg( h_Arg:fVector; h_X:pfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The argument, i.e. the angle of each element is extracted from the polar complex vector X. In contrast to the analogous function for cartesian complex vectors, <I><a href="#CtoArg">VF_CtoArg</a></I>, no normalization of the argument is performed. If the normalized argument is needed, <I><a href="#principal">VPF_principal</a></I> must be called first.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoAbs">VF_PtoAbs</a>,&nbsp;&nbsp; <a href="#PtoMagArg">VF_PtoMagArg</a>,&nbsp;&nbsp; <a href="#PtoReIm">VF_PtoReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoC</b></font></td><td width="33%"><font size="+1"><b>VD_PtoC</b></font></td><td><font size="+1"><b>VE_PtoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Transformation of a polar complex into a cartesian complex vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoC( cfVector&nbsp;Y, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::PtoC( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoC( Y:cfVector; X:pfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_PtoC( cfVector&nbsp;d_Y, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_PtoC( cfVector&nbsp;h_Y, pfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_PtoC( d_Abs:cfVector; d_X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VF_PtoC( h_Abs:cfVector; h_X:pfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X is transformed from polar coordinates {Mag @ Arg} into cartesian coordinates {Re,&nbsp;Im}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoP">VF_CtoP</a>,&nbsp;&nbsp; <a href="#PtoReIm">VF_PtoReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoIm</b></font></td><td width="33%"><font size="+1"><b>VD_PtoIm</b></font></td><td><font size="+1"><b>VE_PtoIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extract the imaginary part from a polar complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoIm( fVector&nbsp;Im, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoIm( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoIm( Im:fVector; X:pfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_PtoIm( fVector&nbsp;d_Im, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_PtoIm( fVector&nbsp;h_Im, pfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_PtoIm( d_Im:fVector; d_X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VF_PtoIm( h_Im:fVector; h_X:pfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The imaginary part of the polar complex vector X is calculated and stored in Im.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoReIm">VF_PtoReIm</a>,&nbsp;&nbsp; <a href="#ReImtoP">VF_ReImtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoMag"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoMag</b></font></td><td width="33%"><font size="+1"><b>VD_PtoMag</b></font></td><td><font size="+1"><b>VE_PtoMag</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extract the magnitudes of complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoMag( fVector&nbsp;Mag, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoMag( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoMag( Mag:fVector; X:pfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_PtoMag( fVector&nbsp;d_Mag, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_PtoMag( fVector&nbsp;h_Mag, pfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_PtoMag( d_Mag:fVector; d_X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VF_PtoMag( h_Mag:fVector; h_X:pfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The magnitude of each element is extracted from the polar complex vector X.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoArg">VF_PtoArg</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoMagArg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoMagArg</b></font></td><td width="33%"><font size="+1"><b>VD_PtoMagArg</b></font></td><td><font size="+1"><b>VE_PtoMagArg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Split a polar complex vector into separate vectors for magnitude and argument.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoMagArg( fVector&nbsp;Mag, fVector&nbsp;Arg, pfVector&nbsp;X, ui&nbsp;size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoMagArg( vector&lt;T&gt; Arg, const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoMagArg( Mag, Arg:fVector; X:pfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_PtoMagArg( fVector&nbsp;d_Mag, fVector&nbsp;d_Arg, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_PtoMagArg( fVector&nbsp;h_Mag, fVector&nbsp;h_Arg, pfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_PtoMagArg( d_Mag,&nbsp;d_Arg:fVector; d_X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VF_PtoMagArg( h_Mag,&nbsp;h_Arg:fVector; h_X:pfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Magnitude and argument of the polar complex vector X are stored in the separate vectors Mag and Arg.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoRe">VF_PtoRe</a>,&nbsp;&nbsp; <a href="#MagArgtoP">VF_MagArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoNorm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoNorm</b></font></td><td width="33%"><font size="+1"><b>VD_PtoNorm</b></font></td><td><font size="+1"><b>VE_PtoNorm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Norm (square of the absolute value) of complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoNorm( fVector&nbsp;Norm, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoNorm( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoNorm( Norm:fVector; X:pfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_PtoNorm( fVector&nbsp;d_Norm, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_PtoNorm( fVector&nbsp;h_Norm, pfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_PtoNorm( d_Norm:fVector; d_X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VF_PtoNorm( h_Norm:fVector; h_X:pfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Norm<sub>i</sub> = Mag<sup>2</sup>(X<sub>i</sub>)
<BR>This definition of the Norm of a complex number is the same as in C++, but it is not consistent with the usual definition in mathematics, where the term &quot;norm&quot; is used as a synomym for &quot;absolute value&quot; or &quot;magnitude&quot;. As defined here, the Norm is the square of the absolute value. The absolute value itself is available by the function <I><a href="#abs">VPF_abs</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoReIm">VF_PtoReIm</a>,&nbsp;&nbsp; <a href="#abs">VPF_abs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoRe"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoRe</b></font></td><td width="33%"><font size="+1"><b>VD_PtoRe</b></font></td><td><font size="+1"><b>VE_PtoRe</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extracts the real part from a polar complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoRe( fVector&nbsp;Re, pfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoRe( const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoRe( Re:fVector; X:pfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_PtoRe( fVector&nbsp;d_Re, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_PtoRe( fVector&nbsp;h_Re, pfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_PtoRe( d_Re:fVector; d_X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VF_PtoRe( h_Re:fVector; h_X:pfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The real part of the polar complex vector X is calculated and stored in Re.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoReIm">VF_PtoReIm</a>,&nbsp;&nbsp; <a href="#PtoIm">VF_PtoIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoReIm</b></font></td><td width="33%"><font size="+1"><b>VD_PtoReIm</b></font></td><td><font size="+1"><b>VE_PtoReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Real and imaginary parts of a polar complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoReIm( fVector&nbsp;Re, fVector&nbsp;Im, pfVector&nbsp;X, ui&nbsp;size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoReIm( vector&lt;T&gt; Im, const&nbsp;vector&lt;polar&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoReIm( Re,&nbsp;Im:fVector; X:pfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_PtoReIm( fVector&nbsp;d_Re, fVector&nbsp;d_Im, pfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_PtoReIm( fVector&nbsp;h_Re, fVector&nbsp;h_Im, pfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_PtoReIm( d_Re,&nbsp;d_Im:fVector; d_X:pfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VF_PtoReIm( h_Re,&nbsp;h_Im:fVector; h_X:pfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar complex vector X is transformed into cartesian coordinates, which are stored in separate vectors Re and Im.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoRe">VF_PtoRe</a>,&nbsp;&nbsp; <a href="#ReImtoP">VF_ReImtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="quartic"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_quartic</b></font></td><td width="33%"><font size="+1"><b>VD_quartic</b></font></td><td><font size="+1"><b>VE_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_quartic</b></font></td><td width="33%"><font size="+1"><b>VDx_quartic</b></font></td><td><font size="+1"><b>VEx_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFu_quartic</b></font></td><td width="33%"><font size="+1"><b>VDu_quartic</b></font></td><td><font size="+1"><b>VEu_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFux_quartic</b></font></td><td width="33%"><font size="+1"><b>VDux_quartic</b></font></td><td><font size="+1"><b>VEux_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_quartic</b></font></td><td width="33%"><font size="+1"><b>VCD_quartic</b></font></td><td><font size="+1"><b>VCE_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_quartic</b></font></td><td width="33%"><font size="+1"><b>VCDx_quartic</b></font></td><td><font size="+1"><b>VCEx_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFu_quartic</b></font></td><td width="33%"><font size="+1"><b>VCDu_quartic</b></font></td><td><font size="+1"><b>VCEu_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFux_quartic</b></font></td><td width="33%"><font size="+1"><b>VCDux_quartic</b></font></td><td><font size="+1"><b>VCEux_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_quartic</b></font></td><td width="33%"><font size="+1"><b>VPD_quartic</b></font></td><td><font size="+1"><b>VPE_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPFu_quartic</b></font></td><td width="33%"><font size="+1"><b>VPDu_quartic</b></font></td><td><font size="+1"><b>VPEu_quartic</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Fourth power</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_quartic( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_quartic( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int VFu_quartic( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFux_quartic( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::quartic( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_quartic( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);
<BR>int vector&lt;T&gt;::u_quartic( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::ux_quartic( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_quartic( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_quartic( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function VFu_quartic( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFux_quartic( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_quartic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_quartic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_quartic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int VFucu_quartic( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFuxcu_quartic( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cudaVFu_quartic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFux_quartic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFux_quartic( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int VFucu_quartic( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFuxcu_quartic( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_quartic( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_quartic( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_quartic( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_quartic( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_quartic( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cudaVFu_quartic( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFux_quartic( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFux_quartic( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFucu_quartic( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFuxcu_quartic( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = X<sub>i</sub> <sup>4</sup>
<BR>expanded versions: Y<sub>i</sub> = (A*X<sub>i</sub>+B) <sup>4</sup>
<BR>The fourth power of the elements of X is stored in Y. 
<BR>The &quot;unprotected&quot; versions (prefix <I>VFu_,&nbsp;&nbsp; VFux_</I>, etc.) do not perform any error handling, which makes them much faster (up to 50%) than the standard versions. The extended-precision complex (<I>VCEu_</I> and <I>VCEux_</I>) versions do not take some of the security measures present in the standard version and might fail for results very near the overflow limit; results near the underflow limit might be rendered as 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#square">VF_square</a>,&nbsp;&nbsp; <a href="#cubic">VF_cubic</a>,&nbsp;&nbsp; <a href="#sqrt">VF_sqrt</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ramp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ramp</b></font></td><td width="34%"><font size="+1"><b>VD_ramp</b></font></td><td><font size="+1"><b>VE_ramp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_ramp</b></font></td><td width="34%"><font size="+1"><b>VCD_ramp</b></font></td><td><font size="+1"><b>VCE_ramp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_ramp</b></font></td><td width="17%"><font size="+1"><b>VBI_ramp</b></font></td><td width="17%"><font size="+1"><b>VSI_ramp</b></font></td><td width="17%"><font size="+1"><b>VLI_ramp</b></font></td><td width="17%"><font size="+1"><b>VQI_ramp</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_ramp</b></font></td><td width="17%"><font size="+1"><b>VUB_ramp</b></font></td><td width="17%"><font size="+1"><b>VUS_ramp</b></font></td><td width="17%"><font size="+1"><b>VUL_ramp</b></font></td><td width="17%"><font size="+1"><b>VUQ_ramp</b></font></td><td><font size="+1"><b>VUI_ramp</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize a vector with an ascending or descending &quot;ramp&quot;.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_ramp( fVector&nbsp;X, ui&nbsp;size, float Start, float Rise&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VCF_,&nbsp;&nbsp; VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">void VU_ramp( uVector&nbsp;X, ui&nbsp;size, unsigned Start, int&nbsp;Rise&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::ramp( T Start, T Rise&nbsp;);
<BR>void vector&lt;unsigned&gt;::ramp( unsigned Start, int&nbsp;Rise&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_ramp( X:fVector; size:UIntSize; Start,&nbsp;Rise:Single&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VCF_,&nbsp;&nbsp; VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">procedure VU_ramp( X:uVector; size:UIntSize; Start:UInt; Rise:Integer&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_,&nbsp;&nbsp; VUQ_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_ramp( fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;Start, float&nbsp;Rise&nbsp;);
<BR>int cusdVF_ramp( fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_Start, float&nbsp;*d_Rise&nbsp;);
<BR>void VFcu_ramp( fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;Start, float&nbsp;Rise&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_ramp( d_X:fVector; size:UIntSize; Start,&nbsp;Rise:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_ramp( d_X:fVector; size:UIntSize; d_Start,&nbsp;d_Rise:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_ramp( h_X:fVector; size:UIntSize; Start,&nbsp;Rise:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = Start + i *&nbsp;Rise
<BR>For the floating-point versions, remember the limited accuracy of floating-point numbers. For example, after calling
<BR><font face="courier new">VF_ramp( F1, 101, -1.0, 0.01&nbsp;);</font>
<BR>the element F1<sub>100</sub> will not be 0.0, as you might wish, but rather something like 2.2E-8. Ths is due to the fact that the number 0.01 (passed as a float to the function) is not exactly representable in the data type float. If that is a problem, consider building the ramp with moderately large integers and dividing by a scaling factor afterwards:
<BR><font face="courier new">VF_ramp( F1, 101, -100.0, 1.0&nbsp;);
<BR><a href="#divC">VF_divC</a>( F1, F1, 101, 100.0&nbsp;);</font>
<P>Note that Rise is defined as int&nbsp;instead of unsigned in the <I>VU_</I> version and as long instead of unsigned long in the <I>VUL_</I> version; this exception from the general rules - that all parameters in one function be of the same data type - allows to create descending ramps of unsigned numbers, which would not be possible otherwise.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Parzen">VF_Parzen</a>,&nbsp;&nbsp; <a href="#Welch">VF_Welch</a>,&nbsp;&nbsp; <a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#random">VF_random</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="random"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_random</b></font></td><td width="34%"><font size="+1"><b>VD_random</b></font></td><td><font size="+1"><b>VE_random</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_random</b></font></td><td width="34%"><font size="+1"><b>VCD_random</b></font></td><td><font size="+1"><b>VCE_random</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_random</b></font></td><td width="17%"><font size="+1"><b>VBI_random</b></font></td><td width="17%"><font size="+1"><b>VSI_random</b></font></td><td width="17%"><font size="+1"><b>VLI_random</b></font></td><td width="17%"><font size="+1"><b>VQI_random</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_random</b></font></td><td width="17%"><font size="+1"><b>VUB_random</b></font></td><td width="17%"><font size="+1"><b>VUS_random</b></font></td><td width="17%"><font size="+1"><b>VUL_random</b></font></td><td width="17%"><font size="+1"><b>VUQ_random</b></font></td><td><font size="+1"><b>VUI_random</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>High-quality random numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>long VF_random( fVector&nbsp;X, ui&nbsp;siz, long&nbsp;seed, float&nbsp;MinVal, float&nbsp;MaxVal&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>long vector&lt;T&gt;::random( long&nbsp;seed, T&nbsp;MinVal, T&nbsp;MaxVal&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_random( X:fVector; size:UIntSize; seed:LongInt; MinVal,&nbsp;MaxVal:Single&nbsp;):&nbsp;LongInt;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_random( fVector&nbsp;d_X, ui&nbsp;siz, long&nbsp;seed, float&nbsp;MinVal, float&nbsp;MaxVal&nbsp;);
<BR>int cusdVF_random( fVector&nbsp;d_X, ui&nbsp;siz, long&nbsp;seed, float&nbsp;*d_MinVal, float&nbsp;*d_MaxVal&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_random( d_X:fVector; size:UIntSize; seed:LongInt; MinVal,&nbsp;MaxVal:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_random( d_X:fVector; size:UIntSize; seed:LongInt; d_MinVal,&nbsp;d_MaxVal:PSingle&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The X vector is filled with a sequence of random numbers. Within the ranges defined by MinVal and MaxVal (and within the restrictions of floating-point representation in the floating-point versions), all numbers are equally probable (including the extreme values themselves), i.e., so-called &quot;uniform deviates&quot; are produced. The parameter seed may be any number. Successive calls to one and the same of these functions will yield identical sequences, if seed is chosen equal; if seed is chosen differently for successive calls, the results will be uncorrelated.
<P>Internally, these functions employ a random number generator by H.W.Lewis. The smaller data types use a 32-bit generator, while the larger types use a 64-bit version. Additional steps (so-called &quot;Bays-Durham shuffle&quot;) are taken to break sequential correlations. This ensures very good randomness. However, as this algorithm is well-known and its state can be inferred from a given series of output numbers, these functions are not suitable for cryptographic applications.
<P>A long value is returned which may be used as new seed for subsequent calls. These calls will, however, not simply continue the series, as the random-number generator will have to run through a new initialization first. If continuity of the series is desired, call <a href="#randomLC">VF_randomLC</a> instead.
<P>The CUDA versions of this function do not return a new seed value, but the usual CUDA error flag.
<BR>There is no <i>VFcu_</i> version of this function, as the random numbers are generated on the CPU anyway.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>last 32-bit random number generated; this may be used as a new seed value for future calls.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I>rand,&nbsp;&nbsp; srand</I> (C/C++ only),&nbsp;&nbsp;<I>random,&nbsp;&nbsp; <a href="#noise">VF_noise</a>,&nbsp;&nbsp; <a href="#randomLC">VF_randomLC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="randomLC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_randomLC</b></font></td><td width="34%"><font size="+1"><b>VD_randomLC</b></font></td><td><font size="+1"><b>VE_randomLC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_randomLC</b></font></td><td width="34%"><font size="+1"><b>VCD_randomLC</b></font></td><td><font size="+1"><b>VCE_randomLC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_randomLC</b></font></td><td width="17%"><font size="+1"><b>VBI_randomLC</b></font></td><td width="17%"><font size="+1"><b>VSI_randomLC</b></font></td><td width="17%"><font size="+1"><b>VLI_randomLC</b></font></td><td width="17%"><font size="+1"><b>VQI_randomLC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_randomLC</b></font></td><td width="17%"><font size="+1"><b>VUB_randomLC</b></font></td><td width="17%"><font size="+1"><b>VUS_randomLC</b></font></td><td width="17%"><font size="+1"><b>VUL_randomLC</b></font></td><td width="17%"><font size="+1"><b>VUQ_randomLC</b></font></td><td><font size="+1"><b>VUI_randomLC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>High-quality random numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_randomLC( fVector&nbsp;X, ui&nbsp;siz, long&nbsp;seed, float&nbsp;MinVal, float&nbsp;MaxVal, V_RANDOMLCSTATE *state&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::randomLC( long seed, T&nbsp;MinVal, T&nbsp;MaxVal, V_RANDOMLCSTATE *state&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_randomLC( X:fVector; size:UIntSize; seed:LongInt; MinVal,&nbsp;MaxVal:Single; state:PV_RANDOMLCSTATE&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_randomLC( fVector&nbsp;d_X, ui&nbsp;siz, long&nbsp;seed, float&nbsp;MinVal, float&nbsp;MaxVal, V_RANDOMLCSTATE&nbsp;*h_state&nbsp;);
<BR>int cusdVF_randomLC( fVector&nbsp;d_X, ui&nbsp;siz, long&nbsp;seed, float&nbsp;*d_MinVal, float&nbsp;*d_MaxVal, V_RANDOMLCSTATE&nbsp;*h_state&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_randomLC( d_X:fVector; size:UIntSize; seed:LongInt; MinVal,&nbsp;MaxVal:Single; h_state:PV_RANDOMLCSTATE&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_randomLC( d_X:fVector; size:UIntSize; seed:LongInt; d_MinVal,&nbsp;d_MaxVal:PSingle; h_state:PV_RANDOMLCSTATE&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The X vector is filled with a sequence of random numbers. Within the ranges defined by MinVal and MaxVal (and within the restrictions of floating-point representation in the floating-point versions), all numbers are equally probable (including the extreme values themselves), i.e., so-called &quot;uniform deviates&quot; are produced. 
<P>If the parameter <i>seed</i> is any non-zero number, the generator is initialized with that seed value and a new series of random numbers is generated. On the other hand, if you wish to continue a previous series, call this function with <i>seed</i>=0 and with the same parameter <i>state</i> as the previous call. Calls to one and the same of these functions will yield identical sequences, if seed is chosen equal; if seed is chosen differently for successive calls, the results will be uncorrelated.
<P>Internally, these functions employ a linear-congruential (hence the "LC" in the function name) random number generator by H.W. Lewis. The smaller data types use a 32-bit generator, while the larger types use a 64-bit version. Additional steps (so-called &quot;Bays-Durham shuffle&quot;) are taken to break sequential correlations. This ensures very good randomness. However, as this algorithm is well-known and its state can be inferred from a given stretch of output numbers, these functions are not suitable for cryptographic applications.
<P>A simplified form of this function is available as  <a href="#random">VF_random</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Example C/C++</td><td><font face="Courier">#include &lt;VFstd.h&gt;
<BR>V_RANDOMLCSTATE MyState;</font>&nbsp;&nbsp;  // Will hold the state of the generator
<BR><font face="Courier">VF_randomLC( X, siz/2, -1111, -1.0, +1.0, &amp;MyState );</font>&nbsp;&nbsp;  // Initialisation by seed != 0 and first half of series
<BR><font face="Courier">VF_randomLC( X, siz-siz/2, 0, -1.0, +1.0, &amp;MyState );</font>&nbsp;&nbsp;  // Continuation of the series by seed = 0
<BR><font face="Courier">VF_randomLC( Y, siz, -1111, -1.0, +1.0, &amp;MyState );</font>&nbsp;&nbsp;  // identical series in Y as in X by choice of identical seed
<BR><font face="Courier">VF_randomLC( Z, siz, 234567, -1.0, +1.0, &amp;MyState );</font>&nbsp;&nbsp;  // different series in Z by choice of different seed
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Beispiel Pascal/Delphi</td><td><font face="Courier">uses VFstd;
<BR>var MyState: V_RANDOMLCSTATE;</font>&nbsp;&nbsp;  { Will hold the state of the generator }
<BR><font face="Courier">VF_randomLC( X, siz div 2, -1111, -1.0, +1.0, @MyState );</font>&nbsp;&nbsp;  { Initialisation by seed != 0 and first half of series }
<BR><font face="Courier">VF_randomLC( X, siz-siz div 2, 0, -1.0, +1.0, @MyState );</font>&nbsp;&nbsp;  { Continuation of the series by seed = 0 }
<BR><font face="Courier">VF_randomLC( Y, siz, -1111, -1.0, +1.0, @MyState );</font>&nbsp;&nbsp;  { identical series in Y as in X by choice of identical seed }
<BR><font face="Courier">VF_randomLC( Z, siz, 234567, -1.0, +1.0, @MyState );</font>&nbsp;&nbsp;  { different series in Z by choice of different seed }
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I>rand,&nbsp;&nbsp; srand</I> (C/C++ only),&nbsp;&nbsp;<I>random,&nbsp;&nbsp; <a href="#noiseLC">VF_noiseLC</a>,&nbsp;&nbsp; <a href="#random">VF_random</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ratinterpol"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ratinterpol</b></font></td><td width="33%"><font size="+1"><b>VD_ratinterpol</b></font></td><td><font size="+1"><b>VE_ratinterpol</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Diagonal-rational interpolation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_ratinterpol( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;sizex, fVector&nbsp;XTab, fVector&nbsp;YTab, ui&nbsp;sizetab, unsigned&nbsp;deg&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::ratinterpol( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;XTab, const&nbsp;vector&lt;T&gt;&amp;&nbsp;YTab, unsigned&nbsp;deg&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_ratinterpol( Y,&nbsp;X:fVector; sizex:UIntSize; XTab,&nbsp;YTab:fVector; sizetab:UIntSize; deg:UInt&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_ratinterpol( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;sizex, fVector&nbsp;d_XTab, fVector&nbsp;d_YTab, ui&nbsp;sizetab, unsigned&nbsp;deg&nbsp;);
<BR>void VFcu_ratinterpol( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;sizex, fVector&nbsp;h_XTab, fVector&nbsp;h_YTab, ui&nbsp;sizetab, unsigned&nbsp;deg&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_ratinterpol( d_Y,&nbsp;d_X:fVector; sizex:UIntSize; d_XTab,&nbsp;d_YTab:fVector; sizetab:UIntSize; deg:UInt&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_ratinterpol( h_Y,&nbsp;h_X:fVector; sizex:UIntSize; h_XTab,&nbsp;h_YTab:fVector; sizetab:UIntSize; deg:UInt&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each of the sizex elements of X, the corresponding element of Y is interpolated from the XTab-YTab value pairs. XTab must be ordered (either ascending or descending). All values of XTab must be distinct; otherwise a division by zero may occur and lead to a program abort. The parameter deg denotes the number of points that will be taken into account for the interpolation. The diagonal rational interpolation scheme by Stoer and Bulirsch is used. The interpolating function is formed by the quotient of two polynomials, the polynomial in the denominator being of the same order (for even deg) or of an order higher by one (for odd deg) than the polynomial of the numerator.
<BR>For table data points with poles, diagonal rational interpolation is superior to polynomial interpolation. On the other hand, even the slightest round-off error may cause rational interpolation to generate a pole where one would not expect one, especially in extrapolation.
<BR>deg must be between 3 and 20.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>A pole (infinity) in the interpolated function is recognized and leads to a SING error with the proposed result being &#177;HUGE_VAL. (Note: the x-value passed to <I>_matherr</I> is the first element of XTab). Trying to use too many elements for the interpolation (deg &gt; 20) leads to an error message &quot;Not possible with more than 20 elements&quot; and to a program abort. If deg is not between 3 and 20, or exceeds <i>sizetab-1</i>, an error message &quot;Invalid parameter(s)&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#polyinterpol">VF_polyinterpol</a>,&nbsp;&nbsp; <a href="#splineinterpol">VF_splineinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="read"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_read</b></font></td><td width="34%"><font size="+1"><b>VD_read</b></font></td><td><font size="+1"><b>VE_read</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_read</b></font></td><td width="34%"><font size="+1"><b>VCD_read</b></font></td><td><font size="+1"><b>VCE_read</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_read</b></font></td><td width="34%"><font size="+1"><b>VPD_read</b></font></td><td><font size="+1"><b>VPE_read</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_read</b></font></td><td width="17%"><font size="+1"><b>VBI_read</b></font></td><td width="17%"><font size="+1"><b>VSI_read</b></font></td><td width="17%"><font size="+1"><b>VLI_read</b></font></td><td width="17%"><font size="+1"><b>VQI_read</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_read</b></font></td><td width="17%"><font size="+1"><b>VUB_read</b></font></td><td width="17%"><font size="+1"><b>VUS_read</b></font></td><td width="17%"><font size="+1"><b>VUL_read</b></font></td><td width="17%"><font size="+1"><b>VUQ_read</b></font></td><td><font size="+1"><b>VUI_read</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reads a vector in ASCII format from a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_read( fVector&nbsp;X, ui&nbsp;size, FILE *stream&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::read( FILE *stream&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_read( X:fVector; size:UIntSize; var Stream:Text&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_read( fVector&nbsp;d_X, ui&nbsp;size, FILE *stream&nbsp;);
<BR>int cudaVF_read_buf( fVector&nbsp;d_X, ui&nbsp;size, FILE *stream, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_read( X:fVector; size:UIntSize; var Stream:FILE&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_read_buf( X:fVector; size:UIntSize; var Stream:FILE; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>size elements are read in ASCII format (up to 80 characters) from stream and stored in X. Normally, this function will be used to import vectors from a program which cannot store numbers in machine format. It can also be used to retrieve vectors previously stored by <I><a href="#write">VF_write</a></I>. For storing and retrieving intermediate results, however, the function pair <I><a href="#store">VF_store</a></I> / <I><a href="#recall">VF_recall</a></I> is to be preferred over <I><a href="#write">VF_write</a></I> / <I>VF_read</I> (see <I><a href="#write">VF_write</a></I>).
<P><u>Complex versions:</u>
<BR>Real und imaginary parts (cartesian complex) or the Mag and Arg parts (polar complex) may, but need not, be enclosed in braces { } or brackets (&nbsp;). However, you must be consequent: Either all or no element may be written with braces or brackets.
<BR>A komma may (but need not) separate the two parts. The imaginary part (cartesian) or the Arg part (polar) must always be explicitly specified, even if it is zero.
<BR>Examples for legal formats are:
<BR>0.3 0.5&nbsp;&nbsp;&nbsp;&nbsp;(neither braces nor separating komma)
<BR>0.3, 0.5&nbsp;&nbsp;&nbsp;&nbsp;(no braces; separating komma)
<BR>{0.3 0.5}&nbsp;&nbsp;&nbsp;&nbsp;(braces; no separating komma)
<BR>(0.3, 0.5)&nbsp;&nbsp;&nbsp;&nbsp;(brackets and separating komma)</td></tr>
<tr valign="TOP">
<td>C/C++ specific:</td><TD>The entries to be read must be separated by whitespace (' ', '\n', or '\t'). Additionally, one (!) &quot;non-whitespace&quot; character is tolerated after each entry, if it follows directly after the last digit. After it, there must be one or more whitespace characters.
<P><u>Whole-number versions</u> except <I>VQI_read</I>:
<BR>By default, the numbers to be read are interpreted as decimal numbers. You may use <I><a href="#setRadix">V_setRadix</a></I> to define any radix between 2 and 36.</td></tr>
<tr valign="TOP">
<td>Pascal/Delphi specific:</td><TD>The entries to be read must be separated by whitespace (' ', #13, or #9).
<P>Whereas the C/C++ version of these functions follows the conventions of the C functions <I>strtod,&nbsp;&nbsp; strtol</I>, etc., the Pascal/Delphi version has to follow the rules applying to the Pascal/Delphi function <I>Read</I>. This makes the Pascal/Delphi version much less flexible than the C version:
<BR>- no separation characters allowed other than ' ' and #9,
<BR>- no automatic truncation of overflowing numbers,
<BR>- no function <I><a href="#setRadix">V_setRadix</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td><u>C/C++:</u>
<BR>Real, complex and quad versions:
<BR>Overflowing numbers are silently truncated to &#177;HUGE_VAL.
<BR>Whole-number versions except <I>VQI_read</I>:
<BR>As long as the numbers can be represented as long or unsigned long, overflowing bits are ignored in the 16-bit versions. Numbers beyond the long range yield -1 (signed types) or +HUGE_VAL (unsigned types).
<BR><u>Pascal/Delphi:</u>
<BR>Overflowing numbers or numbers otherwise not conforming to the format requirements lead to an I/O error.
<P>CUDA versions only: <i>cudaV?_read_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as X. By avoiding the need of <i>cudaV?_read</i> to allocate its own buffer memory, <i>cudaV?_read_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#nread">VF_nread</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; <a href="#recall">VF_recall</a>,&nbsp;&nbsp; strtod,&nbsp;&nbsp; strtol</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="real"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_real</b></font></td><td width="33%"><font size="+1"><b>VCD_real</b></font></td><td><font size="+1"><b>VCE_real</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_real</b></font></td><td width="33%"><font size="+1"><b>VPD_real</b></font></td><td><font size="+1"><b>VPE_real</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Real part of a complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VCF_real( fVector&nbsp;Re, cfVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::real( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_real( Re:fVector; X:cfVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_real( fVector&nbsp;d_Re, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VCFcu_real( fVector&nbsp;h_Re, cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_real( d_Re:fVector; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VCFcu_real( h_Re:fVector; h_X:cfVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Identical to <I><a href="#CtoRe">VF_CtoRe</a>,&nbsp;&nbsp; <a href="#CtoRe">VD_CtoRe</a></I>, and <I><a href="#CtoRe">VE_CtoRe</a></I>. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="recall"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_recall</b></font></td><td width="34%"><font size="+1"><b>VD_recall</b></font></td><td><font size="+1"><b>VE_recall</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_recall</b></font></td><td width="34%"><font size="+1"><b>VCD_recall</b></font></td><td><font size="+1"><b>VCE_recall</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_recall</b></font></td><td width="34%"><font size="+1"><b>VPD_recall</b></font></td><td><font size="+1"><b>VPE_recall</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_recall</b></font></td><td width="17%"><font size="+1"><b>VBI_recall</b></font></td><td width="17%"><font size="+1"><b>VSI_recall</b></font></td><td width="17%"><font size="+1"><b>VLI_recall</b></font></td><td width="17%"><font size="+1"><b>VQI_recall</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_recall</b></font></td><td width="17%"><font size="+1"><b>VUB_recall</b></font></td><td width="17%"><font size="+1"><b>VUS_recall</b></font></td><td width="17%"><font size="+1"><b>VUL_recall</b></font></td><td width="17%"><font size="+1"><b>VUQ_recall</b></font></td><td><font size="+1"><b>VUI_recall</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Read a vector in binary format from a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_recall( fVector&nbsp;X, ui&nbsp;size, FILE *stream&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::recall( FILE *stream&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_recall( X:fVector; size:UIntSize; var Stream:FILE&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_recall( fVector&nbsp;d_X, ui&nbsp;size, FILE *stream&nbsp;);
<BR>int cudaVF_recall_buf( fVector&nbsp;d_X, ui&nbsp;size, FILE *stream, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_recall( X:fVector; size:UIntSize; var Stream:FILE&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_recall_buf( X:fVector; size:UIntSize; var Stream:FILE; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>size</I> elements of X are read from <I>stream</I> in binary format. Normally, these functions are used to retrieve data stored by the respective function of the <I><a href="#store">VF_store</a></I> family. The data type for reading and writing has to be the same. It is not possible to, e.g., store data by <I><a href="#store">VF_store</a></I> and recall them by <I>VD_recall</I> (in contrast to the corresponding write/read functions in ASCII format, see <I><a href="#read">VF_read</a></I>).
<P>The <I>VecObj</I> version differs from the &quot;normal&quot; C/C++ version in that it reads <U>vector objects</U>, not only the vector elements. It first reads a <B>ui</B>, giving the <I>size</I> of the vector, and then <I>size</I> elements, whereas the <I>V?_recall</I> functions assume <I>size</I> as known and take it as an argument. Therefore, the <I>VecObj</I> function <I>recall</I> can be used only to read vector objects previously stored with the <I><U>VecObj</U></I> function <I>store</I>, but not vectors stored with one of the <I>V?_store</I> functions.
<P>CUDA versions only: <i>cudaV?_recall_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as X. By avoiding the need of <i>cudaV?_recall</i> to allocate its own buffer memory, <i>cudaV?_recall_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#store">VF_store</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#print">VF_print</a>,&nbsp;&nbsp; fwrite,&nbsp;&nbsp; fread</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="redC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_redC</b></font></td><td width="33%"><font size="+1"><b>VD_redC</b></font></td><td><font size="+1"><b>VE_redC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Reduce&quot; by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_redC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::redC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_redC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVDmath.h&gt;
<BR>int cudaVF_redC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_redC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_redC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VDmath;
<BR>function cudaVF_redC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_redC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VF_redC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = red( X<sub>i</sub>, C&nbsp;) = X<sub>i</sub> *&nbsp;C / (X<sub>i</sub> + C)
<BR>Expressions of this type are frequently used in physics; for example, the &quot;reduced mass&quot; of a two-body system is the product of both masses divided by their sum.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#redV">VF_redV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="redV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_redV</b></font></td><td width="33%"><font size="+1"><b>VD_redV</b></font></td><td><font size="+1"><b>VE_redV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_redV</b></font></td><td width="33%"><font size="+1"><b>VDx_redV</b></font></td><td><font size="+1"><b>VEx_redV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Reduce&quot; by corresponding vector elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_redV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VFx_redV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::redV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::x_redV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_redV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFx_redV( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_redV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVFx_redV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_redV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>void VFcu_redV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFxcu_redV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_redV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_redV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_redV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_redV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFxcu_redV( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions:
<BR>Z<sub>i</sub> = red( X<sub>i</sub>, Y<sub>i</sub>&nbsp;) = X<sub>i</sub> *&nbsp;Y<sub>i</sub> / (X<sub>i</sub> + Y<sub>i</sub>)
<BR>expanded versions: 
<BR>xi = (A *&nbsp;X<sub>i</sub> + B),
<BR>Z<sub>i</sub> = red( xi, Y<sub>i</sub>&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#redC">VF_redC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="reflect"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_reflect</b></font></td><td width="34%"><font size="+1"><b>VD_reflect</b></font></td><td><font size="+1"><b>VE_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_reflect</b></font></td><td width="34%"><font size="+1"><b>VCD_reflect</b></font></td><td><font size="+1"><b>VCE_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_reflect</b></font></td><td width="34%"><font size="+1"><b>VPD_reflect</b></font></td><td><font size="+1"><b>VPE_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_reflect</b></font></td><td width="17%"><font size="+1"><b>VBI_reflect</b></font></td><td width="17%"><font size="+1"><b>VSI_reflect</b></font></td><td width="17%"><font size="+1"><b>VLI_reflect</b></font></td><td width="17%"><font size="+1"><b>VQI_reflect</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_reflect</b></font></td><td width="17%"><font size="+1"><b>VUB_reflect</b></font></td><td width="17%"><font size="+1"><b>VUS_reflect</b></font></td><td width="17%"><font size="+1"><b>VUL_reflect</b></font></td><td width="17%"><font size="+1"><b>VUQ_reflect</b></font></td><td><font size="+1"><b>VUI_reflect</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Derive the second half of a vector from the first half by reflection at the midpoint.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_reflect( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::reflect();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_reflect( X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_reflect( fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_reflect( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_reflect( d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_reflect( h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>size-i-1</sub> = X<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...,(size-1)/2
<BR>The elements of the lower half of a vector are copied in reverse order into the upper half, i.e., the zero'th element is copied to the last, the element number 1 to the second last, and so on. The elements of the first half are not affected by this operation. This function will be used, e.g., to construct a response function for convolutions (see <I><a href="#convolve">VF_convolve</a></I>). In this case, note that the zero'th element is to appear only once in the response function and must not be included in the reflection by <I>VF_reflect</I>. Therefore, you have to calculate the response function for size/2+1 elements and to apply reflection from element 1 on. For an example, see <I><a href="#convolve">VF_convolve</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#rotate">VF_rotate</a>,&nbsp;&nbsp; <a href="#rev">VF_rev</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#deconvolve">VF_deconvolve</a>,&nbsp;&nbsp; <a href="#filter">VF_filter</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ReImtoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ReImtoC</b></font></td><td width="33%"><font size="+1"><b>VD_ReImtoC</b></font></td><td><font size="+1"><b>VE_ReImtoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct a cartesian complex vector from real and imaginary parts</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_ReImtoC( cfVector&nbsp;Y, fVector&nbsp;Re, fVector&nbsp;Im, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::ReImtoC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Re, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Im&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_ReImtoC( X:cfVector; Re,&nbsp;Im:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVF_ReImtoC( cfVector&nbsp;Y, fVector&nbsp;d_Re, fVector&nbsp;d_Im, ui&nbsp;size&nbsp;);
<BR>void VFcu_ReImtoC( cfVector&nbsp;Y, fVector&nbsp;h_Re, fVector&nbsp;h_Im, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVF_ReImtoC( d_X:cfVector; d_Re,&nbsp;d_Im:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_ReImtoC( h_X:cfVector; h_Re,&nbsp;h_Im:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The complex vector Y is constructed from two real vectors that become the real and imaginary parts of Y.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#RetoC">VF_RetoC</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ReImtoP"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ReImtoP</b></font></td><td width="33%"><font size="+1"><b>VD_ReImtoP</b></font></td><td><font size="+1"><b>VE_ReImtoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct a polar complex vector from real and imaginary parts</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_ReImtoP( pfVector&nbsp;Y, fVector&nbsp;Re, fVector&nbsp;Im, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::ReImtoP( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Re, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Im&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_ReImtoP( X:pfVector; Re,&nbsp;Im:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVPFstd.h&gt;
<BR>int cudaVF_ReImtoP( pfVector&nbsp;Y, fVector&nbsp;d_Re, fVector&nbsp;d_Im, ui&nbsp;size&nbsp;);
<BR>void VFcu_ReImtoP( pfVector&nbsp;Y, fVector&nbsp;h_Re, fVector&nbsp;h_Im, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>function cudaVF_ReImtoP( d_X:pfVector; d_Re,&nbsp;d_Im:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_ReImtoP( h_X:pfVector; h_Re,&nbsp;h_Im:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar complex vector Y is constructed from cartesian coordinates entered as the two real vectors Re and Im.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoReIm">VF_PtoReIm</a>,&nbsp;&nbsp; <a href="#MagArgtoP">VF_MagArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="RetoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_RetoC</b></font></td><td width="33%"><font size="+1"><b>VD_RetoC</b></font></td><td><font size="+1"><b>VE_RetoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Overwrite the real part of a cartesian complex vector with a real vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_RetoC( cfVector&nbsp;Y, fVector&nbsp;Re, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::RetoC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Re&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_RetoC( X:cfVector; Re:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVF_RetoC( cfVector&nbsp;d_Y, fVector&nbsp;d_Im, ui&nbsp;size&nbsp;);
<BR>void VFcu_RetoC( cfVector&nbsp;h_Y, fVector&nbsp;h_Im, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVF_RetoC( d_X:cfVector; d_Im:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_RetoC( h_X:cfVector; h_Im:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The real part of the complex vector Y is overwritten with the elements of the real-valued vector Re. The imaginary part of Y is not affected.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#ImtoC">VF_ImtoC</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="rev"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_rev</b></font></td><td width="34%"><font size="+1"><b>VD_rev</b></font></td><td><font size="+1"><b>VE_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_rev</b></font></td><td width="34%"><font size="+1"><b>VCD_rev</b></font></td><td><font size="+1"><b>VCE_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_rev</b></font></td><td width="34%"><font size="+1"><b>VPD_rev</b></font></td><td><font size="+1"><b>VPE_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_rev</b></font></td><td width="17%"><font size="+1"><b>VBI_rev</b></font></td><td width="17%"><font size="+1"><b>VSI_rev</b></font></td><td width="17%"><font size="+1"><b>VLI_rev</b></font></td><td width="17%"><font size="+1"><b>VQI_rev</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_rev</b></font></td><td width="17%"><font size="+1"><b>VUB_rev</b></font></td><td width="17%"><font size="+1"><b>VUS_rev</b></font></td><td width="17%"><font size="+1"><b>VUL_rev</b></font></td><td width="17%"><font size="+1"><b>VUQ_rev</b></font></td><td><font size="+1"><b>VUI_rev</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse the ordering of the elements of a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_rev( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::rev( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_rev( Y,&nbsp;X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_rev( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VF_rev( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_rev( d_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_rev( h_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>size-i-1</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#reflect">VF_reflect</a>,&nbsp;&nbsp; <a href="#rotate">VF_rotate</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="rms"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_rms</b></font></td><td width="33%"><font size="+1"><b>VD_rms</b></font></td><td><font size="+1"><b>VE_rms</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Root of the mean square</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_rms( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::rms();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_rms( X:fVector; size:UIntSize&nbsp;); Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_rms( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_rms( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_rms( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_rms( var&nbsp;h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_rms( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_rms( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>rms = sqrt( (1/size) *&nbsp;sum( X<sub>i</sub><sup>2</sup>&nbsp;)&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>rms</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#Euclid">VF_Euclid</a>,&nbsp;&nbsp; <a href="#mean">VF_mean</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="rotate"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_rotate</b></font></td><td width="34%"><font size="+1"><b>VD_rotate</b></font></td><td><font size="+1"><b>VE_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_rotate</b></font></td><td width="34%"><font size="+1"><b>VCD_rotate</b></font></td><td><font size="+1"><b>VCE_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_rotate</b></font></td><td width="34%"><font size="+1"><b>VPD_rotate</b></font></td><td><font size="+1"><b>VPE_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_rotate</b></font></td><td width="17%"><font size="+1"><b>VBI_rotate</b></font></td><td width="17%"><font size="+1"><b>VSI_rotate</b></font></td><td width="17%"><font size="+1"><b>VLI_rotate</b></font></td><td width="17%"><font size="+1"><b>VQI_rotate</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_rotate</b></font></td><td width="17%"><font size="+1"><b>VUB_rotate</b></font></td><td width="17%"><font size="+1"><b>VUS_rotate</b></font></td><td width="17%"><font size="+1"><b>VUL_rotate</b></font></td><td width="17%"><font size="+1"><b>VUQ_rotate</b></font></td><td><font size="+1"><b>VUI_rotate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Rotate the ordering of the elements of a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_rotate( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::rotate( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, int&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_rotate( Y,&nbsp;X:fVector; size:UIntSize; pos:Integer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_rotate( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;pos&nbsp;);
<BR>void VFcu_rotate( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, int&nbsp;pos&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_rotate( d_Y,&nbsp;d_X:fVector; size:UIntSize; pos:Integer&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_rotate( h_Y,&nbsp;h_X:fVector; size:UIntSize; pos:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>size-pos+i</sub>,&nbsp;&nbsp;&nbsp;i=0,..,pos-1
<BR>Y<sub>i</sub> = X<sub>i-pos</sub>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=pos,..,size-1
<BR>The output vector equals the rotated input vector. Clockwise rotation is achieved by a positive number pos.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#reflect">VF_reflect</a>,&nbsp;&nbsp; <a href="#rev">VF_rev</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="rotate_buf"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_rotate_buf</b></font></td><td width="34%"><font size="+1"><b>VD_rotate_buf</b></font></td><td><font size="+1"><b>VE_rotate_buf</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_rotate_buf</b></font></td><td width="34%"><font size="+1"><b>VCD_rotate_buf</b></font></td><td><font size="+1"><b>VCE_rotate_buf</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_rotate_buf</b></font></td><td width="34%"><font size="+1"><b>VPD_rotate_buf</b></font></td><td><font size="+1"><b>VPE_rotate_buf</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_rotate_buf</b></font></td><td width="17%"><font size="+1"><b>VBI_rotate_buf</b></font></td><td width="17%"><font size="+1"><b>VSI_rotate_buf</b></font></td><td width="17%"><font size="+1"><b>VLI_rotate_buf</b></font></td><td width="17%"><font size="+1"><b>VQI_rotate_buf</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_rotate_buf</b></font></td><td width="17%"><font size="+1"><b>VUB_rotate_buf</b></font></td><td width="17%"><font size="+1"><b>VUS_rotate_buf</b></font></td><td width="17%"><font size="+1"><b>VUL_rotate_buf</b></font></td><td width="17%"><font size="+1"><b>VUQ_rotate_buf</b></font></td><td><font size="+1"><b>VUI_rotate_buf</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Rotate the ordering of the elements of a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_rotate_buf( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;pos, fVector&nbsp;Buf&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::rotate( const&nbsp;vector&lt;T&gt;&nbsp;X, int&nbsp;pos, const&nbsp;vector&lt;T&gt;&nbsp;Buf&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_rotate_buf( Y,&nbsp;X:fVector; size:UIntSize; pos:Integer; Buf:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_rotate_buf( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;pos, fVector&nbsp;d_Buf&nbsp;);
<BR>void VFcu_rotate_buf( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, int&nbsp;pos, fVector&nbsp;h_Buf&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_rotate_buf( d_Y,&nbsp;d_X:fVector; size:UIntSize; pos:Integer; d_Buf:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_rotate_buf( h_Y,&nbsp;h_X:fVector; size:UIntSize; pos:Integer; h_Buf:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>size-pos+i</sub>,&nbsp;&nbsp;&nbsp;i=0,..,pos-1
<BR>Y<sub>i</sub> = X<sub>i-pos</sub>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=pos,..,size-1
<BR>This is a more efficient variant of <I><a href="#rotate">VF_rotate</a></I>. Instead of allocating buffer memory each time the function is called, it takes the necessary buffer as the argument Buf. Buf must be a vector generated by the <i>OptiVec</i> memory management function (<I><a href="#vector">VF_vector</a></I> etc.). The size of Buf must be greater or equal to the shift, <i>pos</i>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#rotate">VF_rotate</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="rotateCoordinates"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_rotateCoordinates</b></font></td><td width="33%"><font size="+1"><b>VD_rotateCoordinates</b></font></td><td><font size="+1"><b>VE_rotateCoordinates</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_rotateCoordinates</b></font></td><td width="33%"><font size="+1"><b>VCD_rotateCoordinates</b></font></td><td><font size="+1"><b>VCE_rotateCoordinates</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Counter-clockwise rotation of cartesian coordinates</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_rotateCoordinates( fVector&nbsp;Xrot, fVector&nbsp;Yrot, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;costheta, float&nbsp;sintheta&nbsp;);
<BR><BR>void VCF_rotateCoordinates( cfVector&nbsp;XYrot, cfVector&nbsp;XY, ui&nbsp;size, float&nbsp;costheta, float&nbsp;sintheta&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::rotateCoordinates( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Yrot, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X,const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, T&nbsp;costheta, T&nbsp;sintheta&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&nbsp;&gt;::rotateCoordinates( const&nbsp;vector&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;XY, T&nbsp;costheta, T&nbsp;sintheta&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_rotateCoordinates( Xrot, Yrot, X,&nbsp;Y:fVector; size:UIntSize; costheta, sintheta:Single&nbsp;);
<BR><BR>procedure VCF_rotateCoordinates( XYrot, XY:cfVector; size:UIntSize; costheta, sintheta:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>void cudaVF_rotateCoordinates( fVector&nbsp;d_Xrot, fVector&nbsp;d_Yrot, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;costheta, float&nbsp;sintheta&nbsp;);
<BR>void cusdVF_rotateCoordinates( fVector&nbsp;d_Xrot, fVector&nbsp;d_Yrot, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_costheta, float&nbsp;*d_sintheta&nbsp;);
<BR>void cudaVCF_rotateCoordinates( cfVector&nbsp;d_XYrot, cfVector&nbsp;d_XY, ui&nbsp;size, float&nbsp;costheta, float&nbsp;sintheta&nbsp;);
<BR>void cusdVCF_rotateCoordinates( cfVector&nbsp;d_XYrot, cfVector&nbsp;d_XY, ui&nbsp;size, float&nbsp;*d_costheta, float&nbsp;*d_sintheta&nbsp;);
<BR>void VFcu_rotateCoordinates( fVector&nbsp;h_Xrot, fVector&nbsp;h_Yrot, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;costheta, float&nbsp;sintheta&nbsp;);
<BR>void VCFcu_rotateCoordinates( cfVector&nbsp;h_XYrot, cfVector&nbsp;h_XY, ui&nbsp;size, float&nbsp;costheta, float&nbsp;sintheta&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure cudaVF_rotateCoordinates( d_Xrot, d_Yrot, d_X,&nbsp;d_Y:fVector; size:UIntSize; costheta,&nbsp;sintheta:Single&nbsp;);
<BR>procedure cusdVF_rotateCoordinates( d_Xrot, d_Yrot, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_costheta,&nbsp;d_sintheta:Single&nbsp;);
<BR>procedure cudaVCF_rotateCoordinates( d_XYrot, d_XY:cfVector; size:UIntSize; costheta,&nbsp;sintheta:Single&nbsp;);
<BR>procedure cusdVCF_rotateCoordinates( d_XYrot, d_XY:cfVector; size:UIntSize; d_costheta,&nbsp;d_sintheta:Single&nbsp;);
<BR>procedure VFcu_rotateCoordinates( h_Xrot, h_Yrot, h_X, h_Y:fVector; size:UIntSize; costheta,&nbsp;sintheta:Single&nbsp;);
<BR>procedure VCFcu_rotateCoordinates( h_XYrot, h_XY:cfVector; size:UIntSize; costheta,&nbsp;sintheta:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The coordinates specified either in the real vector pair X,Y or in the complex vector XY are rotated counter-clockwise by the angle theta, specified as its cosine and sine, <I>costheta</I> and <I>sintheta</I>:<BR>
Xrot<sub>i</sub> = cos(theta) *&nbsp;X<sub>i</sub> - sin(theta) *&nbsp;Y<sub>i</sub>,<BR>
Yrot<sub>i</sub> = sin(theta) *&nbsp;X<sub>i</sub> + cos(theta) *&nbsp;Y<sub>i</sub>
<P>The result can be scaled by a constant factor: Just multiply the arguments <I>costheta</I> and <I>sintheta</I> by the desired scaling factor. <I>costheta</I> and <I>sintheta</I> need not actually correspond to any real angle.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#lincomb">VF_lincomb</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="round"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_round</b></font></td><td width="33%"><font size="+1"><b>VD_round</b></font></td><td><font size="+1"><b>VE_round</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoI</b></font></td><td><font size="+1"><b>VE_roundtoI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoBI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoBI</b></font></td><td><font size="+1"><b>VE_roundtoBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoSI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoSI</b></font></td><td><font size="+1"><b>VE_roundtoSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoLI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoLI</b></font></td><td><font size="+1"><b>VE_roundtoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoQI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoQI</b></font></td><td><font size="+1"><b>VE_roundtoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoU</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoU</b></font></td><td><font size="+1"><b>VE_roundtoU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoUB</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoUB</b></font></td><td><font size="+1"><b>VE_roundtoUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoUS</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoUS</b></font></td><td><font size="+1"><b>VE_roundtoUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoUL</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoUL</b></font></td><td><font size="+1"><b>VE_roundtoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoUQ</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoUQ</b></font></td><td><font size="+1"><b>VE_roundtoUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoUI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoUI</b></font></td><td><font size="+1"><b>VE_roundtoUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Rounding to the nearest whole number.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_round( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VF_roundtoI( iVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VF_roundtoLI( liVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::round( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;int&gt;::roundtoI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;long&gt;::roundtoLI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_round( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VF_roundtoI( Y:iVector; X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VF_roundtoLI( Y:liVector; X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_round( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVF_roundtoI( iVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_round( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_roundtoI( iVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_round( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_roundtoI( d_Y:iVector; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_round( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_roundtoI( h_Y:iVector; h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is rounded to the nearest integer value. In case of a fractional part of exactly 0.5, the nearest even integer value is chosen and stored in Y. For example, 2.5 is rounded to 2, and 3.5 is rounded to 4.
<BR>The functions <I>VF_roundtoI,&nbsp;&nbsp; VF_roundtoLI,&nbsp;&nbsp; VF_roundtoU</I>, etc. convert the result into the various integer data types.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW and DOMAIN errors are handled "silently", i.e., without any error message and without being indicated by the return value. In the case of OVERFLOW errors, the result is set to the extreme value possible. Negative numbers in the versions <I>VF_roundtoU,&nbsp;&nbsp; VF_roundtoUB,&nbsp;&nbsp; VF_roundtoUS,&nbsp;&nbsp; VF_roundtoUL</I>, and <I>VF_roundtoUI</I> (which would lead to DOMAIN errors) are handled by setting the result to 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ceil">VF_ceil</a>,&nbsp;&nbsp; <a href="#floor">VF_floor</a>,&nbsp;&nbsp; <a href="#chop">VF_chop</a>,&nbsp;&nbsp; <a href="#trunc">VF_trunc</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runintegralC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runintegralC</b></font></td><td width="33%"><font size="+1"><b>VD_runintegralC</b></font></td><td><font size="+1"><b>VE_runintegralC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running integral&quot; of an array sampled at equally-spaced abscissa points.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_runintegralC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float DeltaT&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runintegralC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, T DeltaT&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_runintegralC( Y,&nbsp;X:fVector; size:UIntSize; DeltaT:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_runintegralC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;DeltaT&nbsp;);
<BR>int cusdVF_runintegralC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_DeltaT&nbsp;);
<BR>void VFcu_runintegralC( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;DeltaT&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_runintegralC( d_Y,&nbsp;d_X:fVector; size:UIntSize; DeltaT:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_runintegralC( d_Y,&nbsp;d_X:fVector; size:UIntSize; d_DeltaT:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_runintegralC( h_Y,&nbsp;h_X:fVector; size:UIntSize; DeltaT:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is assumed to be a function of a variable t; the t values themselves are equally spaced. Therefore, only their spacing, DeltaT, must be known to the function. Each element of Y is the integral of all elements of X up to and including the one with the same index. Thus, the last element of Y contains the value of the integral over the whole of X (the area under X). If only this value is of interest, <I><a href="#integralC">VF_integralC</a></I> should be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#runintegralV">VF_runintegralV</a>,&nbsp;&nbsp; <a href="#integralC">VF_integralC</a>,&nbsp;&nbsp; <a href="#derivC">VF_derivC</a>,&nbsp;&nbsp; <a href="#runsum">VF_runsum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runintegralV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runintegralV</b></font></td><td width="33%"><font size="+1"><b>VD_runintegralV</b></font></td><td><font size="+1"><b>VE_runintegralV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running integral&quot;</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_runintegralV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runintegralV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_runintegralV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_runintegralV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>void VFcu_runintegralV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_runintegralV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFcu_runintegralV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y is a function of the variable x which is represented by X. Each element of Z is the integral over all elements of Y up to and including the one with the same index. The first element of Z is always FALSE (0).0. The last element of Z is equal to the value of the integral, i.e. to the area under Y. If only this value of the integral is of interest, <I><a href="#integralV">VF_integralV</a></I> should be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#runintegralC">VF_runintegralC</a>,&nbsp;&nbsp; <a href="#integralV">VF_integralV</a>,&nbsp;&nbsp; <a href="#derivV">VF_derivV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runmax"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runmax</b></font></td><td width="34%"><font size="+1"><b>VD_runmax</b></font></td><td><font size="+1"><b>VE_runmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_runmax</b></font></td><td width="17%"><font size="+1"><b>VBI_runmax</b></font></td><td width="17%"><font size="+1"><b>VSI_runmax</b></font></td><td width="17%"><font size="+1"><b>VLI_runmax</b></font></td><td width="17%"><font size="+1"><b>VQI_runmax</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_runmax</b></font></td><td width="17%"><font size="+1"><b>VUB_runmax</b></font></td><td width="17%"><font size="+1"><b>VUS_runmax</b></font></td><td width="17%"><font size="+1"><b>VUL_runmax</b></font></td><td width="17%"><font size="+1"><b>VUQ_runmax</b></font></td><td><font size="+1"><b>VUI_runmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running&quot; maximum.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_runmax( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runmax( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_runmax( Y,&nbsp;X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_runmax( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_runmax( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_runmax( d_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;);
<BR>procedure VFcu_runmax( h_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of Y is the maximum of the corresponding and all preceding elements of X.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#runmin">VF_runmin</a>,&nbsp;&nbsp; <a href="#runsum">VF_runsum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runmin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runmin</b></font></td><td width="34%"><font size="+1"><b>VD_runmin</b></font></td><td><font size="+1"><b>VE_runmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_runmin</b></font></td><td width="17%"><font size="+1"><b>VBI_runmin</b></font></td><td width="17%"><font size="+1"><b>VSI_runmin</b></font></td><td width="17%"><font size="+1"><b>VLI_runmin</b></font></td><td width="17%"><font size="+1"><b>VQI_runmin</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_runmin</b></font></td><td width="17%"><font size="+1"><b>VUB_runmin</b></font></td><td width="17%"><font size="+1"><b>VUS_runmin</b></font></td><td width="17%"><font size="+1"><b>VUL_runmin</b></font></td><td width="17%"><font size="+1"><b>VUQ_runmin</b></font></td><td><font size="+1"><b>VUI_runmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running&quot; minimum</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_runmin( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runmin( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_runmin( Y,&nbsp;X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_runmin( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_runmin( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_runmin( d_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;);
<BR>procedure VFcu_runmin( h_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of Y is the minimum of the corresponding and all preceding elements of X.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#runmax">VF_runmax</a>,&nbsp;&nbsp; <a href="#runsum">VF_runsum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runprod"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runprod</b></font></td><td width="33%"><font size="+1"><b>VD_runprod</b></font></td><td><font size="+1"><b>VE_runprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_runprod</b></font></td><td width="33%"><font size="+1"><b>VCD_runprod</b></font></td><td><font size="+1"><b>VCE_runprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_runprod</b></font></td><td width="33%"><font size="+1"><b>VPD_runprod</b></font></td><td><font size="+1"><b>VPE_runprod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running&quot; product</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_runprod( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runprod( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_runprod( Y,&nbsp;X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_runprod( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_runprod( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_runprod( d_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;);
<BR>procedure VFcu_runprod( h_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of Y is the product of the corresponding and all preceding elements of X. This function should be used with care: overflow is easily reached, and underflow may lead to all elements from a certain position on being zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#prod">VF_prod</a>,&nbsp;&nbsp; <a href="#runsum">VF_runsum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runsum"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runsum</b></font></td><td width="34%"><font size="+1"><b>VD_runsum</b></font></td><td><font size="+1"><b>VE_runsum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_runsum</b></font></td><td width="34%"><font size="+1"><b>VCD_runsum</b></font></td><td><font size="+1"><b>VCE_runsum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_runsum</b></font></td><td width="17%"><font size="+1"><b>VBI_runsum</b></font></td><td width="17%"><font size="+1"><b>VSI_runsum</b></font></td><td width="17%"><font size="+1"><b>VLI_runsum</b></font></td><td width="17%"><font size="+1"><b>VQI_runsum</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_runsum</b></font></td><td width="17%"><font size="+1"><b>VUB_runsum</b></font></td><td width="17%"><font size="+1"><b>VUS_runsum</b></font></td><td width="17%"><font size="+1"><b>VUL_runsum</b></font></td><td width="17%"><font size="+1"><b>VUQ_runsum</b></font></td><td><font size="+1"><b>VUI_runsum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running&quot; sum, also called "cumulative sum" or "inclusive sum-scan"</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_runsum( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runsum( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_runsum( Y,&nbsp;X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_runsum( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_runsum( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_runsum( d_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;);
<BR>procedure VFcu_runsum( h_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of Y is the sum of the corresponding and all preceding elements of X.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but be careful: this function may easily overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#runprod">VF_runprod</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sabsmax"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sabsmax</b></font></td><td width="33%"><font size="+1"><b>VCD_sabsmax</b></font></td><td><font size="+1"><b>VCE_sabsmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Largest complex vector element in terms of the sum |Re|&nbsp;+&nbsp;|Im|</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_sabsmax( cfVector&nbsp;X, ui&nbsp;size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;complex&lt;T&gt;&gt;::sabsmax();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function VCF_sabsmax( X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
<BR>Alternative syntax (obsolete, but still supported):<font face="courier new">
<BR>procedure VCF_sabsmax( var RetVal:fComplex; X:cfVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_sabsmax( fComplex *h_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVCF_sabsmax( fComplex *d_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>fComplex VCFcu_sabsmax( cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_sabsmax( var h_RetVal:fComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVCF_sabsmax( d_RetVal:PfComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VCFcu_sabsmax( h_X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>By the criterion of the sum |Re|&nbsp;+&nbsp;|Im|, the largest element of a cartesian complex vector is found and returned. In many applications, this function may serve as a much faster replacement for <I><a href="#cabsmax">VCF_cabsmax</a></I>. The latter function uses the absolute value, <I>sqrt</I>(Re<sup>2</sup>&nbsp;+&nbsp;Im<sup>2</sup>), as its criterion.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>largest element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#absmax">VCF_absmax</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a>,&nbsp;&nbsp; <a href="#cabsmax">VCF_cabsmax</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sabsmin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sabsmin</b></font></td><td width="33%"><font size="+1"><b>VCD_sabsmin</b></font></td><td><font size="+1"><b>VCE_sabsmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Smallest complex vector element in terms of the sum |Re|&nbsp;+&nbsp;|Im|</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_sabsmin( cfVector&nbsp;X, ui&nbsp;size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;complex&lt;T&gt;&gt;::sabsmin();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function VCF_sabsmin( X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
<BR>Alternative syntax (obsolete, but still supported):<font face="courier new">
<BR>procedure VCF_sabsmin( var RetVal:fComplex; X:cfVector; size:UIntSize&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVCFstd.h&gt;
<BR>int cudaVCF_sabsmin( fComplex *h_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVCF_sabsmin( fComplex *d_RetVal, cfVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>fComplex VCFcu_sabsmin( cfVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>function cudaVCF_sabsmin( var h_RetVal:fComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVCF_sabsmin( d_RetVal:PfComplex; d_X:cfVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VCFcu_sabsmin( h_X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>By the criterion of the sum |Re|&nbsp;+&nbsp;|Im|, the smallest element of a cartesian complex vector is found and returned. In many applications, this function may serve as a much faster replacement for <I><a href="#cabsmin">VCF_cabsmin</a></I>. The latter function uses the absolute value, <I>sqrt</I>(Re<sup>2</sup>&nbsp;+&nbsp;Im<sup>2</sup>), as its criterion.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>smallest element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#absmin">VCF_absmin</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a>,&nbsp;&nbsp; <a href="#cabsmin">VCF_cabsmin</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="scale10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_scale10</b></font></td><td width="33%"><font size="+1"><b>VD_scale10</b></font></td><td><font size="+1"><b>VE_scale10</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Scaling by an integer power of 10.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_scale10( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;Expo&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::scale10( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, int&nbsp;Expo&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_scale10( Y,&nbsp;X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_scale10( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;Expo&nbsp;);
<BR>int VFcu_scale10( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, int&nbsp;Expo&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_scale10( d_Y,&nbsp;d_X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_scale10( h_Y,&nbsp;h_X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> *&nbsp;(10 <sup>Expo</sup>)
<BR>Note that higher powers of ten are not representable as exact numbers, which may lead to the introduction of round-off error by the scaling. If this is a problem, <I><a href="#scale2">VF_scale2</a></I> should be used instead.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#scale2">VF_scale2</a>,&nbsp;&nbsp; <a href="#mantexp">VF_mantexp</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="scale2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_scale2</b></font></td><td width="33%"><font size="+1"><b>VD_scale2</b></font></td><td><font size="+1"><b>VE_scale2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Scaling by an integer power of 2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_scale2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;Expo&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::scale2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, int&nbsp;Expo&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_scale2( Y,&nbsp;X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_scale2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;Expo&nbsp;);
<BR>int VFcu_scale2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, int&nbsp;Expo&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_scale2( d_Y,&nbsp;d_X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_scale2( h_Y,&nbsp;h_X:fVector; size:UIntSize; Expo:Integer&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> *&nbsp;(2 <sup>Expo</sup>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#scale10">VF_scale10</a>,&nbsp;&nbsp; <a href="#mantexp">VF_mantexp</a>,&nbsp;&nbsp; ldexp</I> (C/C++)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="scalprod"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_scalprod</b></font></td><td width="33%"><font size="+1"><b>VD_scalprod</b></font></td><td><font size="+1"><b>VE_scalprod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Scalar product of two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_scalprod( fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::scalprod( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_scalprod( X,&nbsp;Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_scalprod( float&nbsp;*h_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>int cusdVF_scalprod( float&nbsp;*d_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>float VFcu_scalprod( fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_scalprod( var&nbsp;h_RetVal:Single; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_scalprod( d_RetVal:PSingle; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_scalprod( h_X,&nbsp;h_Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>scalprod = sum( X<sub>i</sub> *&nbsp;Y<sub>i</sub>&nbsp;)
<BR>The scalar (or dot) product of two vectors is defined as the sum of the products of the corresponding elements. The scalar product of a vector with itself is the square of its magnitude and may be calculated using the function <I><a href="#ssq">VF_ssq</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>product</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#prod">VF_prod</a>,&nbsp;&nbsp; <a href="#xprod">VF_xprod</a>,&nbsp;&nbsp; <a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="searchC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_searchC</b></font></td><td width="33%"><font size="+1"><b>VD_searchC</b></font></td><td><font size="+1"><b>VE_searchC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Binary searches of an ordered table for the entry coming closest to a specified value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>ui VF_searchC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C, int&nbsp;mode&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;T&gt;::searchC( const&nbsp;T&amp;&nbsp;C, int&nbsp;mode&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_searchC( X:fVector; size:UIntSize; C:Single; mode:Integer&nbsp;):UIntSize;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_searchC( ui&nbsp;*h_Ind, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C, int&nbsp;mode&nbsp;);
<BR>int cusdVF_searchC( ui&nbsp;*d_Ind, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C, int&nbsp;mode&nbsp;);
<BR>ui VFcu_searchC( fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;C, int&nbsp;mode&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_searchC( d_X:fVector; size:UIntSize; C:Single; mode:Integer&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_searchC( d_X:fVector; size:UIntSize; d_C:PSingle; mode:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_searchC( h_X:fVector; size:UIntSize; C:Single; mode:Integer&nbsp;):UIntSize;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>In a binary search, the element of X is located that is closest to the value specified as C. X has to be an ordered table (either ascending or descending); if this condition is not fulfilled, the result will be wrong. If C is outside the range covered by X, the first or the last element of X is chosen, whichever is closer to C. If C is within the range of the table, three modes of the search are available:
<TABLE BORDER WIDTH="100%">
<TR><TD width="15%">mode = +1:</TD><TD>find the next element greater than or equal to C</TD></TR>
<TR valign="top"><TD>mode = &nbsp;&nbsp;0:</TD><TD>find the element closest to C; if two elements are within equal distance, choose the lower index</TD></TR>
<TR><TD>mode = &nbsp;-1:</TD><TD>find the next element less than or equal to C</TD></TR>
</table></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>index of the element found.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#searchV">VF_searchV</a>,&nbsp;&nbsp; <a href="#sort">VF_sort</a>,&nbsp;&nbsp; <a href="#polyinterpol">VF_polyinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="searchV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_searchV</b></font></td><td width="33%"><font size="+1"><b>VD_searchV</b></font></td><td><font size="+1"><b>VE_searchV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Binary search of an ordered table for the entries coming closest to the values specified as the elements of a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_searchV( uiVector&nbsp;Ind, fVector&nbsp;X, ui&nbsp;sizex, fVector&nbsp;Tab, ui&nbsp;sizetab, int&nbsp;mode&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;ui&gt;::searchV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Tab, int&nbsp;mode&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_searchV( Ind:uiVector; X:fVector; sizex:UIntSize; Tab:fVector; sizetab:UIntSize; mode:Integer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_searchV( uiVector&nbsp;d_Ind, fVector&nbsp;d_X, ui&nbsp;sizex, fVector&nbsp;d_Tab, ui&nbsp;sizetab, int&nbsp;mode&nbsp;);
<BR>void VFcu_searchV( uiVector&nbsp;h_Ind, fVector&nbsp;h_X, ui&nbsp;sizex, fVector&nbsp;h_Tab, ui&nbsp;sizetab, int&nbsp;mode&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_searchV( d_Ind:uiVector; d_X:fVector; sizex:UIntSize; d_Tab:fVector; sizetab:UIntSize; mode:Integer&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_searchV( h_Ind:uiVector; h_X:fVector; sizex:UIntSize; h_Tab:fVector; sizetab:UIntSize; mode:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each element of X, the element of the table Tab is located that is closest to it. Tab has to be ordered (either ascending or descending); if this condition is not fulfilled, the results will be wrong.
<BR>If X<sub>i</sub> is outside the range of the table, the first or the last element of the table is chosen, whichever is appropriate. Otherwise, three modes of the search are available:
<TABLE BORDER WIDTH="100%">
<TR><TD width="15%">mode = +1:&nbsp;</TD><TD>find the next element greater than or equal to X<sub>i</sub></TD></TR>
<TR valign="top"><TD>mode = &nbsp;&nbsp;0:</TD><TD>find the element closest to X<sub>i</sub>; if two elements are within equal distance, choose the lower index</TD></TR>
<TR><TD>mode = &nbsp;-1:</TD><TD>find the next element less than or equal to X<sub>i</sub></TD></TR>
</TABLE>
<P><I>sizex</I> is the number of elements of X and of Ind, whereas <I>sizetab</I> denotes the number of elements of the table Tab.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#searchC">VF_searchC</a>,&nbsp;&nbsp; <a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#sortind">VF_sortind</a>,&nbsp;&nbsp; <a href="#polyinterpol">VF_polyinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sec"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sec</b></font></td><td width="33%"><font size="+1"><b>VD_sec</b></font></td><td><font size="+1"><b>VE_sec</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sec</b></font></td><td width="33%"><font size="+1"><b>VDx_sec</b></font></td><td><font size="+1"><b>VEx_sec</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Secant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sec( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_sec( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sec( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_sec( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sec( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_sec( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sec( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_sec( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_sec( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_sec( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_sec( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sec( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_sec( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_sec( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sec( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_sec( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sec( X<sub>i</sub>&nbsp;)
&nbsp;&nbsp;&nbsp;= 1 / cos( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;sec( A*X<sub>i</sub>+B&nbsp;)
<BR>The secant is defined as the inverse of the cosine (not to be mistaken for the arcus function arccos). For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as rational multiples of <font face="symbol">p</font>, it is better to use <I><a href="#secrpi">VF_secrpi</a></I> than <I>VF_sec</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING or OVERFLOW errors lead to the default result &#177;HUGE_VAL. TLOSS precision errors lead to a result of 1.0 (as if the input were 0.0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sec2">VF_sec2</a>,&nbsp;&nbsp; <a href="#secrpi">VF_secrpi</a>,&nbsp;&nbsp; <a href="#cos">VF_cos</a>,&nbsp;&nbsp; <a href="#sech">VF_sech</a>,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sec2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sec2</b></font></td><td width="33%"><font size="+1"><b>VD_sec2</b></font></td><td><font size="+1"><b>VE_sec2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sec2</b></font></td><td width="33%"><font size="+1"><b>VDx_sec2</b></font></td><td><font size="+1"><b>VEx_sec2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the secant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sec2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_sec2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sec2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_sec2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sec2( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_sec2( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sec2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_sec2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_sec2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_sec2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_sec2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sec2( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_sec2( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_sec2( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sec2( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_sec2( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sec<sup>2</sup>( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;sec<sup>2</sup>( A*X<sub>i</sub>+B&nbsp;)
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>For SING and OVERFLOW errors, the default result is HUGE_VAL (multiplied by the sign of C in the expanded versions); TLOSS errors lead to a default result of 1.0 or C, resp. (as if the input were 0.0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sec">VF_sec</a>,&nbsp;&nbsp; <a href="#secrpi">VF_secrpi</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sech"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sech</b></font></td><td width="33%"><font size="+1"><b>VD_sech</b></font></td><td><font size="+1"><b>VE_sech</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sech</b></font></td><td width="33%"><font size="+1"><b>VDx_sech</b></font></td><td><font size="+1"><b>VEx_sech</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic secant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sech( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_sech( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sech( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_sech( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sech( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_sech( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sech( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_sech( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_sech( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_sech( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_sech( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sech( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_sech( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_sech( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sech( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_sech( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions:
<BR>Y<sub>i</sub> = sech( X<sub>i</sub>&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;= 2 / (exp( X<sub>i</sub>&nbsp;) + exp( -X<sub>i</sub>&nbsp;))
<BR>expanded versions:
<BR>Y<sub>i</sub> = C *&nbsp;sech( A*X<sub>i</sub>+B&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#sech2">VF_sech2</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; sinh</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sech2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sech2</b></font></td><td width="33%"><font size="+1"><b>VD_sech2</b></font></td><td><font size="+1"><b>VE_sech2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sech2</b></font></td><td width="33%"><font size="+1"><b>VDx_sech2</b></font></td><td><font size="+1"><b>VEx_sech2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the hyperbolic secant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sech2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_sech2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sech2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_sech2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sech2( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_sech2( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sech2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_sech2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_sech2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_sech2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_sech2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sech2( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_sech2( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_sech2( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sech2( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_sech2( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sech<sup>2</sup>( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;sech<sup>2</sup>( A*X<sub>i</sub>+B&nbsp;)
<BR>The sech<sup>2</sup> function is used in physics, e.g., to describe the shape of ultrashort light pulses. Compared to a Gaussian or Lorentzian pulse shape of the same autocorrelation width (see <I><a href="#autocorr">VF_autocorr</a></I>), the sech<sup>2</sup> function has the smallest FWHM (full width to half maximum).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sech">VF_sech</a>,&nbsp;&nbsp; <a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a>,&nbsp;&nbsp; <a href="#Lorentz">VF_Lorentz</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="secrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_secrpi</b></font></td><td width="33%"><font size="+1"><b>VD_secrpi</b></font></td><td><font size="+1"><b>VE_secrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_secrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_secrpi2</b></font></td><td><font size="+1"><b>VE_secrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_secrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_secrpi3</b></font></td><td><font size="+1"><b>VE_secrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Secant function of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_secrpi( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_secrpi2( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_secrpi3( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::secrpi( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::secrpi2( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::secrpi3( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_secrpi( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_secrpi2( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_secrpi3( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_secrpi( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_secrpi2( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_secrpi3( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_secrpi( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_secrpi2( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_secrpi3( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_secrpi( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_secrpi2( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_secrpi3( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_secrpi( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_secrpi2( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_secrpi3( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = sec( (P<sub>i</sub> / q) *&nbsp;<font face="symbol">p</font>&nbsp;)
<BR>The secant of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_secrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_secrpi2</I> should be used which is a highly optimized version utilizing a look-up table. If q is a multiple of 3, <I>VF_secrpi3</I> should be used. <I>VF_secrpi2</I> and <I>VF_secrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors occur if P<sub>i</sub> / q is an odd multiple of 1/2; the default result is 0.0 (which is the mean of +HUGE_VAL and -HUGE_VAL; similarly to <I><a href="#cosecrpi">VF_cosecrpi2</a></I>, 0.0 is chosen irrespective to the fact that it is not a valid result of the secant function!);
<BR>q must be non-zero; this is, however, not tested for.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sec">VF_sec</a></I>,&nbsp;&nbsp;cos</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="selected_mean"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_selected_mean</b></font></td><td width="33%"><font size="+1"><b>VD_selected_mean</b></font></td><td><font size="+1"><b>VE_selected_mean</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean of the elements of a one-dimensional distribution, falling into a specified interval</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_selected_mean( ui&nbsp;*nsel, fVector&nbsp;X, ui&nbsp;size, float&nbsp;XMin, float&nbsp;XMax&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::selected_mean( ui&nbsp;*nsel, T XMin, T XMax&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_selected_mean( var nsel:UIntSize; X:fVector; size:UIntSize; XMin,&nbsp;XMax:Single&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_selected_mean( ui&nbsp;*h_nsel, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;XMin, float&nbsp;XMax&nbsp;);
<BR>int cusdVF_selected_mean( ui&nbsp;*h_nsel, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_XMin, float&nbsp;*d_XMax&nbsp;);
<BR>float VFcu_selected_mean( ui&nbsp;*h_nsel, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;XMin, float&nbsp;XMax&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_selected_mean( var&nbsp;h_RetVal:Single; var h_nsel:UIntSize; d_X:fVector; size:UIntSize; XMin,&nbsp;XMax:Single&nbsp;)::&nbsp;IntBool;
<BR>function cusdVF_selected_mean( d_RetVal:PSingle; var h_nsel:UIntSize; d_X:fVector; size:UIntSize; d_XMin,&nbsp;d_XMax:PSingle&nbsp;)::&nbsp;IntBool;
<BR>function VFcu_selected_mean( var&nbsp;h_nsel:UIntSize; h_X:fVector; size:UIntSize; XMin,&nbsp;XMax:Single&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Those elements of X are selected, which fall into the interval XMin &lt;= X<sub>i</sub> &lt;= XMax.
<BR>Their mean is calculated, and the number of selected elements is stored at the address nsel. If this number is not needed, nsel may be passed to the function as NULL (C/C++) or nil (Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If no element falls into the specified range, nsel = 0 and the return value is (XMax+XMin)/2</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Mean of the selected vector elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setAutoCudaUse"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setAutoCudaUse</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Decide if <i>OptiVec</i> functions shall automatically determine if they use the CUDA device or not</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>void V_setAutoCudaUse( int&nbsp;UseCuda&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_setAutoCudaUse( UseCuda: Integer&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>By default, the (host) functions contained in the <i>cudaOptiVec</i> libraries (marked by the letter "C" in the library name, like OVVC8C.LIB) will automatically decide if any performance gain is to be expected from transferring part or all of the work to the CUDA device &#x2013; and do so, if it seems advantageous. As the <i>OptiVec</i> functions cannot easily "know" the relative quality of your CPU and your CUDA device, this decision-making algorithm is far from perfect. Often, you may be better off by switching it off. In that case, one has to change the prefix of those functions which one actually wishes to employ the CUDA device by adding the letters "cu" before the underbar of the function prefix: instead of <i>VF_</i> write <i>VFcu_</i> etc. &nbsp;If one decides to do that, the include-files <font face="Courier New">&lt;cudaVFstd.h&gt;, &lt;cudaVFmath.h&gt;</font> etc. have to be included.
<BR>UseCuda = 0 switches the automatic use of the CUDA device off.
<BR>Any non-zero value of UseCuda switches the automatic use of the CUDA device on again.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap4">CudaOptiVec.htm, Chapter&nbsp;4. Distinguishing <i>OptiVec</i> Functions for Host and for Device Memory</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setBoundaryCheckWarn"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setBoundaryCheckWarn</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Switch warnings about non-<i>OptiVec</i> vectors / matrices on and off (during checks for dimension mismatches)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Veclib.h&gt;
<BR>void V_setBoundaryCheckWarn( int&nbsp;WarnLevel&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Veclib;
<BR>procedure V_setBoundaryCheckWarn( WarnLevel: IntBool&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The dimension-checking debug libraries (VCF4WD.LIB for Borland / CodeGear C++,  OVVC4D.LIB for Visual C++,  units in LIB4D for Delphi) will normally issue a warning, if any array not generated by <a href="#vector">V?_vector</a> or <a href="MATRIX.HTM#matrix">M?_matrix</a> is encountered. While using non-<i>OptiVec</i> vectors is perfectly legal, it might also be dangerous, as possible dimension-mismatches cannot detected. If you have to use static arrays (or arrays dynamic allocated with <i>malloc</i> or the Windows API memory functions) and do not want to see the warning messages, you may call 
<BR><font face="courier new">V_setBoundaryCheckWarn( 0 );</font> &nbsp;(C/C++) or 
<BR><font face="courier new">V_setBoundaryCheckWarn( FALSE );</font>  &nbsp;(Pascal / Delphi).
<BR>This will switch off only the described <u>warning</u> messages. It does not affect the <u>error</u> messages. For details about the error and warning messages, see <a href="#checkBoundaries">V_checkBoundaries</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#checkBoundaries">V_checkBoundaries</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setCoordSystem"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setCoordSystem</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Restore the scalings and position of a coordinate system previously saved by <I><a href="#getCoordSystem">V_getCoordSystem</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_setCoordSystem( VCOORDSYSTEM *csys&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_setCoordSystem( csys: VCOORDSYSTEM&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>If one wants to &quot;hop&quot; between several coordinate systems, displayed in one and the same window, one has to store the specifications (position and scalings) of each coordinate system separately, using <I><a href="#getCoordSystem">V_getCoordSystem</a></I>, and to retrieve them as needed, using this function.
<BR>The address of a struct VCOORDSYSTEM is passed as the argument. VCOORDSYSTEM is defined in &lt;Vgraph.h&gt; (C/C++) or the unit Vgraph (Pascal/Delphi).
<BR>For an example, see <I><a href="#getCoordSystem">V_getCoordSystem</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#getCoordSystem">V_getCoordSystem</a>,&nbsp;&nbsp; <a href="#setPlotRegion">V_setPlotRegion</a>,&nbsp;&nbsp; <a href="#continuePlot">V_continuePlot</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setCudaWorkspace"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setCudaWorkspace</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Set the <i>OptiVec for CUDA</i> workspace to be used by the following function calls</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>overror_t V_setCudaWorkspace( V_CUDAWORKSPACE wsp&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Delphi</td><td><font face="courier new">uses VecLib;
<BR>function V_setCudaWorkspace( wsp: V_CUDAWORKSPACE&nbsp;): Integer;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>An <i>OptiVec for CUDA</i> workspace, previously created by <I><a href="#createCudaWorkspace">V_createCudaWorkspace</a></I>, is set to be used by the following calls to <i>cudaV?_</i> functions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>0 if successful; non-zero if the workspace did not exist or did not contain a valid stream / buffer memory handles. As sometimes even an invalid workspace may seem to contain valid values, not all errors would be detected.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap5">CudaOptiVec.htm, Chapter 5. Streams and Workspaces</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setElement"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setElement</b></font></td><td width="34%"><font size="+1"><b>VD_setElement</b></font></td><td><font size="+1"><b>VE_setElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_setElement</b></font></td><td width="34%"><font size="+1"><b>VCD_setElement</b></font></td><td><font size="+1"><b>VCE_setElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_setElement</b></font></td><td width="34%"><font size="+1"><b>VPD_setElement</b></font></td><td><font size="+1"><b>VPE_setElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_setElement</b></font></td><td width="17%"><font size="+1"><b>VBI_setElement</b></font></td><td width="17%"><font size="+1"><b>VSI_setElement</b></font></td><td width="17%"><font size="+1"><b>VLI_setElement</b></font></td><td width="17%"><font size="+1"><b>VQI_setElement</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_setElement</b></font></td><td width="17%"><font size="+1"><b>VUB_setElement</b></font></td><td width="17%"><font size="+1"><b>VUS_setElement</b></font></td><td width="17%"><font size="+1"><b>VUL_setElement</b></font></td><td width="17%"><font size="+1"><b>VUQ_setElement</b></font></td><td><font size="+1"><b>VUI_setElement</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sets a single vector element to a given value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_setElement( fVector&nbsp;X, ui&nbsp;pos, float C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>vector&lt;T&gt;::setElement( ui&nbsp;pos, T C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_setElement( X:fVector; pos:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>void cudaVF_setElement( fVector&nbsp;d_X, ui&nbsp;pos, float&nbsp;C&nbsp;);
<BR>void cusdVF_setElement( fVector&nbsp;d_X, ui&nbsp;pos, float&nbsp;*d_C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure cudaVF_setElement( d_X:fVector; pos:UIntSize; C:Single&nbsp;);
<BR>procedure cusdVF_setElement( d_X:fVector; pos:UIntSize; d_C:PSingle&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The element at the position <i>pos</i> is overwritten with the value C.
<BR>This function is needed to set elements of dynamically allocated vectors, for which older versions of Borland C++ had a pointer arithmetics bug, and Pascal/Delphi - unlike C - does not provide an own mechanism at all.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Pelement">VF_Pelement</a>, &nbsp;&nbsp;<a href="#element">VF_element</a>, &nbsp;&nbsp;<a href="#getElement">VF_getElement</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setErrorEventFile"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setErrorEventFile</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Prepare a file for printing error messages into it</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_setErrorEventFile(
 char *filename, unsigned ScreenAndFile&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_setErrorEventFile( filename:PChar; ScreenAndFile:UInt&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function determines where to print messages notifying errors that occur within <I>OptiVec</I> routines. <i>filename</i> is the desired name of the event file (often called &quot;log-file&quot;). <i>ScreenAndFile</i> decides if you wish to have error messages printed simultaneously into the file and onto the screen:
<BR><I>ScreenAndFile</I> = 0: no screen output.
<BR><I>ScreenAndFile</I> = 1: output into a message box (i.e., Windows default)
<BR><I>ScreenAndFile</I> = 2: output into <i>stderr</i> (for Console programmes only)
<BR>&nbsp;<BR>The event file is closed by <I><a href="#closeErrorEventFile">V_closeErrorEventFile</a></I>. After that, <i>OptiVec</i> error messages are emitted according to the paramter <i>ScreenAndFile</i> with which the event file was generated.
<BR>&nbsp;<BR>By calling<i>V_setErrorEventFile</i> with a value of NULL or "NULL" (C/C++), <i>nil</i> or 'nil' (Pascal/Delphi) for <i>filename</i> no event file is generated: 
<BR><font face="courier new">V_setErrorEventFile( "NULL", 0 );</font>: Any <i>OptiVec</i> messages are completely suppressed (which is probably not a wise choice in most instances).
<BR><font face="courier new">V_setErrorEventFile( "NULL", 1 );</font>: messages are printed into a message box.
<BR><font face="courier new">V_setErrorEventFile( "NULL", 2 );</font>: for Console programmes only: messages are emitted to <i>stderr</i>. In Visual C++, this option is possible only if the dynamic RTL is used; in the configurations DebugStatic and ReleaseStatic, it cannot be used and would be treated as "0".
<BR>Any previously generated event file remaines unchanged by this, of course.
<BR>&nbsp;<BR>If a user-defined <I>_matherr</I> function (C/C++) or any other custom error handler (both C/C++ and Pascal/Delphi) calls <I><a href="#noteError">V_noteError</a></I>, also errors occurring outside <I>OptiVec</I> routines will lead to a message printed into the event file (see <a href="HANDBOOK.HTM#chap5_5">chapter&nbsp;5.5</a>).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If the desired event file cannot be opened or created, the program is aborted with a message &quot;Cannot open error event file&quot;.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#noteError">V_noteError</a>,&nbsp;&nbsp; <a href="#closeErrorEventFile">V_closeErrorEventFile</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setFPAccuracy"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setFPAccuracy</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Set the coprecessor to a specific precision</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void  V_setFPAccuracy( unsigned level&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_setFPAccuracy( level:UInt&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function changes the FPU Control-Word to switch the FPU to a specified accuracy, passed to the function as the argument <I>level</I>. For <I>level</I>=1, <B>float / Single</B> precision is obtained, <I>level</I>=2 leads to <B>double</B> precision, whereas <I>level</I>=3 switches the FPU into <B>extended</B> precision. The actual accuracy the coprocessor is switched to may be read through <I><a href="#getFPAccuracy">V_getFPAccuracy</a></I>.
<BR>Operating the floating-point processor at <B>float / Single</B> precision may significantly speed up program execution, especially for any functions involving divisions (on Pentium or higher). This is true for functions (including <I>OptiVec</I> functions) of any floating-point data type. Thereby, you may even operate <I>VD_</I> and <I>VE_</I> functions at <B>float / Single</B> accuracy ? preserving <B>double</B> or <B>extended</B> range, but calculating results to single precision only. 
<BR>On the other hand, as some versions of Windows XP and Vista automatically reduce the accuracy to double-precision instead of the standard 80-bit <b>extended</b> precision, you may actually wish to set <font face="courier new">V_setFPAccuracy( 3 );</font> in order to get full-precision results from the <I>VD_</I> and <I>VE_</I> functions.
<BR>There are several groups of functions which rely on full coprocessor accuracy for intermediate results, or which use precision-controlled iterations. Obviously, if the FPU operates in single precision only, such a function will never attain double precision and may get caught in an infinite loop. You should <U>never</U> call any of the following functions while the FPU is switched to single precision (or, for <I>VE_</I> functions, to double precision):
<BR><I><a href="#Kepler">V?_Kepler</a></I>,
<BR><I><a href="MATRIX.HTM#SVdecompose">M?_SVdecompose</a></I>,
<BR>or any of the nonlinear data fitting functions like <I><a href="MATRIX.HTM#nonlinfit">VF_nonlinfit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#getFPAccuracy">V_getFPAccuracy</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setFPErrorHandling"></a><a name="FPErrorHandlingMode"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setFPErrorHandling</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Define the action taken in the case of floating-point errors (Pascal/Delphi only).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>type V_fphand = 0..$1717;
<BR>procedure V_setFPErrorHandling( hand:V_fpHand&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>As Pascal/Delphi does not handle floating-point errors through a user-definable function <I>_matherr</I>, as does C/C++, the function <I>V_setFPErrorHandling</I> is offered in <I>OptiVec</I> as a means for the programmer to exert at least some control over the actions to be taken in the case of floating-point errors occurring within <I>OptiVec</I> functions. A number of pre-defined constants <I>fperrXXX</I> is available for the construction of the desired error-handling mode:<br>&nbsp;
<table border width="100%">
<tr valign="top"><td>Constant</td><td>Value</td><td>Meaning</td></tr>
<tr valign="top"><td>fperrIgnore</td><td>0</td><td>Ignore all floating-point errors: handle them silently, do not print a message, continue program execution</td></tr>
<tr valign="top"><td>fperrNoteDOMAIN</td><td>$0001</td><td>Print a message in case of a DOMAIN error</td></tr>
<tr valign="top"><td>fperrNoteSING</td><td>$0002</td><td>Print a message in case of a SING error</td></tr>
<tr valign="top"><td>fperrNoteOVERFLOW</td><td>$0003</td><td>Print a message in case of an OVERFLOW error</td></tr>
<tr valign="top"><td>fperrNoteTLOSS</td><td>$0004</td><td>Print a message in case of a TLOSS error</td></tr>
<tr valign="top"><td>fperrAbortDOMAIN</td><td>$0101</td><td>Abort program in case of a DOMAIN error</td></tr>
<tr valign="top"><td>fperrAbortSING</td><td>$0202</td><td>Abort program in case of a SING error</td></tr>
<tr valign="top"><td>fperrAbortOVERFLOW</td><td>$0303</td><td>Abort program in case of an OVERFLOW error</td></tr>
<tr valign="top"><td>fperrAbortTLOSS</td><td>$0404</td><td>Abort program in case of a TLOSS error</td></tr>
<tr valign="top"><td>fperrDefaultHandling</td><td>$0107</td><td>Same as fperrAbortDOMAIN <B>or</B> fperrNoteSING <B>or</B> fperrNoteOVERFLOW</td></tr>
</table>&nbsp;</td></tr>
<tr valign="TOP">
<td width="15%">Example</td><td><font face="courier new">V_setFPErrorHandling( fperrAbortDOMAIN + fperrAbortSING + fperrAbortOVERFLOW + fperrNoteTLOSS&nbsp;);</font>
<BR>In this example, program execution will be aborted (with the appropriate message) in the case of the most severe errors, DOMAIN and SING. In the case of OVERFLOW and TLOSS errors, a warning will be displayed, but program execution will be continued with default results set by the respective functions where the errors occur. The repeated occurrence
of the same type of error within one and the same function will lead to only one message being generated. Subsequent errors will be treated silently.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setIntErrorHandling">V_setIntErrorHandling</a>,&nbsp;&nbsp; <a href="#setErrorEventFile">V_setErrorEventFile</a>,&nbsp;&nbsp; <a href="#noteError">V_noteError</a>,&nbsp;&nbsp; <a href="#printErrorMsg">V_printErrorMsg</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setIntErrorHandling"></a><a name="intErrorHandlingMode"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setIntErrorHandling</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Define the action taken in the case of INTEGER OVERFLOW and INTEGER DOMAIN errors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>typedef enum {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ierrIgnore = 0,&nbsp;ierrNote,&nbsp;ierrAbort
<BR>} V_ihand;
<BR>void V_setIntErrorHandling( V_ihand ihand&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>type V_ihand = 0..2;
<BR>procedure V_setIntErrorHandling( ihand:V_iHand&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function allows to set the handling mode for OVERFLOW and DOMAIN errors occurring within integer functions of <I>OptiVec</I>. It has to be called with one of the following pre-defined constants as argument:<br><font face="courier new">
&nbsp;&nbsp;&nbsp;&nbsp;ierrIgnore = 0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ierrNote&nbsp;= 1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ierrAbort&nbsp;= 2;</font>
<BR>The default is that these errors are ignored, i.e., they are treated by discarding overflowing bits (see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2</a> for details on integer error handling). If you wish to change this behaviour, call, e.g.,
<BR><font face="courier new">V_setIntErrorHandling( ierrNote&nbsp;);</font>
<BR>and add the letter &quot;o&quot; to the prefixes of those integer functions for which you wish to trap errors: <I>VIo_,&nbsp;&nbsp; VUSo_</I>, etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setFPErrorHandling">V_setFPErrorHandling</a>,&nbsp;&nbsp; <a href="#setErrorEventFile">V_setErrorEventFile</a>,&nbsp;&nbsp; <a href="#noteError">V_noteError</a>,&nbsp;&nbsp; <a href="#printErrorMsg">V_printErrorMsg</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setLineThickness"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setLineThickness</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Modify the line thickness used in plotting functions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_setLineThickness( unsigned linethickness&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_setLineThickness( linethickness:UInt&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The line thickness used in the plotting functions <I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a></I>, etc., is set to linethickness. To reset the default value, call <I>V_setLineThickness</I> with linethickness = 1.
<BR><u>DOS:</u>
<BR>There are only two possible values for linethickness:
<BR>&nbsp;&nbsp;&nbsp;C/C++: NORM_WIDTH = 1 and THICK_WIDTH = 3.
<BR>&nbsp;&nbsp;&nbsp;Pascal/Delphi: NormWidth = 1 and ThickWidth = 3.
<BR>Any value of linethickness below 3 is interpreted as NORM_WIDTH, any value above 3 is taken as THICK_WIDTH.
<BR><u>Windows:</u>
<BR>Any value of linethickness between 1 and 500 is allowed, useful values ranging from 1 to about 10. A minimum thickness of one pixel is always secured, even if linethickness is set to 0. Note that broken or dotted lines are plotted accurately only with a linethicknes of 1. At higher values of linethickness, all lines will look like solid lines. Thicker lines are plotted considerably slower than thinner ones.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td><u>DOS:</u> &quot;silent&quot; correction of the input value.
<BR><u>Windows:</u> A value of linethickness greater than 500 leads to a warning message &quot;Cannot use line thicker than 500 pixels.&quot; Program execution is continued with linethickness set to 500.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#setSymbolSize">V_setSymbolSize</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setNWriteSeparate"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setNWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VD_setNWriteSeparate</b></font></td><td><font size="+1"><b>VE_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_setNWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VCD_setNWriteSeparate</b></font></td><td><font size="+1"><b>VCE_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_setNWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VPD_setNWriteSeparate</b></font></td><td><font size="+1"><b>VPE_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_setNWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VBI_setNWriteSeparate</b></font></td><td><font size="+1"><b>VSI_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_setNWriteSeparate</b></font></td><td><font size="+1"><b>VQI_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_setNWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VUB_setNWriteSeparate</b></font></td><td><font size="+1"><b>VUS_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_setNWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VUQ_setNWriteSeparate</b></font></td><td><font size="+1"><b>VUI_setNWriteSeparate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Definition of the string to be used by the <I><a href="#nwrite">V.._nwrite</a></I> functions to separate table entries.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_setNWriteSeparate( char *SepString&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_setNWriteSeparate( SepString:PChar&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function defines the character string to be inserted between the columns of a table written by <I><a href="#nwrite">VF_nwrite</a></I>. <I>VF_setNWriteSeparate</I> does not influence the end of each line which is always a line-feed character (&quot;\n&quot; for C/C++ and #13 for Pascal/Delphi).
<BR>SepString may contain up to twelve characters. The default setting is a tab character (&quot;\t&quot; for C/C++ and #9 for Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>In the case of <I>SepString</I> longer than twelve characters, the program is aborted with the error message &quot;Invalid Parameter(s)&quot;.
<BR>The contents of <I>SepString</I> is not checked.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setWriteFormat">VF_setWriteFormat</a>,&nbsp;&nbsp; <a href="#setWriteSeparate">VF_setWriteSeparate</a>,&nbsp;&nbsp; <a href="#nwrite">VF_nwrite</a>,&nbsp;&nbsp; <a href="#nread">VF_nread</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setODThresh"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setODThresh</b></font></td><td width="33%"><font size="+1"><b>VD_setODThresh</b></font></td><td><font size="+1"><b>VE_setODThresh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_setODThresh</b></font></td><td width="33%"><font size="+1"><b>VUB_setODThresh</b></font></td><td><font size="+1"><b>VUS_setODThresh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_setODThresh</b></font></td><td width="33%"><font size="+1"><b>VUQ_setODThresh</b></font></td><td><font size="+1"><b>VQI_setODThresh</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Set the threshold for optical density calculation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_setODThresh( float minX, float minX0&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec&gt;
<BR>void vector&lt;T&gt;::setODThresh( T minX, T minX0&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_setODThresh( minX, minX0:Single&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>As described for <I><a href="#OD">VF_OD</a></I> and <I><a href="#ODwDark">VF_ODwDark</a></I>, the threshold below which input numbers for these functions are regarded as &quot;experimental noise&quot;, with the OD being set to 0.0, can be set to any positive number by <I>VF_setODThresh</I> etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#OD">VF_OD</a>,&nbsp;&nbsp; <a href="#ODwDark">VF_ODwDark</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setPlotRegion"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setPlotRegion</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Defines a screen or printer-page region to be used by <I>VectorLib</I> plotting operations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_setPlotRegion( int&nbsp;left, int&nbsp;top, int&nbsp;right, int&nbsp;bottom&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_setPlotRegion( left, top, right, bottom:Integer);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The rectangular region defined by the parameters, passed to <I>V_setPlotRegion</I>, will hold the coordinate system including all labels generated by future calls to <I>VectorLib</I> plotting functions such as <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. The parameters left, top, right, and bottom are in pixels, counting from the upper left corner of the screen or of the printer page.
<BR><I>V_setPlotRegion</I> has to be called after (!) <I><a href="#initPlot">V_initPlot</a></I> or <I><a href="#initPrint">V_initPrint</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#initPlot">V_initPlot</a>,&nbsp;&nbsp; <a href="#initPrint">V_initPrint</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setRadix"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setRadix</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Define the radix for the whole-number read functions: C/C++ only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VIstd.h&gt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(or &lt;VSIstd.h&gt;, &lt;VLIstd.h&gt;, &lt;VUstd.h&gt;, ... *)
<BR><font face="courier new"> void V_setRadix( int&nbsp;radix&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>By default, the V..<I><a href="#read">_read</a></I> functions for the whole-number data types interpret all numbers as decimal numbers. <I>V_setRadix</I> allows to change this default behaviour.
<BR>The radix set by <I>V_setRadix</I> will be used in <I><a href="#read">VI_read</a>,&nbsp;&nbsp; <a href="#nread">VI_nread</a></I> and their <I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VU_,&nbsp;&nbsp; VUL_</I>, and <I>VUI_</I> analogues. It does, however, not affect <I><a href="#read">VQI_read</a></I>, <I><a href="#nread">VQI_nread</a></I>, <I><a href="#read">VUQ_read</a></I>, or <I><a href="#nread">VUQ_nread</a></I> (where the radix is always 10).
<P><I>radix</I> may take on values between 2 and 36 or 0.
<BR>In the case of <I>radix</I>=0, the basis of each number is determined at run-time:
<BR>All numbers beginning with the ciphers 1-9 are recognized as decimal numbers. All numbers beginning with &quot;0x&quot; are interpreted as hexadecimal and all numbers beginning with &quot;0&quot; without &quot;x&quot; are read as octal numbers.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>radix &lt; 0, radix=1, or radix &gt; 36 lead to a program abort with the error message &quot;Invalid Parameter(s)&quot;.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#read">VI_read</a>,&nbsp;&nbsp; <a href="#nread">VI_nread</a>,&nbsp;&nbsp; strtol,&nbsp;&nbsp; strtoul</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setRspEdit"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setRspEdit</b></font></td><td width="33%"><font size="+1"><b>VD_setRspEdit</b></font></td><td><font size="+1"><b>VE_setRspEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Modify the treatment of round-off errors in <I><a href="#convolve">VF_convolve</a></I> and <I><a href="#deconvolve">VF_deconvolve</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_setRspEdit( fComplex Trunc&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::setRspEdit( const complex&lt;T&gt;&amp;&nbsp;Trunc&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_setRspEdit( Trunc:fComplex&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>void cudaVF_setRspEdit( fComplex&nbsp;Trunc&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure cudaVF_setRspEdit( Trunc:fComplex&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>In the functions <I><a href="#convolve">VF_convolve</a></I> and <I><a href="#deconvolve">VF_deconvolve</a></I>, a frequency filter is calculated by Fourier-transforming a given response function. The filter is then applied to a vector. Due to accumulated round-off, filter elements that should be zero may be not so, but contain small non-zero numbers.
<P>The maximum round-off error in the construction of Flt accumulates roughly to (size *&nbsp;big *&nbsp;prec), where big is the largest element of Flt and prec the relative floating-point precision. Any element smaller than that should be regarded as zero. In order to determine the exact threshold for the real and imaginary parts separately, the function uses the real and imaginary parts of Trunc, substituting them for prec in the above expression. Normally, you would choose
<BR>Trunc.Re = Trunc.Im, although a stricter (i.e. larger) value for Trunc.Im is also reasonable. Both Trunc.Re and Trunc.Im must be &lt; 1.0; otherwise an error message "Invalid Parameter(s)" is generated and the program terminated.
<P>By default, Trunc.Re = 16*EPSILON and Trunc.Im = 32*EPSILON, where EPSILON is the relative floating-point accuracy of the respective data type. (For C/C++, EPSILON is FLT_EPSILON, &nbsp;DBL_EPSILON, or LDBL_EPSILON, as defined in &lt;float.h&gt;).
<P>In order to switch the editing of the filter completely off, choose Trunc.Re = Trunc.Im = 0.
<P>During convolutions, the editing of the filter leads to slightly smoother results. During deconvolutions, the editing has also another meaning: for all &quot;lost&quot; frequencies (i.e., those for which the Fourier transform of the response function contains only numbers near zero), the filter is set to 0 instead of the inverse of these small numbers. Thereby, possible OVERFLOW and SING errors are avoided.
<P>To read the currently set threshold, call <I><a href="#getRspEdit">VF_getRspEdit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either Trunc.Re or Trunc.Im (or both) are &gt;= 1.0, an error message "Invalid Parameter(s)" is generated and the program terminated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#deconvolve">VF_deconvolve</a>,&nbsp;&nbsp; <a href="#getRspEdit">VF_getRspEdit</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setSymbolSize"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setSymbolSize</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Modify the size of the symbols used in plotting functions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_setSymbolSize( float symsiz&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_setSymbolSize( symsize:Single&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The size of the symbols used in the plotting functions <I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a></I>, etc., is modified by scaling with symsiz. To reset the symbol size to the default value, call <I>V_setSymbolSize</I> with symsiz=1.0. Note that it is not possible to make the symbols completely vanish (e.g., by setting symsiz = 0.0), since a minimum radius of one pixel is always secured. Useful values of symsiz range from about 0.5 to 5.0. Values above 50.0 are prohibited.
<P>When magnifying the symbols, you should also consider modifying the thickness of the connecting lines, if you are using any. See <I><a href="#setLineThickness">V_setLineThickness</a></I>.
<P>Note: An automatic scaling is always performed in order to maintain a constant relation between the symbol size and the overall size of the coordinate grid (which is especially important for Windows applications). The factor symsiz of this function scales the symbol size with respect to the automatically-found value. The automatic scaling cannot be switched off.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>DOS: &quot;silent&quot; correction of the input value.
<BR>Windows: A value of symsiz greater than 50.0 leads to a warning message &quot;Cannot scale symbols by more than a factor of 50.0&quot;. Program execution is continued with symsiz set to 50.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#setLineThickness">V_setLineThickness</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setWriteFormat"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setWriteFormat</b></font></td><td width="33%"><font size="+1"><b>VD_setWriteFormat</b></font></td><td><font size="+1"><b>VE_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_setWriteFormat</b></font></td><td width="33%"><font size="+1"><b>VCD_setWriteFormat</b></font></td><td><font size="+1"><b>VCE_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_setWriteFormat</b></font></td><td width="33%"><font size="+1"><b>VPD_setWriteFormat</b></font></td><td><font size="+1"><b>VPE_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_setWriteFormat</b></font></td><td width="33%"><font size="+1"><b>VBI_setWriteFormant</b></font></td><td><font size="+1"><b>VSI_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_setWriteFormat</b></font></td><td><font size="+1"><b>VQI_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_setWriteFormat</b></font></td><td width="33%"><font size="+1"><b>VUB_setWriteFormat</b></font></td><td><font size="+1"><b>VUS_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_setWriteFormat</b></font></td><td width="33%"><font size="+1"><b>VUQ_setWriteFormat</b></font></td><td><font size="+1"><b>VUI_setWriteFormat</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Definition of the format to be used by <I><a href="#write">V.._write</a></I> and <I><a href="#nwrite">V.._nwrite</a></I>: C/C++ only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_setWriteFormat( char *FormatString&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::setWriteFormat( char *FormatString&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The functions of the <I><a href="#write">VF_write</a></I> and <I><a href="#nwrite">VF_nwrite</a></I> families employ internally the ANSI C function <I>fprintf</I> in order to print numbers into a stream.
<BR>According to the rules described in the documentation of your C compiler's <I>printf</I> function, the format may be specified as fits your needs. When defining a write format, one should always be aware of the restrictions imposed by the read functions (not all formats you can write will be read correcly, see <I><a href="#read">VF_read</a></I>).
<P><I>VF_setWriteFormat</I> should not be used for the definition of whitespace before or after the numbers. This is the task of <I><a href="#setWriteSeparate">VF_setWriteSeparate</a></I>.
<P>For details about the formats used for each of the various data types, please refer to the following table. The last column of this table gives the maximum length of the format string.
<BR>&nbsp;<table border width="100%">
<tr valign="top"><td>Version</td><td>Standard Format</td><td>Alternative Example</td><td>max. length</td></tr>
<tr valign="top"><td><I>VF_</I></td><td>&quot;% 11.8e&quot;</td><td>&quot;% 8.4f&quot;</td><td>16</td></tr>
<tr valign="top"><td><I>VD_</I></td><td>&quot;% 19.16le&quot;</td><td>&quot;% 16.8lf&quot;</td><td>16</td></tr>
<tr valign="top"><td><I>VE_</I></td><td>&quot;% 22.19Le&quot;</td><td>&quot;% 22.19LG&quot;</td><td>16</td></tr>
<tr valign="top"><td><I>VCF_</I></td><td>&quot;% 11.8e, % 11.8e&quot;</td><td>&quot;{% 8.4f, % 8.4f}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VCD_</I></td><td>&quot;% 19.16le, % 19.16le&quot;</td><td>&quot;{% 19.16lE % 19.16lE}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VCE_</I></td><td>&quot;% 22.19Le, % 22.19Le&quot;</td><td>&quot;{% 22.19Lg % 22.19Lg}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VPF_</I></td><td>&quot;% 11.8e @% 11.8e&quot;</td><td>&quot;{% 8.4f @% 8.4f}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VPD_</I></td><td>&quot;% 19.16le @% 19.16le&quot;</td><td>&quot;{% 19.16lE @% 19.16lE}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VPE_</I></td><td>&quot;% 22.19Le @% 22.19Le&quot;</td><td>&quot;{% 22.19Lg @% 22.19Lg}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VI_</I></td><td>&quot;% 10d&quot;</td><td>&quot;0x% 8x&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VBI_</I></td><td>&quot;% 3hd&quot;</td><td>&quot;0x% 2hX&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VSI_</I></td><td>&quot;% 5hd&quot;</td><td>&quot;0x% 4hX&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VLI_</I></td><td>&quot;% 10ld&quot;</td><td>&quot;%08lXh&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VQI_</I></td><td>&quot;% 20lld&quot;</td><td></TD><td>16</td></tr>
<tr valign="top"><td><I>VU_</I></td><td>&quot;%10u&quot;</td><td>&quot;%04xh&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VUB_</I></td><td>&quot;%3hu&quot;</td><td>&quot;0%02ho&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VUS_</I></td><td>&quot;%5hu&quot;</td><td>&quot;0%04ho&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VUL_</I></td><td>&quot;%10lu&quot;</td><td>&quot;0%08lO&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VUQ_</I></td><td>&quot;%20I64u&quot;</td><td>&nbsp;</td><td>12</td></tr></table>
<P>Note that byte-sized integers are extended to 16-bit before being printed, so that the format specifier has to be for 16-bit numbers.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Format strings longer than the maximum length specified in the above table lead to a program abort with the error message &quot;Invalid Parameter(s)&quot;.
<BR>The contents of the format string is not checked. So you have to be very careful to specify a format which is valid for the respective data type.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setWriteSeparate">VF_setWriteSeparate</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#nwrite">VF_nwrite</a>,&nbsp;&nbsp; <a href="#read">VF_read</a>,&nbsp;&nbsp; <a href="#nread">VF_nread</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setWriteSeparate"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VD_setWriteSeparate</b></font></td><td><font size="+1"><b>VE_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_setWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VCD_setWriteSeparate</b></font></td><td><font size="+1"><b>VCE_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_setWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VPD_setWriteSeparate</b></font></td><td><font size="+1"><b>VPE_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_setWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VBI_setWriteSeparate</b></font></td><td><font size="+1"><b>VSI_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_setWriteSeparate</b></font></td><td><font size="+1"><b>VQI_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_setWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VUB_setWriteSeparate</b></font></td><td><font size="+1"><b>VUS_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_setWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VUQ_setWriteSeparate</b></font></td><td><font size="+1"><b>VUI_setWriteSeparate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Definition of the separation string used by V..<I><a href="#write">_write</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_setWriteSeparate( char *SepString&nbsp;);</font></td></tr>
<tr><td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::setWriteSeparate( char *SepString&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_setWriteSeparate( SepString:PChar&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>By default, <I><a href="#write">VF_write</a></I> puts a line feed character after each vector element written into a stream. This means that each element gets its own line. You may use <I>VF_setWriteSeparate</I> to define another separation string. This may be, for example, a tab character (&quot;\t&quot; for C/C++ or #9 for Pascal/Delphi) or a series of spaces (e.g., &quot;&nbsp;&nbsp;&nbsp;&nbsp;&quot; for C/C++ or '&nbsp;&nbsp;&nbsp;&nbsp;' for Pascal/Delphi).
<P><I><a href="#write">VF_write</a></I> will insert the separation string only in between the vector elements. At the end, after the last element, there is always a line feed (&quot;\n&quot;) instead of the separation string.
<P>SepString may contain up to twelve characters.
<BR><u>C/C++ only:</u>
<BR>If you use <I><a href="#write">VF_write</a></I> with the output sent directly to the printer (stream = <I>stdprn</I>), you probably have to explicitly use a carriage return character in addition to the line feed. To do this, call
<BR><I>VF_setWriteSeparate</I>( &quot;\n\r&quot;&nbsp;);</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>In the case of SepString longer than twelve characters, the program is aborted with the error message &quot;Invalid Parameter(s)&quot;.
<BR>The contents of SepString is not checked.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setWriteFormat">VF_setWriteFormat</a>,&nbsp;&nbsp; <a href="#setNWriteSeparate">VF_setNWriteSeparate</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#read">VF_read</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sgn"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sgn</b></font></td><td width="33%"><font size="+1"><b>VD_sgn</b></font></td><td><font size="+1"><b>VE_sgn</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Signum function, compares each element of a vector with 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_sgn( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::sgn( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_sgn( Y,&nbsp;X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sgn( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_sgn( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sgn( d_Y,&nbsp;d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_sgn( h_Y,&nbsp;h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is compared with 0 and the result of the comparison stored in Y:
<BR>Y<sub>i</sub> = +1.0, if X<sub>i</sub> &gt; 0
<BR>Y<sub>i</sub> = &nbsp;&nbsp;0.0, if X<sub>i</sub> = 0
<BR>Y<sub>i</sub> = &nbsp;-1.0, if X<sub>i</sub> &lt; 0.
<BR>This function is identical to <I><a href="#cmp0">VF_cmp0</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cmp_">VF_cmp_...</a>,&nbsp;&nbsp; <a href="#cmpC">VF_cmpC</a>,&nbsp;&nbsp; <a href="#cmpV">VF_cmpV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="shl"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_shl</b></font></td><td width="17%"><font size="+1"><b>VBI_shl</b></font></td><td width="17%"><font size="+1"><b>VSI_shl</b></font></td><td width="17%"><font size="+1"><b>VLI_shl</b></font></td><td width="17%"><font size="+1"><b>VQI_shl</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_shl</b></font></td><td width="17%"><font size="+1"><b>VUB_shl</b></font></td><td width="17%"><font size="+1"><b>VUS_shl</b></font></td><td width="17%"><font size="+1"><b>VUL_shl</b></font></td><td width="17%"><font size="+1"><b>VUQ_shl</b></font></td><td><font size="+1"><b>VUI_shl</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Shift to the left&quot;, i.e. multiply by integer powers of 2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_shl( iVector&nbsp;Y, iVector&nbsp;X, ui&nbsp;size, unsigned C&nbsp;);
<BR>void VUL_shl( ulVector&nbsp;Y, ulVector&nbsp;X, ui&nbsp;size, unsigned C&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::shl( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, unsigned C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_shl( Y,&nbsp;X:iVector; size:UIntSize; C:UInt&nbsp;);
<BR>procedure VUL_shl( Y,&nbsp;X:ulVector; size:UIntSize; C:UInt&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVImath.h&gt;
<BR>int cudaVI_shl( iVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size, unsigned C&nbsp;);
<BR>int cudaVUL_shl( ulVector&nbsp;d_Y, ulVector&nbsp;d_X, ui&nbsp;size, unsigned C&nbsp;);
<BR>void VIcu_shl( iVector&nbsp;h_Y, iVector&nbsp;h_X, ui&nbsp;size, unsigned C&nbsp;);
<BR>void VULcu_shl( ulVector&nbsp;h_Y, ulVector&nbsp;h_X, ui&nbsp;size, unsigned C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>function cudaVI_shl( d_Y,&nbsp;d_X:iVector; size:UIntSize; C:UInt&nbsp;):&nbsp;IntBool;
<BR>function cudaVUL_shl( d_Y,&nbsp;d_X:ulVector; size:UIntSize; C:UInt&nbsp;):&nbsp;IntBool;
<BR><BR>procedure VIcu_shl( h_Y,&nbsp;h_X:iVector; size:UIntSize; C:UInt&nbsp;);
<BR>procedure VULcu_shl( h_Y,&nbsp;h_X:ulVector; size:UIntSize; C:UInt&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> &lt;&lt; C
<BR>All bits of X<sub>i</sub> are shifted to the left by as many positions as indicated in the parameter C. This corresponds to a multiplication by 2<sup>C</sup>, neglecting possible overflow (in all versions) and loss of the sign bit (for signed numbers, i.e. in the <I>VI_,&nbsp;&nbsp; VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_</I>, and <I>VQI_</I> versions).
<BR>Note that by shifting 8-bit numbers (<I>VBI_,&nbsp;&nbsp; VUB_</I> versions) by more than 7 positions, any non-zero bit present in the original number is lost and the result is 0. The same is true for 16-bit numbers (<I>VSI_,&nbsp;&nbsp; VUS_</I> versions) shifted by more than 15 positions, for 32-bit numbers (<I>VLI_</I>, VUL_) shifted by more than 31 positions, and for 64-bit numbers (<I>VQI_</I>, VUQ_) shifted by more than 63 positions.
<BR>C is always of the data type unsigned. Shifting by negative numbers C is, therefore, not possible. To perform a right-shift, the appropriate function of the <I><a href="#shr">VI_shr</a></I> family has to be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mulC">VI_mulC</a>,&nbsp;&nbsp; <a href="#shr">VI_shr</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="shr"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="17%"><font size="+1"><b>VI_shr</b></font></td><td width="17%"><font size="+1"><b>VBI_shr</b></font></td><td width="17%"><font size="+1"><b>VSI_shr</b></font></td><td width="17%"><font size="+1"><b>VLI_shr</b></font></td><td width="17%"><font size="+1"><b>VQI_shr</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="17%"><font size="+1"><b>VU_shr</b></font></td><td width="17%"><font size="+1"><b>VUB_shr</b></font></td><td width="17%"><font size="+1"><b>VUS_shr</b></font></td><td width="17%"><font size="+1"><b>VUL_shr</b></font></td><td width="17%"><font size="+1"><b>VUQ_shr</b></font></td><td><font size="+1"><b>VUI_shr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Shift to the right&quot;, i.e., divide by integer powers of 2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_shr( iVector&nbsp;Y, iVector&nbsp;X, ui&nbsp;size,unsigned C&nbsp;);
<BR>void VUL_shr( ulVector&nbsp;Y, ulVector&nbsp;X, ui&nbsp;size, unsigned C&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::shr( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, unsigned C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_shr( Y,&nbsp;X:iVector; size:UIntSize; C:UInt&nbsp;);
<BR>procedure VUL_shr( Y,&nbsp;X:ulVector; size:UIntSize; C:UInt&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVImath.h&gt;
<BR>int cudaVI_shr( iVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size, unsigned C&nbsp;);
<BR>int cudaVUL_shr( ulVector&nbsp;d_Y, ulVector&nbsp;d_X, ui&nbsp;size, unsigned C&nbsp;);
<BR>void VIcu_shr( iVector&nbsp;h_Y, iVector&nbsp;h_X, ui&nbsp;size, unsigned C&nbsp;);
<BR>void VULcu_shr( ulVector&nbsp;h_Y, ulVector&nbsp;h_X, ui&nbsp;size, unsigned C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>function cudaVI_shr( d_Y,&nbsp;d_X:iVector; size:UIntSize; C:UInt&nbsp;):&nbsp;IntBool;
<BR>function cudaVUL_shr( d_Y,&nbsp;d_X:ulVector; size:UIntSize; C:UInt&nbsp;):&nbsp;IntBool;
<BR><BR>procedure VIcu_shr( h_Y,&nbsp;h_X:iVector; size:UIntSize; C:UInt&nbsp;);
<BR>procedure VULcu_shr( h_Y,&nbsp;h_X:ulVector; size:UIntSize; C:UInt&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> &gt;&gt; C
<BR>All bits of X<sub>i</sub> are shifted to the right by as many positions as indicated in the parameter C. This corresponds to an integer division by 2<sup>C</sup>. The sign of Y<sub>i</sub> is always the same as of X<sub>i</sub>. In contrast to explicit integer divisions, the result is always rounded toward minus infinity: -15 / 2 = -7, but -15 &gt;&gt; 1 = -8.
<BR>Note that by shifting 8-bit numbers by more than 7 positions, any unsigned or positive number yields 0, whereas any negative number yields -1 in this case.
<BR>The same is true for 16-bit numbers upon shifting by more than 15 positions, and for 32-bit numbers being shifted by more than 31 positions.
<P>C is always of the data type unsigned. Shifting by negative numbers C is, therefore, not possible. To perform a left-shift, the appropriate function of the <I><a href="#shl">VI_shl</a></I> family has to be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divC">VI_divC</a>,&nbsp;&nbsp; <a href="#shl">VI_shl</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sin</b></font></td><td width="33%"><font size="+1"><b>VD_sin</b></font></td><td><font size="+1"><b>VE_sin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sin</b></font></td><td width="33%"><font size="+1"><b>VDx_sin</b></font></td><td><font size="+1"><b>VEx_sin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_sin</b></font></td><td width="33%"><font size="+1"><b>VDr_sin</b></font></td><td><font size="+1"><b>VEr_sin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_sin</b></font></td><td width="33%"><font size="+1"><b>VDrx_sin</b></font></td><td><font size="+1"><b>VErx_sin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sin</b></font></td><td width="33%"><font size="+1"><b>VCD_sin</b></font></td><td><font size="+1"><b>VCE_sin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_sin</b></font></td><td width="33%"><font size="+1"><b>VCDx_sin</b></font></td><td><font size="+1"><b>VCEx_sin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sine function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sin( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_sin( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VFr_sin( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFrx_sin( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sin( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_sin( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>int vector&lt;T&gt;::r_sin( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::rx_sin( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sin( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_sin( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VFr_sin( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFrx_sin( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sin( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_sin( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_sin( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_sin( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_sin( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sin( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_sin( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_sin( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sin( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_sin( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sin( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;sin( A*X<sub>i</sub>+B&nbsp;)
<BR>For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as fractional multiples of <font face="symbol">p</font>, it is better to use <I><a href="#sinrpi">VF_sinrpi</a></I> than <I>VF_sin</I>.
<BR>If, on the other hand, one can be sure that all X<sub>i</sub> are within the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>, one can employ the faster reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I>. These reduced-range functions are not available for CUDA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors lead to a default result of 0.0 and a non-zero return value, but are ignored otherwise; <I>_matherr</I> is not called.
<BR>OVERFLOW errors can only occur in the complex versions and lead to a result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sin2">VF_sin2</a>,&nbsp;&nbsp; <a href="#sinrpi">VF_sinrpi</a>,&nbsp;&nbsp; <a href="#cos">VF_cos</a>,&nbsp;&nbsp; <a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#asin">VF_asin</a>,&nbsp;&nbsp; sin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sin2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sin2</b></font></td><td width="33%"><font size="+1"><b>VD_sin2</b></font></td><td><font size="+1"><b>VE_sin2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sin2</b></font></td><td width="33%"><font size="+1"><b>VDx_sin2</b></font></td><td><font size="+1"><b>VEx_sin2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_sin2</b></font></td><td width="33%"><font size="+1"><b>VDr_sin2</b></font></td><td><font size="+1"><b>VEr_sin2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_sin2</b></font></td><td width="33%"><font size="+1"><b>VDrx_sin2</b></font></td><td><font size="+1"><b>VErx_sin2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the sine function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sin2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_sin2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sin2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_sin2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sin2( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_sin2( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sin2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_sin2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_sin2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_sin2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_sin2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sin2( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_sin2( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_sin2( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sin2( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_sin2( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sin<sup>2</sup>( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;sin<sup>2</sup>( A*X<sub>i</sub>+B&nbsp;)
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards. The reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I> are for situations in which one can be sure that all input values lie in the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>. These reduced-range functions are not available for CUDA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors lead to a default result of 0.0 and a non-zero return value, but are otherwise ignored; <I>_matherr</I> is not called.
<BR>OVERFLOW errors can only occur in the complex versions and lead to a result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#sinrpi">VF_sinrpi</a></I>,&nbsp;&nbsp;sin</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sinc"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sinc</b></font></td><td width="33%"><font size="+1"><b>VD_sinc</b></font></td><td><font size="+1"><b>VE_sinc</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sinc</b></font></td><td width="33%"><font size="+1"><b>VDx_sinc</b></font></td><td><font size="+1"><b>VEx_sinc</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sinc function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sinc( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_sinc( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sinc( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_sinc( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sinc( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_sinc( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sinc( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_sinc( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_sinc( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_sinc( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_sinc( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sinc( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_sinc( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_sinc( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sinc( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_sinc( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sinc( X<sub>i</sub>&nbsp;) = sin( X<sub>i</sub>&nbsp;) / X<sub>i</sub>
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;sinc( A*X<sub>i</sub>+B&nbsp;)
<BR>The sinc function for an argument of 0.0 is defined as 1.0. The sinc function is the Fourier transform of a square pulse and is used, for example, to describe the diffraction pattern of a slit.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#sinrpi">VF_sinrpi</a>,&nbsp;&nbsp; sin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sincos"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sincos</b></font></td><td width="33%"><font size="+1"><b>VD_sincos</b></font></td><td><font size="+1"><b>VE_sincos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sincos</b></font></td><td width="33%"><font size="+1"><b>VDx_sincos</b></font></td><td><font size="+1"><b>VEx_sincos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_sincos</b></font></td><td width="33%"><font size="+1"><b>VDr_sincos</b></font></td><td><font size="+1"><b>VEr_sincos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_sincos</b></font></td><td width="33%"><font size="+1"><b>VDrx_sincos</b></font></td><td><font size="+1"><b>VErx_sincos</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sine and Cosine simultaneously</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sincos( fVector&nbsp;YSin, fVector&nbsp;YCos, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_sincos( fVector&nbsp;YSin, fVector&nbsp;YCos, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VFr_sincos( fVector&nbsp;YSin, fVector&nbsp;YCos, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFrx_sincos( fVector&nbsp;YSin, fVector&nbsp;YCos, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sincos( vector&lt;T&gt; YCos, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_sincos( vector&lt;T&gt; YCos, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>int vector&lt;T&gt;::r_sincos( vector&lt;T&gt; YCos, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::rx_sincos( vector&lt;T&gt; YCos, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sincos( Sin, Cos, X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_sincos( Sin, Cos, X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VFr_sincos( Sin, Cos, X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFrx_sincos( Sin, Cos, X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sincos( fVector&nbsp;d_YSin, fVector&nbsp;d_YCos, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_sincos( fVector&nbsp;d_YSin, fVector&nbsp;d_YCos, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_sincos( fVector&nbsp;d_YSin, fVector&nbsp;d_YCos, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_sincos( fVector&nbsp;h_YSin, fVector&nbsp;h_YCos, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_sincos( fVector&nbsp;h_YSin, fVector&nbsp;h_YCos, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sincos( d_YSin, d_YCos, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_sincos( d_YSin, d_YCos, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_sincos( d_YSin, d_YCos, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sincos( h_YSin, h_YCos, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_sincos( h_YSin, h_YCos, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: 
<BR>YSin<sub>i</sub> = sin( X<sub>i</sub>&nbsp;)
<BR>YCos<sub>i</sub> = cos( X<sub>i</sub>&nbsp;)
<BR>expanded versions: 
<BR>YSin<sub>i</sub> = C *&nbsp;sin( A*X<sub>i</sub>+B&nbsp;)
<BR>YCos<sub>i</sub> = C *&nbsp;cos( A*X<sub>i</sub>+B&nbsp;)
<BR>The sine and the cosine are calculated simultaneously, which is far more efficient than calculating them separately if both of them are needed. For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as fractional multiples of <font face="symbol">p</font>, it is better to use <I><a href="#sincosrpi">VF_sincosrpi</a></I> than <I>VF_sincos</I>.
<BR>If, on the other hand, one can be sure that all X<sub>i</sub> are within the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>, one can employ the faster reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors lead to a result of 0.0 for the sine and 1.0 for the cosine (as if the input were 0.0) along with a non-zero return value, but are otherwise ignored; <I>_matherr</I> is not called. Other errors should not occur.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sincos2">VF_sincos2</a>,&nbsp;&nbsp; <a href="#sincosrpi">VF_sincosrpi</a>,&nbsp;&nbsp; sin,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sincos2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sincos2</b></font></td><td width="33%"><font size="+1"><b>VD_sincos2</b></font></td><td><font size="+1"><b>VE_sincos2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sincos2</b></font></td><td width="33%"><font size="+1"><b>VDx_sincos2</b></font></td><td><font size="+1"><b>VEx_sinco2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_sincos2</b></font></td><td width="33%"><font size="+1"><b>VDr_sincos2</b></font></td><td><font size="+1"><b>VEr_sincos2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_sincos2</b></font></td><td width="33%"><font size="+1"><b>VDrx_sincos2</b></font></td><td><font size="+1"><b>VErx_sinco2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the sine and of the cosine simultaneously</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sincos2( fVector&nbsp;YSin2, fVector&nbsp;YCos2, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_sincos2( fVector&nbsp;YSin2, fVector&nbsp;YCos2, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int VFr_sincos2( fVector&nbsp;YSin, fVector&nbsp;YCos, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFrx_sincos2(fVector&nbsp;YSin, fVector&nbsp;YCos, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sincos2( vector&lt;T&gt; YCos2, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_sincos2( vector&lt;T&gt; YCos2, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>int vector&lt;T&gt;::r_sincos2( vector&lt;T&gt; YCos, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::rx_sincos2( vector&lt;T&gt; YCos, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sincos2( Sin, Cos, X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_sincos2( Sin, Cos, X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function VFr_sincos2( Sin, Cos, X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFrx_sincos2(Sin, Cos, X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sincos2( fVector&nbsp;d_YSin, fVector&nbsp;d_YCos, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_sincos2( fVector&nbsp;d_YSin, fVector&nbsp;d_YCos, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_sincos2( fVector&nbsp;d_YSin, fVector&nbsp;d_YCos, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_sincos2( fVector&nbsp;h_YSin, fVector&nbsp;h_YCos, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_sincos2( fVector&nbsp;h_YSin, fVector&nbsp;h_YCos, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sincos2( d_YSin, d_YCos, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_sincos2( d_YSin, d_YCos, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_sincos2( d_YSin, d_YCos, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sincos2( h_YSin, h_YCos, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_sincos2( h_YSin, h_YCos, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: 
<BR>YSin2<sub>i</sub> = sin<sup>2</sup>( X<sub>i</sub>&nbsp;)
<BR>YCos2<sub>i</sub> = cos<sup>2</sup>( X<sub>i</sub>&nbsp;)
<BR>expanded versions: 
<BR>YSin2<sub>i</sub> = C *&nbsp;sin<sup>2</sup>( A*X<sub>i</sub>+B&nbsp;)
<BR>YCos2<sub>i</sub> = C *&nbsp;cos<sup>2</sup>( A*X<sub>i</sub>+B&nbsp;)
<BR>The squared sine and the squared cosine are calculated simultaneously, which is far more efficient than calculating them separately, if both of them are needed.
<BR>The reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I> are for situations in which one can be sure that all input values lie in the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors lead to a result of 0.0 for the sin<sup>2</sup> and of 1.0 for the cos<sup>2</sup> (as if the input were 0.0) along with a non-zero return value, but are otherwise ignored; <I>_matherr</I> is not called. Other errors should not occur.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sincos">VF_sincos</a>,&nbsp;&nbsp; sin,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sincosrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sincosrpi</b></font></td><td width="33%"><font size="+1"><b>VD_sincosrpi</b></font></td><td><font size="+1"><b>VE_sincosrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sincosrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_sincosrpi2</b></font></td><td><font size="+1"><b>VE_sincosrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sincosrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_sincosrpi3</b></font></td><td><font size="+1"><b>VE_sincosrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sine and cosine of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sincosrpi( fVector&nbsp;YSin, fVector&nbsp;YCos, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_sincosrpi2( fVector&nbsp;YSin, fVector&nbsp;YCos, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_sincosrpi3( fVector&nbsp;YSin, fVector&nbsp;YCos, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sincosrpi( vector&lt;T&gt; YCos, const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::sincosrpi2( vector&lt;T&gt; YCos, const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::sincosrpi3( vector&lt;T&gt; YCos, const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sincosrpi( YSin, YCos:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_sincosrpi2( YSin, YCos:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_sincosrpi3( YSin, YCos:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sincosrpi( fVector&nbsp;d_YSin, fVector&nbsp;d_YCos, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_sincosrpi2( fVector&nbsp;d_YSin, fVector&nbsp;d_YCos, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_sincosrpi3( fVector&nbsp;d_YSin, fVector&nbsp;d_YCos, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_sincosrpi( fVector&nbsp;h_YSin, fVector&nbsp;h_YCos, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_sincosrpi2( fVector&nbsp;h_YSin, fVector&nbsp;h_YCos, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_sincosrpi3( fVector&nbsp;h_YSin, fVector&nbsp;h_YCos, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sincosrpi( d_YSin,&nbsp;d_YCos:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_sincosrpi2( d_YSin,&nbsp;d_YCos:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_sincosrpi3( d_YSin,&nbsp;d_YCos:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sincosrpi( h_YSin,&nbsp;h_YCos:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sincosrpi2( h_YSin,&nbsp;h_YCos:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sincosrpi3( h_YSin,&nbsp;h_YCos:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>YSin<sub>i</sub> = sin( (P<sub>i</sub> / q) *&nbsp;<font face="symbol">p</font>&nbsp;)
<BR>YCos<sub>i</sub> = cos( (P<sub>i</sub> / q) *&nbsp;<font face="symbol">p</font>&nbsp;)
<BR>The sine and the cosine of fractional multiples of <font face="symbol">p</font> are calculated. There are three versions: <I>VF_sincosrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_sincosrpi2</I> should be used which is a highly optimized version reading the results from a table named <I><a href="#sintab2">VF_sintab2</a></I>, if possible. If q is a multiple of 3, <I>VF_sincosrpi3</I> should be used which utilizes a table named <I><a href="#sintab2">VF_sintab3</a></I>. The use of <I>VF_sincosrpi3</I> is a convenient way to use degrees instead of radians; if, for example, q is 180, then the unit of the elements of P is &quot;degree&quot;. <I>VF_sincosrpi2</I> and <I>VF_sincosrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the (then useless) tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof, as long as q!=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sincos">VF_sincos</a>,&nbsp;&nbsp; sin,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sinh"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sinh</b></font></td><td width="33%"><font size="+1"><b>VD_sinh</b></font></td><td><font size="+1"><b>VE_sinh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sinh</b></font></td><td width="33%"><font size="+1"><b>VCD_sinh</b></font></td><td><font size="+1"><b>VCE_sinh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sinh</b></font></td><td width="33%"><font size="+1"><b>VDx_sinh</b></font></td><td><font size="+1"><b>VEx_sinh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_sinh</b></font></td><td width="33%"><font size="+1"><b>VCDx_sinh</b></font></td><td><font size="+1"><b>VCEx_sinh</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic sine function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sinh( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_sinh( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sinh( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_sinh( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sinh( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_sinh( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sinh( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_sinh( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_sinh( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_sinh( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_sinh( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sinh( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_sinh( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_sinh( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sinh( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_sinh( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sinh( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;sinh ( A*X<sub>i</sub>+B&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cosh">VF_cosh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; sinh</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sinrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sinrpi</b></font></td><td width="33%"><font size="+1"><b>VD_sinrpi</b></font></td><td><font size="+1"><b>VE_sinrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sinrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_sinrpi2</b></font></td><td><font size="+1"><b>VE_sinrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sinrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_sinrpi3</b></font></td><td><font size="+1"><b>VE_sinrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sine function of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sinrpi( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_sinrpi2( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_sinrpi3( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sinrpi( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::sinrpi2( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::sinrpi3( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sinrpi( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_sinrpi2( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_sinrpi3( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sinrpi( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_sinrpi2( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_sinrpi3( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_sinrpi( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_sinrpi2( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_sinrpi3( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sinrpi( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_sinrpi2( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_sinrpi3( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sinrpi( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sinrpi2( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sinrpi3( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = sin( (P<sub>i</sub> / q) *&nbsp;<font face="symbol">p</font>&nbsp;)
<BR>The sine of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_sinrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_sinrpi2</I> should be used which is a highly optimized version reading the results from a look-up table, if possible. If q is a multiple of 3, <I>VF_sinrpi3</I> should be used. <I>VF_sinrpi3</I> offers a convenient way to use degrees instead of radians; if, for example, q is 180, then the unit of the elements of P is &quot;degree&quot;. <I>VF_sinrpi2</I> and <I>VF_sinrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof, as long as q!=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sin">VF_sin</a>,&nbsp;&nbsp; sin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sintab2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sintab2</b></font></td><td width="33%"><font size="+1"><b>VD_sintab2</b></font></td><td><font size="+1"><b>VE_sintab2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sintab3</b></font></td><td width="33%"><font size="+1"><b>VD_sintab3</b></font></td><td><font size="+1"><b>VE_sintab3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">&nbsp;</TD><td>Table of sine values for arguments between 0 and <font face="symbol">p</font>/2</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_sintab2[ VF_tabsz2+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_sintab2[ VD_tabsz2+1 ];
<BR>extern extended&nbsp;VE_sintab2[ VE_tabsz2+1 ];
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_sintab3[ VF_tabsz3+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_sintab3[ VD_tabsz3+1 ];
<BR>extern extended&nbsp;VE_sintab3[ VE_tabsz3+1 ];</font>
<BR></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses FSINTAB2, DSINTAB2, ESINTAB2,
FSINTAB3, DSINTAB3, ESINTAB3;
<BR>VF_sintab2: array[0..VF_tabsz2] of Single;
<BR>VD_sintab2: array[0..VD_tabsz2] of Double;
<BR>VE_sintab2: array[0..VE_tabsz2] of Extended;
<BR>VF_sintab3: array[0..VF_tabsz3] of Single;
<BR>VD_sintab3: array[0..VD_tabsz3] of Double;
<BR>VE_sintab3: array[0..VE_tabsz3] of Extended;</font><BR></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>VF_sintab2[ i ] = sin( i/(2*VF_tabsz2) *&nbsp;<font face="symbol">p</font>&nbsp;), &nbsp;&nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz2
<BR>VF_sintab3[ i ] = sin( i/(2*VF_tabsz3) *&nbsp;<font face="symbol">p</font>&nbsp;), &nbsp;&nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz3
<BR>These look-up tables of sine values for arguments between 0 and <font face="symbol">p</font>/2 are used by <I><a href="#sinrpi">VF_sinrpi2</a></I> and the other functions of that family and are also available for other purposes.
<BR><u>C/C++:</u> The symbols VF_tabsz2 etc., denoting the size of the tables, are defined in &lt;xmath.h&gt;.
<BR><u>Pascal/Delphi:</u> The symbols VF_tabsz2 etc. are defined in the same units as the tables themselves.
<BR><u>FreePascal/Lazarus:</u> These tables are not available for FreePascal/Lazarus.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinrpi">VF_sinrpi2</a>,&nbsp;&nbsp; <a href="#tantab2">VF_tantab2</a>,&nbsp;&nbsp; <a href="#cosectab2">VF_cosectab2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="smooth"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_smooth</b></font></td><td width="33%"><font size="+1"><b>VD_smooth</b></font></td><td><font size="+1"><b>VE_smooth</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data smoothing</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_smooth( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, unsigned&nbsp;deg);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::smooth( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, unsigned&nbsp;deg&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_smooth( Y,&nbsp;X:fVector; size:UIntSize; deg:UInt&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_smooth( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, unsigned&nbsp;deg);
<BR>void VFcu_smooth( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, unsigned&nbsp;deg);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_smooth( d_Y,&nbsp;d_X:fVector; size:UIntSize; deg:UInt&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_smooth( h_Y,&nbsp;h_X:fVector; size:UIntSize; deg:UInt&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A primitive, but very fast low-frequency filtering of the vector X is performed. For each point, a weighted average of the point itself and its one or few nearest neighbours is calculated. The argument deg decides how many points are taken into accout. E.g., deg=3 means 3-point smoothing by the formula:
<BR>Y<sub>i</sub> = 0.25 *&nbsp;(2*X<sub>i</sub> + X<sub>i-1</sub> + X<sub>i+1</sub>)
<BR>Higher degrees (5, 7, 9...) of smoothing are achieved internally by repeated 3-point smoothing. deg = 0 or 1 means no smoothing at all; deg = 2 or 3 is interpreted as 3-point smoothing, deg = 4 or 5 as 5-point smoothing, and so on.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#filter">VF_filter</a>,&nbsp;&nbsp; <a href="#biquad">VF_biquad</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sort"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sort</b></font></td><td width="34%"><font size="+1"><b>VD_sort</b></font></td><td><font size="+1"><b>VE_sort</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_sort</b></font></td><td width="17%"><font size="+1"><b>VBI_sort</b></font></td><td width="17%"><font size="+1"><b>VSI_sort</b></font></td><td width="17%"><font size="+1"><b>VLI_sort</b></font></td><td width="17%"><font size="+1"><b>VQI_sort</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_sort</b></font></td><td width="17%"><font size="+1"><b>VUB_sort</b></font></td><td width="17%"><font size="+1"><b>VUS_sort</b></font></td><td width="17%"><font size="+1"><b>VUL_sort</b></font></td><td width="17%"><font size="+1"><b>VUQ_sort</b></font></td><td><font size="+1"><b>VUI_sort</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sorting into ascending or descending order</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_sort( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, int&nbsp;dir&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::sort( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, int&nbsp;dir=1&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_sort( Y,&nbsp;X:fVector; size:UIntSize; dir:Integer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_sort( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;dir&nbsp;);
<BR>void VFcu_sort( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, int&nbsp;dir&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_sort( d_Y,&nbsp;d_X:fVector; size:UIntSize; dir:Integer&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_sort( h_Y,&nbsp;h_X:fVector; size:UIntSize; dir:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector is sorted in ascending order, if dir is positive; negative dir yields descending order. The present implementation uses the &quot;Heapsort&quot; algorithm.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sortind">VF_sortind</a>,&nbsp;&nbsp; <a href="#rotate">VF_rotate</a>,&nbsp;&nbsp; <a href="#rev">VF_rev</a>,&nbsp;&nbsp; qsort</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sortind"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sortind</b></font></td><td width="34%"><font size="+1"><b>VD_sortind</b></font></td><td><font size="+1"><b>VE_sortind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_sortind</b></font></td><td width="17%"><font size="+1"><b>VBI_sortind</b></font></td><td width="17%"><font size="+1"><b>VSI_sortind</b></font></td><td width="17%"><font size="+1"><b>VLI_sortind</b></font></td><td width="17%"><font size="+1"><b>VQI_sortind</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_sortind</b></font></td><td width="17%"><font size="+1"><b>VUB_sortind</b></font></td><td width="17%"><font size="+1"><b>VUS_sortind</b></font></td><td width="17%"><font size="+1"><b>VUL_sortind</b></font></td><td width="17%"><font size="+1"><b>VUQ_sortind</b></font></td><td><font size="+1"><b>VUI_sortind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sort the index-array of a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_sortind( uiVector&nbsp;Ind, fVector&nbsp;X, ui&nbsp;size, int&nbsp;dir&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;ui&gt;::sortind( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, int&nbsp;dir=1&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_sortind( Ind:uiVector; X:fVector; size:UIntSize; dir:Integer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_sortind( uiVector&nbsp;d_Ind, fVector&nbsp;d_X, ui&nbsp;size, int&nbsp;dir&nbsp;);
<BR>void VFcu_sortind( uiVector&nbsp;h_IndY, fVector&nbsp;h_X, ui&nbsp;size, int&nbsp;dir&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_sortind( d_Ind:uiVector; d_X:fVector; size:UIntSize; dir:Integer&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_sortind( h_Ind:uiVector; h_X:fVector; size:UIntSize; dir:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The routine is similar to <I><a href="#sort">VF_sort</a></I>, but this time it is the index-array of X rather than the vector X itself that is ordered. Ascending order is obtained by setting dir to any positive number. Here, ascending order means that Ind<sub>0</sub> will contain the index of the smallest element of X, Ind<sub>1</sub> the index of the second-smallest, and so on, up to Ind<sub>size-1</sub>, the index of the largest element in X. Descending order is obtained by setting dir negative. In the case of two or more identical vector elements, the lower index comes first (regardless of the sortind direction).
<BR>This routine is used if other vectors are correlated with X and the correlation of the individual elements has to be maintained. After sorting the index-array, use <I><a href="#indpick">VF_indpick</a></I> (<I>VD_indpick,&nbsp;&nbsp; VI_indpick</I>, etc.) to actually perform the sorting of X and the other vectors correlated with X.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sort">VF_sort</a>,&nbsp;&nbsp; <a href="#indpick">VF_indpick</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="spectrum"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_spectrum</b></font></td><td width="33%"><font size="+1"><b>VD_spectrum</b></font></td><td><font size="+1"><b>VE_spectrum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Power-density spectrum</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_spectrum( fVector&nbsp;Spc, ui&nbsp;specsiz, fVector&nbsp;X, ui&nbsp;xsiz, fVector&nbsp;Win&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::spectrum( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Win&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_spectrum( Spc:fVector; specsiz:UIntSize; X:fVector; xsiz:UIntSize; Win:fVector&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_spectrum( float&nbsp;*h_psdfNyq, fVector&nbsp;d_Spc, ui&nbsp;specsiz, fVector&nbsp;d_X, ui&nbsp;xsiz, fVector&nbsp;d_Win&nbsp;);
<BR>int cusdVF_spectrum( float&nbsp;*d_psdfNyq, fVector&nbsp;d_Spc, ui&nbsp;specsiz, fVector&nbsp;d_X, ui&nbsp;xsiz, fVector&nbsp;d_Win&nbsp;);
<BR>float VFcu_spectrum( fVector&nbsp;h_Spc, ui&nbsp;specsiz, fVector&nbsp;h_X, ui&nbsp;xsiz, fVector&nbsp;h_Win&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_spectrum( var&nbsp;h_psdfNyq:Single; d_Spc:fVector; specsiz:UIntSize; d_X:fVector; xsiz:UIntSize; d_Win:fVector&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_spectrum( d_psdfNyq:PSingle; d_Spc:fVector; specsiz:UIntSize; d_X:fVector; xsiz:UIntSize; d_Win:fVector&nbsp;):&nbsp;IntBool;
<BR>function VFcu_spectrum( h_Spc:fVector; specsiz:UIntSize; h_X:fVector; xsiz:UIntSize; h_Win:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The data set X is analyzed for its power spectral density (PSD), i.e. the mean square amplitude. The result is stored in Spc. xsiz must be at least 2*specsiz, and specsiz has to be an integer power of 2. Internally, X is divided into xsiz*specsiz/2 segments and the average over the spectra of the individual segments is calculated. Each segment of length 2*specsiz yields the PSD for specsiz+1 frequencies (see <I><a href="#FFT">VF_FFT</a></I>). In order to keep specsiz an integer power of 2, there are only specsiz points stored in Spc and the last one, the PSD at the Nyquist frequency <I>f<sub>Nyquist</sub></I> = 0.5 / <I>sampling_interval</I>, is given as the return value of the function. It may either be neglected (by calling the function like a void function) or stored as the last element in Spc by calling the function as
<BR><font face="courier new">Spc[specsiz] = VF_spectrum( Spc, specsiz, X, xsiz, Win&nbsp;);</font>
<BR>in this case, Spc must have a length of specsiz+1.
<P>Win is a window that is applied to the data segments. The size of the Win vector must be 2*specsiz. Within the <I>VectorLib</I> library, three functions are available that give suitable Windows: <I><a href="#Welch">VF_Welch</a>,&nbsp;&nbsp; <a href="#Parzen">VF_Parzen</a></I>, and <I><a href="#Hann">VF_Hann</a></I>. A square window (i.e. no windowing at all) is achieved by setting all elements of Win to 1.0 using <I><a href="#equ1">VF_equ1</a></I>. Use of the square window is not recommended here, though.
<P>You may wish to test the quality of the calculated spectrum by applying Parseval's theorem (provided you called <I>VF_spectrum</I> as in the above example and stored the PSD for the Nyquist frequency):
<BR>1.0/xsize *&nbsp;<I><a href="#ssq">VF_ssq</a></I>( X, xsize&nbsp;) must be about equal to <I><a href="#sum">VF_sum</a></I>( Spc, specsiz+1&nbsp;).
<BR>If the deviation between both results is large, the sampling interval in X probably is too large.
<P>For an example for this function, see the demo program VDEMO.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_spectrum</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>PSD at the Nyquist frequency</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#filter">VF_filter</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="splinederiv2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_splinederiv2</b></font></td><td width="33%"><font size="+1"><b>VD_splinederiv2</b></font></td><td><font size="+1"><b>VE_splinederiv2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Generate a second-derivative table from an X-Y-table to be used for cubic-spline interpolation.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_splinederiv2( fVector&nbsp;Y2, fVector&nbsp;XTab, fVector&nbsp;YTab, ui&nbsp;size, int&nbsp;specify, float&nbsp;Yp0, float&nbsp;Ypn&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::splinederiv2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;XTab, const&nbsp;vector&lt;T&gt;&amp;&nbsp;YTab, int&nbsp;specify, T&nbsp;Yp0, T&nbsp;Ypn&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_splinederiv2( Y2, XTab,&nbsp;YTab:fVector; size:UIntSize; specify:IntBool; Yp0,&nbsp;Ypn:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_splinederiv2( fVector&nbsp;d_Y2, fVector&nbsp;d_XTab, fVector&nbsp;d_YTab, ui&nbsp;size, int&nbsp;specify, float&nbsp;Yp0, float&nbsp;Ypn&nbsp;);
<BR>int cusdVF_splinederiv2( fVector&nbsp;d_Y2, fVector&nbsp;d_XTab, fVector&nbsp;d_YTab, ui&nbsp;size, int&nbsp;specify, float&nbsp;*d_Yp0, float&nbsp;*d_Ypn&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_splinederiv2( d_Y2,&nbsp;d_XTab,&nbsp;d_YTab:fVector; size:UIntSize; specify:IntBool; Yp0,&nbsp;Ypn:Single&nbsp;);
<BR>function cusdVF_splinederiv2( d_Y2,&nbsp;d_XTab,&nbsp;d_YTab:fVector; size:UIntSize; specify:IntBool; d_Yp0,&nbsp;d_Ypn:PSingle&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A table of second derivatives of YTab is generated to be used for cubic-spline interpolation with <I><a href="#splineinterpol">VF_splineinterpol</a></I>. In order to get a unique solution, two additional conditions have to be specified. Setting specify to FALSE (0) yields the &quot;natural cubic spline&quot; with Y2 being set to zero at both end-points; in this case, Yp0 and Ypn have no influence. Setting specify to TRUE (1) yields Y2 calculated in such a way that the first(!) derivative at the zero'th and at the last position equals Yp0 and Ypn, resp.
<P>CUDA versions only: These functions are very slow, as the actual calculation of the derivative table is performed on the CPU rather than on the GPU. This is also the reason why there are no <i>V?cu_</i> versions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#splineinterpol">VF_splineinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="splineinterpol"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_splineinterpol</b></font></td><td width="33%"><font size="+1"><b>VD_splineinterpol</b></font></td><td><font size="+1"><b>VE_splineinterpol</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cubic-spline interpolation of X-Y-table values with given second derivatives of the table</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_splineinterpol( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;sizex, fVector&nbsp;XTab, fVector&nbsp;YTab, fVector&nbsp;Y2Tab, ui&nbsp;sizetab&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::splineinterpol( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;XTab, const&nbsp;vector&lt;T&gt;&amp;&nbsp;YTab, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y2Tab&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_splineinterpol( Y,&nbsp;X:fVector; sizex:UIntSize; XTab,&nbsp;YTab,&nbsp;Y2Tab:fVector; sizetab:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_splineinterpol( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;sizex, fVector&nbsp;d_XTab, fVector&nbsp;d_YTab, fVector&nbsp;d_Y2Tab, ui&nbsp;sizetab&nbsp;);
<BR>void VFcu_splineinterpol( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;sizex, fVector&nbsp;h_XTab, fVector&nbsp;h_YTab, fVector&nbsp;h_Y2Tab, ui&nbsp;sizetab&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_splineinterpol( d_Y,&nbsp;d_X:fVector; sizex:UIntSize; d_XTab,&nbsp;d_YTab,&nbsp;d_Y2Tab:fVector; sizetab:UIntSize&nbsp;);
<BR>procedure VFcu_splineinterpol( h_Y,&nbsp;h_X:fVector; sizex:UIntSize; h_XTab,&nbsp;h_YTab,&nbsp;h_Y2Tab:fVector; sizetab:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each of the sizex elements of X, the corresponding element of Y is interpolated from the XTab-YTab value pairs. A table of second derivatives of YTab is needed that has to be generated by a call to <I><a href="#splinederiv2">VF_splinederiv2</a></I> prior to calling <I>VF_splineinterpol</I>. XTab must be ordered (either ascending or descending). All values of XTab must be distinct; otherwise a division by zero may occur and lead to a program abort. sizetab must be greater than or equal to 3.
<BR>For a simplified alternative to this function, consider <I><a href="#natCubSplineInterpol">VF_natCubSplineInterpol</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (you have to take care yourself that the XTab values are distinct and that the YTab values are not near the limit of overflowing).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#natCubSplineInterpol">VF_natCubSplineInterpol</a>,&nbsp;&nbsp; <a href="#splinederiv2">VF_splinederiv2</a>,&nbsp;&nbsp; <a href="#ratinterpol">VF_ratinterpol</a>,&nbsp;&nbsp; <a href="#polyinterpol">VF_polyinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="square"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_square</b></font></td><td width="33%"><font size="+1"><b>VD_square</b></font></td><td><font size="+1"><b>VE_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_square</b></font></td><td width="33%"><font size="+1"><b>VDx_square</b></font></td><td><font size="+1"><b>VEx_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFu_square</b></font></td><td width="33%"><font size="+1"><b>VDu_square</b></font></td><td><font size="+1"><b>VEu_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFux_square</b></font></td><td width="33%"><font size="+1"><b>VDux_square</b></font></td><td><font size="+1"><b>VEux_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_square</b></font></td><td width="33%"><font size="+1"><b>VCD_square</b></font></td><td><font size="+1"><b>VCE_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_square</b></font></td><td width="33%"><font size="+1"><b>VCDx_square</b></font></td><td><font size="+1"><b>VCEx_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFu_square</b></font></td><td width="33%"><font size="+1"><b>VCDu_square</b></font></td><td><font size="+1"><b>VCEu_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFux_square</b></font></td><td width="33%"><font size="+1"><b>VCDux_square</b></font></td><td><font size="+1"><b>VCEux_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_square</b></font></td><td width="33%"><font size="+1"><b>VPD_square</b></font></td><td><font size="+1"><b>VPE_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPFu_square</b></font></td><td width="33%"><font size="+1"><b>VPDu_square</b></font></td><td><font size="+1"><b>VPEu_square</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_square( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_square( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int VFu_square( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFux_square( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::square( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_square( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);
<BR>int vector&lt;T&gt;::u_square( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::ux_square( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_square( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_square( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function VFu_square( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFux_square( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_square( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_square( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_square( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int VFucu_square( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFuxcu_square( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cudaVFu_square( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFux_square( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFux_square( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int VFucu_square( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFuxcu_square( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_square( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_square( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_square( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_square( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_square( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cudaVFu_square( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFux_square( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFux_square( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFucu_square( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFuxcu_square( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = X<sub>i</sub><sup>2</sup>
<BR>expanded versions: Y<sub>i</sub> = (A*X<sub>i</sub>+B)<sup>2</sup>
<P>The &quot;unprotected&quot; versions (prefix <I>VFu_,&nbsp;&nbsp; VFux_</I>, etc.) do not perform any error handling, which makes them much faster (up to 50%), but riskier than the standard versions. The extended-precision complex (<I>VCEu_</I> and <I>VCEux_</I>) versions do not take some of the security measures present in the standard version and might fail for results very near the overflow limit; results near the underflow limit might be rendered as 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cubic">VF_cubic</a>,&nbsp;&nbsp; <a href="#sqrt">VF_sqrt</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sqrt"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sqrt</b></font></td><td width="33%"><font size="+1"><b>VD_sqrt</b></font></td><td><font size="+1"><b>VE_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFu_sqrt</b></font></td><td width="33%"><font size="+1"><b>VDu_sqrt</b></font></td><td><font size="+1"><b>VEu_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sqrt</b></font></td><td width="33%"><font size="+1"><b>VCD_sqrt</b></font></td><td><font size="+1"><b>VCE_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sqrt</b></font></td><td width="33%"><font size="+1"><b>VDx_sqrt</b></font></td><td><font size="+1"><b>VEx_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFux_sqrt</b></font></td><td width="33%"><font size="+1"><b>VDux_sqrt</b></font></td><td><font size="+1"><b>VEux_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_sqrt</b></font></td><td width="33%"><font size="+1"><b>VCDx_sqrt</b></font></td><td><font size="+1"><b>VCEx_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_sqrt</b></font></td><td width="33%"><font size="+1"><b>VPD_sqrt</b></font></td><td><font size="+1"><b>VPE_sqrt</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square root</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sqrt( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_sqrt( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sqrt( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_sqrt( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sqrt( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_sqrt( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sqrt( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_sqrt( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_sqrt( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_sqrt( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_sqrt( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sqrt( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_sqrt( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_sqrt( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sqrt( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_sqrt( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sqrt( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;sqrt( A*X<sub>i</sub>+B&nbsp;)
<P>The &quot;unprotected&quot; versions (prefix <I>VFu_,&nbsp;&nbsp; VFux_</I>, etc.) do not perform any error handling, which makes them much faster (up to 350% for <I>VFux_sqrt</I>) than the standard versions. On the other hand, any negative input number may lead to an uncontrolled programme crash. Input numbers near the underflow limit may lead to a result of 0. Apart from allowing no negative input numbers, the &quot;unprotected&quot; expanded version (prefix <I>VFux_</I>) also requires that neither the product A*X<sub>i</sub> nor the sum A*X<sub>i</sub>+B may overflow.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>DOMAIN errors occur if, in the real-number versions, the square root of a negative numbers is requested; NAN (&quot;not-a-number&quot;) is the default result in this case.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#square">VF_square</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ssq"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ssq</b></font></td><td width="33%"><font size="+1"><b>VD_ssq</b></font></td><td><font size="+1"><b>VE_ssq</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum-of-squares</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_ssq( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::ssq();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_ssq( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_ssq( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_ssq( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_ssq( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_ssq( var&nbsp;h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_ssq( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_ssq( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>ssq = sum( X<sub>i</sub><sup>2</sup>&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but be careful: this function may lead to an overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the squares of the vector elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#rms">VF_rms</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#scalprod">VF_scalprod</a>,&nbsp;&nbsp; <a href="#Euclid">VF_Euclid</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ssqdevC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ssqdevC</b></font></td><td width="33%"><font size="+1"><b>VD_ssqdevC</b></font></td><td><font size="+1"><b>VE_ssqdevC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum of the squares of the deviations from a preset value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_ssqdevC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::ssqdevC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_ssqdevC( X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_ssqdevC( float *h_RetVal, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_ssqdevC( float *d_RetVal, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>float VFcu_ssqdevC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_ssqdevC( var h_RetVal:Single; d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_ssqdevC( d_RetVal:PSingle; d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_ssqdevC( h_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>ssqdevC = sum( (X<sub>i</sub> - C)<sup>2</sup>&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the squares of the deviations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevV">VF_ssqdevV</a>,&nbsp;&nbsp; <a href="#avdevC">VF_avdevC</a>,&nbsp;&nbsp; <a href="#sumdevC">VF_sumdevC</a>,&nbsp;&nbsp; <a href="#chi2">VF_chi2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ssqdevV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ssqdevV</b></font></td><td width="33%"><font size="+1"><b>VD_ssqdevV</b></font></td><td><font size="+1"><b>VE_ssqdevV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum of the squares of the deviations of the elements of one vector from the corresponding elements of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_ssqdevV( fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::ssqdevV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_ssqdevV( X,&nbsp;Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_ssqdevV( float *h_RetVal, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>int cusdVF_ssqdevV( float *d_RetVal, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>float VFcu_ssqdevV( fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_ssqdevV( var h_RetVal:Single; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_ssqdevV( d_RetVal:PSingle; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_ssqdevV( h_X, h_Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>ssqdevV = sum( (X<sub>i</sub> - Y<sub>i</sub>)<sup>2</sup>&nbsp;)
<BR>The deviation of each element of X from the corresponding element of Y is calculated and the squares of the deviations summed up and returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the squares of the deviations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#avdevV">VF_avdevV</a>,&nbsp;&nbsp; <a href="#sumdevV">VF_sumdevV</a>,&nbsp;&nbsp; <a href="#chi2">VF_chi2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="store"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_store</b></font></td><td width="34%"><font size="+1"><b>VD_store</b></font></td><td><font size="+1"><b>VE_store</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_store</b></font></td><td width="34%"><font size="+1"><b>VCD_store</b></font></td><td><font size="+1"><b>VCE_store</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_store</b></font></td><td width="34%"><font size="+1"><b>VPD_store</b></font></td><td><font size="+1"><b>VPE_store</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_store</b></font></td><td width="17%"><font size="+1"><b>VBI_store</b></font></td><td width="17%"><font size="+1"><b>VSI_store</b></font></td><td width="17%"><font size="+1"><b>VLI_store</b></font></td><td width="17%"><font size="+1"><b>VQI_store</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_store</b></font></td><td width="17%"><font size="+1"><b>VUB_store</b></font></td><td width="17%"><font size="+1"><b>VUS_store</b></font></td><td width="17%"><font size="+1"><b>VUL_store</b></font></td><td width="17%"><font size="+1"><b>VUQ_store</b></font></td><td><font size="+1"><b>VUI_store</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Store a vector in binary format into a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_store( FILE *stream, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::store( FILE *stream&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_store( var Stream:FILE; X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>void cudaVF_store( FILE&nbsp;*stream, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void cudaVF_store_buf( FILE&nbsp;*stream, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure cudaVF_store( var Stream:FILE; d_X:fVector; size:UIntSize&nbsp;);
<BR>procedure cudaVF_store_buf( var Stream:FILE; d_X:fVector; size:UIntSize; h_Wk:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>size</I> elements of X are written to stream in binary format. The stream must be already open for binary write operations.
<BR>The <I>VecObj</I> version stores not only the vector elements, but the whole <U>vector object</U> by first storing <I>size</I>. Please note that <I><a href="#recall">VF_recall</a></I> etc. can only read vectors stored with <I>VF_store</I> etc., whereas the <I>VecObj</I> function <I>recall</I> is used to retrieve vector objects stored with the <I>VecObj</I> function <I>store</I>. You can, however, employ the calling sequence
<BR><font face="courier new">VUI_store( stream, &amp;size, 1&nbsp;);
<BR>VF_store( stream, X, size&nbsp;);  &nbsp;&nbsp;/*&nbsp;C/C++ */ </font>
<BR>or
<BR><font face="courier new">VU_store( stream, @size, 1&nbsp;);
<BR>VF_store( stream, X, size&nbsp;); &nbsp;&nbsp;(*&nbsp;Pascal/Delphi *)</font>
<BR>to make the stored vector X readable as a vector object later.
<P>CUDA versions only: <i>cudaV?_store_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as X. By avoiding the need of <i>cudaV?_store</i> to allocate its own buffer memory, <i>cudaV?_store_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#recall">VF_recall</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#cprint">VF_cprint</a>,&nbsp;&nbsp; <a href="#print">VF_print</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subC</b></font></td><td width="34%"><font size="+1"><b>VD_subC</b></font></td><td><font size="+1"><b>VE_subC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subC</b></font></td><td width="34%"><font size="+1"><b>VCD_subC</b></font></td><td><font size="+1"><b>VCE_subC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subReC</b></font></td><td width="34%"><font size="+1"><b>VCD_subReC</b></font></td><td><font size="+1"><b>VCE_subReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_subC</b></font></td><td width="17%"><font size="+1"><b>VBI_subC</b></font></td><td width="17%"><font size="+1"><b>VSI_subC</b></font></td><td width="17%"><font size="+1"><b>VLI_subC</b></font></td><td width="17%"><font size="+1"><b>VQI_subC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_subC</b></font></td><td width="17%"><font size="+1"><b>VUB_subC</b></font></td><td width="17%"><font size="+1"><b>VUS_subC</b></font></td><td width="17%"><font size="+1"><b>VUL_subC</b></font></td><td width="17%"><font size="+1"><b>VUQ_subC</b></font></td><td><font size="+1"><b>VUI_subC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Subtract a constant from each vector element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VCF_subC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>void VCF_subReC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::subC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::subReC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;CRe&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VCF_subC( Y,&nbsp;X:cfVector; size:UIntSize; C:fComplex&nbsp;);
<BR>procedure VCF_subReC( Y,&nbsp;X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_subC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_subC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_subC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVCF_subReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);
<BR>int cusdVCF_subReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_CRe&nbsp;);
<BR>void VCFcu_subReC( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_subC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_subC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_subC( h_Y, h_X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>function cudaVCF_subReC( d_Y, d_X:cfVector; size:UIntSize; CRe:Single&nbsp;);
<BR>function cusdVCF_subReC( d_Y, d_X:cfVector; size:UIntSize; d_CRe:PSingle&nbsp;);
<BR>procedure VCFcu_subReC( h_Y, h_X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> - C
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe subtracted from the complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#subrC">VF_subrC</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subrC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrC</b></font></td><td width="34%"><font size="+1"><b>VD_subrC</b></font></td><td><font size="+1"><b>VE_subrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subrC</b></font></td><td width="34%"><font size="+1"><b>VCD_subrC</b></font></td><td><font size="+1"><b>VCE_subrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subrReC</b></font></td><td width="34%"><font size="+1"><b>VCD_subrReC</b></font></td><td><font size="+1"><b>VCE_subrReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_subrC</b></font></td><td width="17%"><font size="+1"><b>VBI_subrC</b></font></td><td width="17%"><font size="+1"><b>VSI_subrC</b></font></td><td width="17%"><font size="+1"><b>VLI_subrC</b></font></td><td width="17%"><font size="+1"><b>VQI_subrC</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_subrC</b></font></td><td width="17%"><font size="+1"><b>VUB_subrC</b></font></td><td width="17%"><font size="+1"><b>VUS_subrC</b></font></td><td width="17%"><font size="+1"><b>VUL_subrC</b></font></td><td width="17%"><font size="+1"><b>VUQ_subrC</b></font></td><td><font size="+1"><b>VUI_subrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse subtraction: subtract a vector from a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subrC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VCF_subrC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, fComplex&nbsp;C&nbsp;);
<BR>void VCF_subrReC( cfVector&nbsp;Y, cfVector&nbsp;X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subrC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::subrC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, complex&lt;T&gt; C&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::subrReC( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;CRe&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subrC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VCF_subrC( Y,&nbsp;X:cfVector; size:UIntSize; C:fComplex&nbsp;);
<BR>procedure VCF_subrReC( Y,&nbsp;X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_subrC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_subrC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_subrC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVCF_subrReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);
<BR>int cusdVCF_subrReC( cfVector&nbsp;d_Y, cfVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_CRe&nbsp;);
<BR>void VCFcu_subrReC( cfVector&nbsp;h_Y, cfVector&nbsp;h_X, ui&nbsp;size, float&nbsp;CRe&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_subrC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_subrC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_subrC( h_Y, h_X:fVector; size:UIntSize; C:Single&nbsp;);
<BR>function cudaVCF_subrReC( d_Y, d_X:cfVector; size:UIntSize; CRe:Single&nbsp;);
<BR>function cusdVCF_subrReC( d_Y, d_X:cfVector; size:UIntSize; d_CRe:PSingle&nbsp;);
<BR>procedure VCFcu_subrReC( h_Y, h_X:cfVector; size:UIntSize; CRe:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = C - X<sub>i</sub>
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe from which the complex vector is subtracted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subrV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrV</b></font></td><td width="34%"><font size="+1"><b>VD_subrV</b></font></td><td><font size="+1"><b>VE_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subrV</b></font></td><td width="34%"><font size="+1"><b>VCD_subrV</b></font></td><td><font size="+1"><b>VCE_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subrReV</b></font></td><td width="34%"><font size="+1"><b>VCD_subrReV</b></font></td><td><font size="+1"><b>VCE_subrReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_subrV</b></font></td><td width="34%"><font size="+1"><b>VDx_subrV</b></font></td><td><font size="+1"><b>VEx_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_subrV</b></font></td><td width="34%"><font size="+1"><b>VCDx_subrV</b></font></td><td><font size="+1"><b>VCEx_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_subrReV</b></font></td><td width="34%"><font size="+1"><b>VCDx_subrReV</b></font></td><td><font size="+1"><b>VCEx_subrReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_subrV</b></font></td><td width="17%"><font size="+1"><b>VBI_subrV</b></font></td><td width="17%"><font size="+1"><b>VSI_subrV</b></font></td><td width="17%"><font size="+1"><b>VLI_subrV</b></font></td><td width="17%"><font size="+1"><b>VQI_subrV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_subrV</b></font></td><td width="17%"><font size="+1"><b>VUB_subrV</b></font></td><td width="17%"><font size="+1"><b>VUS_subrV</b></font></td><td width="17%"><font size="+1"><b>VUL_subrV</b></font></td><td width="17%"><font size="+1"><b>VUQ_subrV</b></font></td><td><font size="+1"><b>VUI_subrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Subtraction in reverse order</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subrV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VFx_subrV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>void VCF_subrV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCF_subrReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCFx_subrV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFx_subrReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subrV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::x_subrV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::subrV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::subrReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_subrV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_subrReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subrV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFx_subrV( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B:Single);
<BR>procedure VCF_subrV( Z, X,&nbsp;Y:cfVector; size:UIntSize&nbsp;);
<BR>procedure VCF_subrReV( Z, X:cfVector; Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCFx_subrV( Z, X,&nbsp;Y:cfVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);
<BR>procedure VCFx_subrReV( Z, X:cfVector; Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVF_subrV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVFs_subrV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVFs_subrV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>int cudaVFx_subrV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_subrV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int cudaVCF_subrReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>int cudaVCFx_subrReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>int cusdVCFx_subrReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;*d_A, fComplex&nbsp;*d_B&nbsp;);
<BR>void VFcu_subrV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFscu_subrV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFxcu_subrV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>void VCFcu_subrReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);
<BR>void VCFxcu_subrV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, cfVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFxcu_subrReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_subrV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFs_subrV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFs_subrV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_subrV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_subrV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVCF_subrReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVCFx_subrReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;):&nbsp;IntBool;
<BR>function cusdVCFx_subrReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PfComplex&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_subrV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFscu_subrV( h_Z, h_X, h_Y:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VFxcu_subrV( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);
<BR>procedure VCFcu_subrReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCFxcu_subrReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = Y<sub>i</sub> - X<sub>i</sub>
<BR>expanded versions: Z<sub>i</sub> = Y<sub>i</sub> - (A*X<sub>i</sub>+B)
<BR>The complex floating-point versions exist in two variants: in the first variant (e.g., <I>VCF_subrV,&nbsp;&nbsp; VCFx_subrV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g., <I>VCF_subrReV</I> - &quot;reverse subtraction of a real vector&quot;, i.e., subtraction of a complex vector from a real vector).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subrC">VF_subrC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#subrVI">VF_subrVI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subrVI"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrVI</b></font></td><td width="33%"><font size="+1"><b>VD_subrVI</b></font></td><td><font size="+1"><b>VE_subrVI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrVBI</b></font></td><td width="33%"><font size="+1"><b>VD_subrVBI</b></font></td><td><font size="+1"><b>VE_subrVBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrVSI</b></font></td><td width="33%"><font size="+1"><b>VD_subrVSI</b></font></td><td><font size="+1"><b>VE_subrVSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrVLI</b></font></td><td width="33%"><font size="+1"><b>VD_subrVLI</b></font></td><td><font size="+1"><b>VE_subrVLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrVQI</b></font></td><td width="33%"><font size="+1"><b>VD_subrVQI</b></font></td><td><font size="+1"><b>VE_subrVQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrVU</b></font></td><td width="33%"><font size="+1"><b>VD_subrVU</b></font></td><td><font size="+1"><b>VE_subrVU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrVUB</b></font></td><td width="33%"><font size="+1"><b>VD_subrVUB</b></font></td><td><font size="+1"><b>VE_subrVUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrVUS</b></font></td><td width="33%"><font size="+1"><b>VD_subrVUS</b></font></td><td><font size="+1"><b>VE_subrVUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrVUL</b></font></td><td width="33%"><font size="+1"><b>VD_subrVUL</b></font></td><td><font size="+1"><b>VE_subrVUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrVUQ</b></font></td><td width="33%"><font size="+1"><b>VD_subrVUQ</b></font></td><td><font size="+1"><b>VE_subrVUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrVUI</b></font></td><td width="33%"><font size="+1"><b>VD_subrVUI</b></font></td><td><font size="+1"><b>VE_subrVUI</b></font></td></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse subtraction: subtract a floating-point vector from an integer vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subrVI( fVector&nbsp;Z, fVector&nbsp;X, iVector&nbsp;Y,ui&nbsp;size&nbsp;);
<BR>void VF_subrVUB( fVector&nbsp;Z, fVector&nbsp;X, ubVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subrVI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;int&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::subrVUS( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;unsigned short&gt;&amp;&nbsp;Y,&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subrVI( Z, X:fVector; Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VF_subrVUL( Z, X:fVector; Y:ulVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_subrVI( fVector&nbsp;d_Z, fVector&nbsp;d_X, iVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVF_subrVUB( fVector&nbsp;d_Z, fVector&nbsp;d_X, ubVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>void VFcu_subrVI( fVector&nbsp;h_Z, fVector&nbsp;h_X, iVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFcu_subrVUB( fVector&nbsp;h_Z, fVector&nbsp;h_X, ubVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_subrVI( d_Z, d_X:fVector; d_Y:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_subrVUL( d_Z, d_X:fVector; d_Y:ulVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_subrVI( h_Z, h_X:fVector; h_Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VFcu_subrVUL( h_Z, h_X:fVector; h_Y:ulVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = Y<sub>i</sub> - X<sub>i</sub>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subrV">VF_subrV</a>,&nbsp;&nbsp; <a href="#subVI">VF_subVI</a>,&nbsp;&nbsp; <a href="#addVI">VF_addVI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subV</b></font></td><td width="34%"><font size="+1"><b>VD_subV</b></font></td><td><font size="+1"><b>VE_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subV</b></font></td><td width="34%"><font size="+1"><b>VCD_subV</b></font></td><td><font size="+1"><b>VCE_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subReV</b></font></td><td width="34%"><font size="+1"><b>VCD_subReV</b></font></td><td><font size="+1"><b>VCE_subReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFs_subV</b></font></td><td width="34%"><font size="+1"><b>VDs_subV</b></font></td><td><font size="+1"><b>VEs_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_subV</b></font></td><td width="34%"><font size="+1"><b>VDx_subV</b></font></td><td><font size="+1"><b>VEx_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_subV</b></font></td><td width="34%"><font size="+1"><b>VCDx_subV</b></font></td><td><font size="+1"><b>VCEx_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_subReV</b></font></td><td width="34%"><font size="+1"><b>VCDx_subReV</b></font></td><td><font size="+1"><b>VCEx_subReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_subV</b></font></td><td width="17%"><font size="+1"><b>VBI_subV</b></font></td><td width="17%"><font size="+1"><b>VSI_subV</b></font></td><td width="17%"><font size="+1"><b>VLI_subV</b></font></td><td width="17%"><font size="+1"><b>VQI_subV</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_subV</b></font></td><td width="17%"><font size="+1"><b>VUB_subV</b></font></td><td width="17%"><font size="+1"><b>VUS_subV</b></font></td><td width="17%"><font size="+1"><b>VUL_subV</b></font></td><td width="17%"><font size="+1"><b>VUQ_subV</b></font></td><td><font size="+1"><b>VUI_subV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Subtract two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VFs_subV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFx_subV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>void VCF_subV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCF_subReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VCFx_subV( cfVector&nbsp;Z, cfVector&nbsp;X, cfVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFx_subReV( cfVector&nbsp;Z, cfVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::s_subV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;T&gt;::x_subV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::subV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::subReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_subV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_subReV( const&nbsp;vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, complex&lt;T&gt; A, complex&lt;T&gt; B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFx_subV( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B:Single);
<BR>procedure VCF_subV( Z, X,&nbsp;Y:cfVector; size:UIntSize&nbsp;);
<BR>procedure VCF_subReV( Z, X:cfVector; Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCFx_subV( Z, X,&nbsp;Y:cfVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);
<BR>procedure VCFx_subrReV( Z, X:cfVector; Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVCFmath.h&gt;
<BR>int cudaVF_subV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVFs_subV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVFs_subV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>int cudaVFx_subV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_subV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>int cudaVCF_subReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>int cudaVCFx_subReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>int cusdVCFx_subReV( cfVector&nbsp;d_Z, cfVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, fComplex&nbsp;*d_A, fComplex&nbsp;*d_B&nbsp;);
<BR>void VFcu_subV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFscu_subV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>void VFxcu_subV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>void VCFcu_subReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);
<BR>void VCFxcu_subV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, cfVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);
<BR>void VCFxcu_subReV( cfVector&nbsp;h_Z, cfVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, fComplex&nbsp;A, fComplex&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VCFmath;
<BR>function cudaVF_subV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFs_subV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFs_subV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_subV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_subV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>function cudaVCF_subReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVCFx_subReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;):&nbsp;IntBool;
<BR>function cusdVCFx_subReV( d_Z, d_X:cfVector; d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PfComplex&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_subV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFscu_subV( h_Z, h_X, h_Y:fVector; size:UIntSize; C:Single&nbsp;);
<BR>procedure VFxcu_subV( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);
<BR>procedure VCFcu_subReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VCFxcu_subReV( h_Z, h_X:cfVector; h_Y:fVector; size:UIntSize; A,&nbsp;B:fComplex&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = X<sub>i</sub> - Y<sub>i</sub>
<BR>scaled versions: Z<sub>i</sub> = C *&nbsp;(X<sub>i</sub> - Y<sub>i</sub>)
<BR>expanded versions: Z<sub>i</sub> = (A*X<sub>i</sub>+B) - Y<sub>i</sub>
<BR>The complex floating-point versions exist in two variants: in the first variant (e.g., <I>VCF_subV,&nbsp;&nbsp; VCFx_subV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g., <I>VCF_subReV</I> - &quot;subtract a real vector&quot;).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#subVI">VF_subVI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subVI"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subVI</b></font></td><td width="33%"><font size="+1"><b>VD_subVI</b></font></td><td><font size="+1"><b>VE_subVI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subVBI</b></font></td><td width="33%"><font size="+1"><b>VD_subVBI</b></font></td><td><font size="+1"><b>VE_subVBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subVSI</b></font></td><td width="33%"><font size="+1"><b>VD_subVSI</b></font></td><td><font size="+1"><b>VE_subVSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subVLI</b></font></td><td width="33%"><font size="+1"><b>VD_subVLI</b></font></td><td><font size="+1"><b>VE_subVLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subVQI</b></font></td><td width="33%"><font size="+1"><b>VD_subVQI</b></font></td><td><font size="+1"><b>VE_subVQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subVU</b></font></td><td width="33%"><font size="+1"><b>VD_subVU</b></font></td><td><font size="+1"><b>VE_subVU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subVUB</b></font></td><td width="33%"><font size="+1"><b>VD_subVUB</b></font></td><td><font size="+1"><b>VE_subVUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subVUS</b></font></td><td width="33%"><font size="+1"><b>VD_subVUS</b></font></td><td><font size="+1"><b>VE_subVUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subVUL</b></font></td><td width="33%"><font size="+1"><b>VD_subVUL</b></font></td><td><font size="+1"><b>VE_subVUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subVUQ</b></font></td><td width="33%"><font size="+1"><b>VD_subVUQ</b></font></td><td><font size="+1"><b>VE_subVUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subVUI</b></font></td><td width="33%"><font size="+1"><b>VD_subVUI</b></font></td><td><font size="+1"><b>VE_subVUI</b></font></td></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Subtract an integer vector from a floating-point vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subVI( fVector&nbsp;Z, fVector&nbsp;X, iVector&nbsp;Y,ui&nbsp;size&nbsp;);
<BR>void VF_subVUB( fVector&nbsp;Z, fVector&nbsp;X, ubVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subVI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;int&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::subVUS( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;unsigned short&gt;&amp;&nbsp;Y,&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subVI( Z, X:fVector; Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VF_subVUL( Z, X:fVector; Y:ulVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_subVI( fVector&nbsp;d_Z, fVector&nbsp;d_X, iVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVF_subVUB( fVector&nbsp;d_Z, fVector&nbsp;d_X, ubVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>void VFcu_subVI( fVector&nbsp;h_Z, fVector&nbsp;h_X, iVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFcu_subVUB( fVector&nbsp;h_Z, fVector&nbsp;h_X, ubVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_subVI( d_Z, d_X:fVector; d_Y:iVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_subVUL( d_Z, d_X:fVector; d_Y:ulVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_subVI( h_Z, h_X:fVector; h_Y:iVector; size:UIntSize&nbsp;);
<BR>procedure VFcu_subVUL( h_Z, h_X:fVector; h_Y:ulVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = X<sub>i</sub> - Y<sub>i</sub>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#subrVI">VF_subrVI</a>,&nbsp;&nbsp; <a href="#addVI">VF_addVI</a></I></td></tr></table></td></tr>
</table>


<P>&nbsp;<P><a name="sub2V"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sub2V</b></font></td><td width="33%"><font size="+1"><b>VD_sub2V</b></font></td><td><font size="+1"><b>VE_sub2V</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Subtract two vectors simultaneously from one vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_sub2V( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y1, fVector&nbsp;Y2, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::sub2V( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y1, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y2&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_sub2V( Z, X, Y1, Y2:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_sub2V( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y1, fVector&nbsp;d_Y2, ui&nbsp;size&nbsp;);
<BR>void VFcu_sub2V( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y1, fVector&nbsp;h_Y2, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_sub2V( d_Z, d_X,&nbsp;d_Y1, d_Y2:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_sub2V( h_Z, h_X, h_Y1, h_Y2:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = X<sub>i</sub> - Y1<sub>i</sub> - Y2<sub>i</sub>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#add2V">VF_add2V</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subvector"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subvector</b></font></td><td width="34%"><font size="+1"><b>VD_subvector</b></font></td><td><font size="+1"><b>VE_subvector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subvector</b></font></td><td width="34%"><font size="+1"><b>VCD_subvector</b></font></td><td><font size="+1"><b>VCE_subvector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_subvector</b></font></td><td width="34%"><font size="+1"><b>VPD_subvector</b></font></td><td><font size="+1"><b>VPE_subvector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_subvector</b></font></td><td width="17%"><font size="+1"><b>VBI_subvector</b></font></td><td width="17%"><font size="+1"><b>VSI_subvector</b></font></td><td width="17%"><font size="+1"><b>VLI_subvector</b></font></td><td width="17%"><font size="+1"><b>VQI_subvector</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_subvector</b></font></td><td width="17%"><font size="+1"><b>VUB_subvector</b></font></td><td width="17%"><font size="+1"><b>VUS_subvector</b></font></td><td width="17%"><font size="+1"><b>VUL_subvector</b></font></td><td width="17%"><font size="+1"><b>VUQ_subvector</b></font></td><td><font size="+1"><b>VUI_subvector</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extract a sub-vector from the input vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_subvector( fVector&nbsp;Y, ui&nbsp;subsize, fVector&nbsp;X, int&nbsp;samp&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subvector( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, int&nbsp;samp, ui&nbsp;start=0&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_subvector( Y:fVector; sizey:UIntSize; X:fVector; samp:Integer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_subvector( fVector&nbsp;d_Y, ui&nbsp;subsize, fVector&nbsp;d_X, int&nbsp;samp&nbsp;);
<BR>void VFcu_subvector( fVector&nbsp;h_Y, ui&nbsp;subsize, fVector&nbsp;h_X, int&nbsp;samp&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_subvector( d_Y:fVector; sizey:UIntSize; d_X:fVector; samp:Integer&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_subvector( h_Y:fVector; sizey:UIntSize; h_X:fVector; samp:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i*samp</sub>
<BR>A sub-vector Y is extracted from X with a sampling interval samp. This means that every samp'th element is taken, up to a total of subsize elements, starting with the zero'th element of X. Since X may be an expression like XX+1000 (C/C++) or VF_Pelement( XX, 1000&nbsp;) (Pascal/Delphi), samp does not always need to be positive, but may also take on negative values (or the trivial value of 0). X and Y have to be distinct. Instead of using a samp of 0, 1, or -1, one should use <I><a href="#equC">VF_equC</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a></I>, or <I><a href="#rev">VF_rev</a></I>, respectively.
<BR>The <I>VecObj</I> version is called with an additional argument <I>start</I>, denoting the element of X to start with. This is necessary to avoid input expressions like <font face="courier new">XX+1000</font>, which are possible only with pointers, but would be mis-interpreted as the <font face="courier new">operator +</font> in the class-based object-oriented interface.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#CtoRe">VF_CtoRe</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subvector_"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VD_subvector_...</b></font></td><td><font size="+1"><b>VE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VCD_subvector_...</b></font></td><td><font size="+1"><b>VCE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VPD_subvector_...</b></font></td><td><font size="+1"><b>VPE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._addC</b></font></td><td><font size="+1"><b>..._addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._divC</b></font></td><td><font size="+1"><b>..._divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._divrC</b></font></td><td><font size="+1"><b>..._divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._mulC</b></font></td><td><font size="+1"><b>..._mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._subC</b></font></td><td><font size="+1"><b>..._subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._subrC</b></font></td><td><font size="+1"><b>..._subrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Arithmetic functions working on a sub-set of elements within a vector of one of the floating-point data types.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subvector_addC( fVector&nbsp;Y, ui&nbsp;subsize, unsigned samp, float&nbsp;C&nbsp;);
<BR>void VF_subvector_addV( fVector&nbsp;Y, ui&nbsp;subsize, unsigned samp, fVector&nbsp;X&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subvector_addC( unsigned samp, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;T&gt;::subvector_addV( unsigned samp, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subvector_addC( Y:fVector; subsiz:UIntSize; samp:UIntSize; C:Single&nbsp;);
<BR>procedure VF_subvector_addV( Y:fVector; subsiz:UIntSize; samp:UIntSize; X:fVector&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_subvector_addC( fVector&nbsp;d_Y, ui&nbsp;subsize, unsigned&nbsp;samp, float&nbsp;C&nbsp;);
<BR>int cusdVF_subvector_addC( fVector&nbsp;d_Y, ui&nbsp;subsize, unsigned&nbsp;samp, float&nbsp;*d_C&nbsp;);
<BR>int cudaVF_subvector_addV( fVector&nbsp;d_Y, ui&nbsp;subsize, unsigned&nbsp;samp, fVector&nbsp;X&nbsp;);
<BR>void VFcu_subvector_addC( fVector&nbsp;h_Y, ui&nbsp;subsize, unsigned&nbsp;samp, float&nbsp;C&nbsp;);
<BR>void VFcu_subvector_addV( fVector&nbsp;h_Y, ui&nbsp;subsize, unsigned&nbsp;samp, fVector&nbsp;X&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_subvector_addC( d_Y:fVector; subsiz:UIntSize; samp:UIntSize; C:Single&nbsp;);
<BR>function cusdVF_subvector_addC( d_Y:fVector; subsiz:UIntSize; samp:UIntSize; d_C:PSingle&nbsp;);
<BR>function cudaVF_subvector_addV( d_Y:fVector; subsiz:UIntSize; samp:UIntSize; X:fVector&nbsp;);
<BR>procedure VFcu_subvector_addC( h_Y:fVector; subsiz:UIntSize; samp:UIntSize; C:Single&nbsp;);
<BR>procedure VFcu_subvector_addV( h_Y:fVector; subsiz:UIntSize; samp:UIntSize; X:fVector&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><table><tr valign="top"><td>..._addC:</td><td>Y<sub>i*samp</sub> += C,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._addV:</td><td>Y<sub>i*samp</sub> += X<sub>i</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._subC:</td><td>Y<sub>i*samp</sub> -= C,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._subV:</td><td>Y<sub>i*samp</sub> -= X<sub>i</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._subrC:</td><td>Y<sub>i*samp</sub> = C - Y<sub>i*samp</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._subrV:&nbsp;&nbsp;</td><td>Y<sub>i*samp</sub> = X<sub>i</sub>- Y<sub>i*samp</sub>,&nbsp;&nbsp;</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._mulC:</td><td>Y<sub>i*samp</sub> *= C,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._mulV:</td><td>Y<sub>i*samp</sub> *= X<sub>i</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._divC:</td><td>Y<sub>i*samp</sub> /= C,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._divV:</td><td>Y<sub>i*samp</sub> /= X<sub>i</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._divrC:</td><td>Y<sub>i*samp</sub> = C / Y<sub>i*samp</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._divrV:</td><td>Y<sub>i*samp</sub> = X<sub>i</sub> / Y<sub>i*samp</sub>,</td><td>i=0,...subsize-1</td></tr>
</table>&nbsp;
<BR>Polar complex versions:
<BR>only multiplication and division are present: <I>...mulC, &nbsp;...mulV, &nbsp;...divC, &nbsp;...divV, &nbsp;...divrC</I>, and <I>...divrV</I>.
<P>The operation indicated in the suffix of the function name is perfomed on a sub-set of the elements of a vector. The sampling interval is denoted by samp: every samp'th element is taken, up to a total of subsize, starting with the zero'th one (that means, subsize is not the total size of the vector, but rather the size of the sub-set, i.e. the number of elements for which the function is performed). Note that all operations are performed in place, i.e., the input vector itself is changed.
<BR>For similar functions not included in the above list, the necessary sequence of calls is similar to the following example (which shows how to calculate the sinc function of the zero'th and then every tenth element of X, assuming that size is an integer multiple of 10):
<BR><font face="courier new"><a href="#subvector">VF_subvector</a>( Y, size/10, 10, X&nbsp;);
<BR><a href="#sinc">VF_sinc</a>( Y, Y, size/10&nbsp;);
<BR><a href="#subvector_equC">VF_subvector_equV</a>( X, size/10, 10, Y&nbsp;);</font>
<BR>(However, in such cases, you would sometimes prefer the classic style of a loop with the loop-increment set to 10. Only if the desired function is not available in the math library of your compiler, the effort of copying back and forth into the dummy vector Y will pay off.)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#subvector_equC">VF_subvector_equC</a>,&nbsp;&nbsp; <a href="#subvector_equC">VF_subvector_equV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subvector_equC"></a><a name="subvector_equV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VD_subvector_...</b></font></td><td><font size="+1"><b>VE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VCD_subvector_...</b></font></td><td><font size="+1"><b>VCE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VPD_subvector_...</b></font></td><td><font size="+1"><b>VPE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VBI_subvector_...</b></font></td><td><font size="+1"><b>VSI_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_subvector_...</b></font></td><td><font size="+1"><b>VQI_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VUB_subvector_...</b></font></td><td><font size="+1"><b>VUS_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VUQ_subvector_...</b></font></td><td><font size="+1"><b>VUI_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._equC</b></font></td><td><font size="+1"><b>..._equV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize a sub-set of elements within a vector either with a constant value or with values stored as the elements of another vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_subvector_equC( fVector&nbsp;Y, ui&nbsp;subsize, unsigned samp, float&nbsp;C&nbsp;);
<BR>void VF_subvector_equV( fVector&nbsp;Y, ui&nbsp;subsize, unsigned samp, fVector&nbsp;X&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subvector_equC( unsigned samp, const&nbsp;T&amp;&nbsp;C&nbsp;);
<BR>void vector&lt;T&gt;::subvector_equV( unsigned samp, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_subvector_equC( Y:fVector; subsz:UIntSize; samp:UIntSize; C:Single&nbsp;);
<BR>procedure VF_subvector_equV( Y:fVector; subsz:UIntSize; samp:UIntSize; X:fVector&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_subvector_equC( fVector&nbsp;d_Y, ui&nbsp;subsize, unsigned&nbsp;samp, float&nbsp;C&nbsp;);
<BR>int cusdVF_subvector_equC( fVector&nbsp;d_Y, ui&nbsp;subsize, unsigned&nbsp;samp, float&nbsp;*d_C&nbsp;);
<BR>int cudaVF_subvector_equV( fVector&nbsp;d_Y, ui&nbsp;subsize, unsigned&nbsp;samp, fVector&nbsp;X&nbsp;);
<BR>void VFcu_subvector_equC( fVector&nbsp;h_Y, ui&nbsp;subsize, unsigned&nbsp;samp, float&nbsp;C&nbsp;);
<BR>void VFcu_subvector_equV( fVector&nbsp;h_Y, ui&nbsp;subsize, unsigned&nbsp;samp, fVector&nbsp;X&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_subvector_equC( d_Y:fVector; subsiz:UIntSize; samp:UIntSize; C:Single&nbsp;);
<BR>function cusdVF_subvector_equC( d_Y:fVector; subsiz:UIntSize; samp:UIntSize; d_C:PSingle&nbsp;);
<BR>function cudaVF_subvector_equV( d_Y:fVector; subsiz:UIntSize; samp:UIntSize; X:fVector&nbsp;);
<BR>procedure VFcu_subvector_equC( h_Y:fVector; subsiz:UIntSize; samp:UIntSize; C:Single&nbsp;);
<BR>procedure VFcu_subvector_equV( h_Y:fVector; subsiz:UIntSize; samp:UIntSize; X:fVector&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><table><tr valign="top"><td>..._equC:&nbsp;&nbsp;</td><td>Y<sub>i*samp</sub> = C,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._equV:</td><td>Y<sub>i*samp</sub> = X<sub>i</sub>,&nbsp;&nbsp;</td><td>i=0,...subsize-1</td></tr>
</table>&nbsp;
<BR>A sub-set of the elements of a vector is overwritten according to the sampling interval <I>samp</I>: every <I>samp</I>'th element is initialized either with the constant C, or with the value specified as an element of the vector X. A total of <I>subsize</I> elements is initialized, starting with the zeroth one (that means, <I>subsize</I> is not the total size of the vector, but rather the size of the sub-set). <I>VF_subvector_equV</I> is the exact reverse of <I><a href="#subvector">VF_subvector</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a>,&nbsp;&nbsp; <a href="#subvector_">VF_subvector_addC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sum"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sum</b></font></td><td width="34%"><font size="+1"><b>VD_sum</b></font></td><td><font size="+1"><b>VE_sum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sum</b></font></td><td width="34%"><font size="+1"><b>VCD_sum</b></font></td><td><font size="+1"><b>VCE_sum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_sum</b></font></td><td width="17%"><font size="+1"><b>VBI_sum</b></font></td><td width="17%"><font size="+1"><b>VSI_sum</b></font></td><td width="17%"><font size="+1"><b>VLI_sum</b></font></td><td width="17%"><font size="+1"><b>VQI_sum</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_sum</b></font></td><td width="17%"><font size="+1"><b>VUB_sum</b></font></td><td width="17%"><font size="+1"><b>VUS_sum</b></font></td><td width="17%"><font size="+1"><b>VUL_sum</b></font></td><td width="17%"><font size="+1"><b>VUQ_sum</b></font></td><td><font size="+1"><b>VUI_sum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum up all the elements of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_sum( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::sum();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_sum( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;
<BR>function VCF_sum( X:cfVector; size:UIntSize&nbsp;):fComplex;</font>
<BR>Alternative syntax for the complex types (obsolete, but still supported):<font face="courier new">
procedure VCF_sum( var Sum:fComplex; X:cfVector; size:UIntSize);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_sum( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_sum( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_sum( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_sum( var&nbsp;h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_sum( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sum( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>sum = sum( X<sub>i</sub>&nbsp;)
<BR>The sum over all elements of a vector is calculated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but be careful: this function may easily overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the vector elements (except complex versions in Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#runsum">VF_runsum</a>,&nbsp;&nbsp; <a href="#fsum">VI_fsum</a>, &nbsp;&nbsp;<a href="#prod">VF_prod</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#mean">VF_mean</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sumabs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sumabs</b></font></td><td width="33%"><font size="+1"><b>VD_sumabs</b></font></td><td><font size="+1"><b>VE_sumabs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum up the absolute values of all the elements of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_sumabs( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::sumabs();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_sumabs( X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_sumabs( float&nbsp;*h_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cusdVF_sumabs( float&nbsp;*d_RetVal, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>float VFcu_sumabs( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_sumabs( var&nbsp;h_RetVal:Single; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_sumabs( d_RetVal:PSingle; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sumabs( h_X:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>sumabs = sum(| X<sub>i</sub> |)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but be careful: this function may easily overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the absolute values of all vector elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#meanabs">VF_meanabs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sumdevC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sumdevC</b></font></td><td width="33%"><font size="+1"><b>VD_sumdevC</b></font></td><td><font size="+1"><b>VE_sumdevC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum of the absolute deviations from a preset value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_sumdevC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::sumdevC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_sumdevC( X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_sumdevC( float *h_RetVal, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_sumdevC( float *d_RetVal, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>float VFcu_sumdevC( fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_sumdevC( var h_RetVal:Single; d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_sumdevC( d_RetVal:PSingle; d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sumdevC( h_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>sumdevC = sum( |X<sub>i</sub> - C|&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the absolute deviations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#sumdevV">VF_sumdevV</a>,&nbsp;&nbsp; <a href="#avdevC">VF_avdevC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sumdevV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sumdevV</b></font></td><td width="33%"><font size="+1"><b>VD_sumdevV</b></font></td><td><font size="+1"><b>VE_sumdevV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum of the absolute deviations of the elements of one vector from the corresponding elements of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_sumdevV( fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::sumdevV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_sumdevV( X,&nbsp;Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_sumdevV( float *h_RetVal, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>int cusdVF_sumdevV( float *d_RetVal, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>float VFcu_sumdevV( fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_sumdevV( var h_RetVal:Single; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_sumdevV( d_RetVal:PSingle; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_sumdevV( h_X, h_Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>sumdevV = sum( |X<sub>i</sub> - Y<sub>i</sub>|&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the absolute deviations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#sumdevC">VF_sumdevC</a>,&nbsp;&nbsp; <a href="#avdevV">VF_avdevV</a>,&nbsp;&nbsp; <a href="#ssqdevV">VF_ssqdevV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cudaSynchronize"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>cudaV_synchronize</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Wait until any active tasks of the current workspace are finished</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;cudaVecLib.h&gt;
<BR>void cudaV_synchronize( void&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure cudaV_synchronize;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>As described in <a href="CUDAOPTIVEC.HTM#chap4">Chapter 4</a>, the functions with the prefixes <i>cudaV?_</i> and <i>cusdV?_</i> return control to the calling function before actually finishing their tasks. This makes parallel execution of host and device functions and concurrent execution of several <i>cudaV?_</i> functions on the device possible. However, whenever the result of one function call is needed for transfer to host memory, or for a call to a <i>cudaV?_</i> function with a different workspace, calls to <i>cudaV_synchronize</i> have to be inserted in order to ensure proper synchronization.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap4">CudaOptiVec.htm - Chapter 4. Distinguishing <i>OptiVec</i> Functions for Host and for Device Memory</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="tan"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tan</b></font></td><td width="33%"><font size="+1"><b>VD_tan</b></font></td><td><font size="+1"><b>VE_tan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_tan</b></font></td><td width="33%"><font size="+1"><b>VCD_tan</b></font></td><td><font size="+1"><b>VCE_tan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_tan</b></font></td><td width="33%"><font size="+1"><b>VDx_tan</b></font></td><td><font size="+1"><b>VEx_tan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_tan</b></font></td><td width="33%"><font size="+1"><b>VCDx_tan</b></font></td><td><font size="+1"><b>VCEx_tan</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Tangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_tan( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_tan( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::tan( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_tan( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_tan( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_tan( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_tan( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_tan( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_tan( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_tan( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_tan( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_tan( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_tan( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_tan( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_tan( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_tan( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = tan ( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;tan( A*X<sub>i</sub>+B&nbsp;)
<BR>For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as rational multiples of <font face="symbol">p</font>, it is better to use <I><a href="#tanrpi">VF_tanrpi</a></I> than <I>VF_tan</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING and OVERFLOW errors (for arguments very close to <font face="symbol">p</font>/2) lead to a default result of &#177;HUGE_VAL. Precision errors lead to a default result of 0.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tan2">VF_tan2</a>,&nbsp;&nbsp; <a href="#tanrpi">VF_tanrpi</a>,&nbsp;&nbsp; <a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#tanh">VF_tanh</a>,&nbsp;&nbsp; <a href="#atan">VF_atan</a>,&nbsp;&nbsp; <a href="#atan2">VF_atan2</a>,&nbsp;&nbsp; tan</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="tan2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tan2</b></font></td><td width="33%"><font size="+1"><b>VD_tan2</b></font></td><td><font size="+1"><b>VE_tan2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_tan2</b></font></td><td width="33%"><font size="+1"><b>VDx_tan2</b></font></td><td><font size="+1"><b>VEx_tan2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the tangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_tan2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_tan2( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::tan2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_tan2( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_tan2( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_tan2( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_tan2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_tan2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_tan2( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_tan2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_tan2( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_tan2( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_tan2( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_tan2( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_tan2( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_tan2( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = tan<sup>2</sup>( X<sub>i</sub>&nbsp;)
<BR>expanded versions: Y<sub>i</sub> = C *&nbsp;tan<sup>2</sup>( A*X<sub>i</sub>+B&nbsp;)
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING and OVERFLOW errors (for arguments close to <font face="symbol">p</font>/2) lead to a default result of &#177;HUGE_VAL. Precision errors lead to a default result of 0.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tan">VF_tan</a>,&nbsp;&nbsp; <a href="#tanrpi">VF_tanrpi</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="tanh"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tanh</b></font></td><td width="33%"><font size="+1"><b>VD_tanh</b></font></td><td><font size="+1"><b>VE_tanh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_tanh</b></font></td><td width="33%"><font size="+1"><b>VCD_tanh</b></font></td><td><font size="+1"><b>VCE_tanh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_tanh</b></font></td><td width="33%"><font size="+1"><b>VDx_tanh</b></font></td><td><font size="+1"><b>VEx_tanh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_tanh</b></font></td><td width="33%"><font size="+1"><b>VCDx_tanh</b></font></td><td><font size="+1"><b>VCEx_tanh</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic tangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_tanh( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VFx_tanh( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::tanh( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;T&gt;::x_tanh( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_tanh( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFx_tanh( Y,&nbsp;X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_tanh( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVFx_tanh( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);
<BR>int cusdVFx_tanh( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B, float&nbsp;*d_C&nbsp;);
<BR>int VFcu_tanh( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFxcu_tanh( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;A, float&nbsp;B, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_tanh( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_tanh( d_Y, d_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_tanh( d_Y, d_X:fVector; size:UIntSize; d_A,&nbsp;d_B,&nbsp;d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_tanh( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFxcu_tanh( h_Y, h_X:fVector; size:UIntSize; A,&nbsp;B,&nbsp;C:Single&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions:
<table><tr><td>Y<sub>i</sub> =&nbsp;&nbsp;</td><td>tanh( X<sub>i</sub>&nbsp;)</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;</td><td><U>exp( X<sub>i</sub>&nbsp;) - exp( -X<sub>i</sub>&nbsp;)</U>
<BR>exp( X<sub>i</sub>&nbsp;) + exp( -X<sub>i</sub>&nbsp;)</td></tr></table>&nbsp;
<BR>expanded versions:
<BR>Y<sub>i</sub> = C *&nbsp;tanh( A*X<sub>i</sub>+B&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; tanh</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="tanrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tanrpi</b></font></td><td width="33%"><font size="+1"><b>VD_tanrpi</b></font></td><td><font size="+1"><b>VE_tanrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tanrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_tanrpi2</b></font></td><td><font size="+1"><b>VE_tanrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tanrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_tanrpi3</b></font></td><td><font size="+1"><b>VE_tanrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Tangent function of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_tanrpi( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_tanrpi2( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VF_tanrpi3( fVector&nbsp;Y, iVector&nbsp;P, ui&nbsp;size, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::tanrpi( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::tanrpi2( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);
<BR>int vector&lt;T&gt;::tanrpi3( const&nbsp;vector&lt;int&gt;&amp;&nbsp;P, int&nbsp;q&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_tanrpi( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_tanrpi2( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VF_tanrpi3( Y:fVector; P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_tanrpi( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_tanrpi2( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int cudaVF_tanrpi3( fVector&nbsp;d_Y, iVector&nbsp;d_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_tanrpi( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_tanrpi2( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);
<BR>int VFcu_tanrpi3( fVector&nbsp;h_Y, iVector&nbsp;h_P, ui&nbsp;size, int&nbsp;q&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_tanrpi( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_tanrpi2( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_tanrpi3( d_Y:fVector; d_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_tanrpi( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_tanrpi2( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;
<BR>function VFcu_tanrpi3( h_Y:fVector; h_P:iVector; size:UIntSize; q:Integer&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = tan( (P<sub>i</sub> / q) *&nbsp;<font face="symbol">p</font>&nbsp;)
<BR>The tangent of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_tanrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_tanrpi2</I> should be used which is a highly optimized version using a look-up table. If q is a multiple of 3, <I>VF_tanrpi3</I> should be used. <I>VF_tanrpi2</I> and <I>VF_tanrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the then useless tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors occur if P<sub>i</sub> / q is an odd multiple of 1/2; the default result is 0.0 (which is the mean of +HUGE_VAL and -HUGE_VAL).
<BR>q must be non-zero; this is, however, not tested for.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tan">VF_tan</a>,&nbsp;&nbsp; tan</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="tantab2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tantab2</b></font></td><td width="33%"><font size="+1"><b>VD_tantab2</b></font></td><td><font size="+1"><b>VE_tantab2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tantab3</b></font></td><td width="33%"><font size="+1"><b>VD_tantab3</b></font></td><td><font size="+1"><b>VE_tantab3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">&nbsp;</TD><td>Table of tangent values for arguments between 0 and <font face="symbol">p</font>/2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_tantab2[ VF_tabsz2+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_tantab2[ VD_tabsz2+1 ];
<BR>extern extended&nbsp;VE_tantab2[ VE_tabsz2+1 ];
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_tantab3[ VF_tabsz3+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_tantab3[ VD_tabsz3+1 ];
<BR>extern extended&nbsp;VE_tantab3[ VE_tabsz3+1 ];</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses FTANTAB2, DTANTAB2, ETANTAB2,
FTANTAB3, DTANTAB3, ETANTAB3;
<BR>VF_tantab2: array[0..VF_tabsz2] of Single;
<BR>VD_tantab2: array[0..VD_tabsz2] of Double;
<BR>VE_tantab2: array[0..VE_tabsz2] of Extended;
<BR>VF_tantab3: array[0..VF_tabsz3] of Single;
<BR>VD_tantab3: array[0..VD_tabsz3] of Double;
<BR>VE_tantab3: array[0..VE_tabsz3] of Extended;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>VF_tantab2[ i ] = tan( i/(2*VF_tabsz2) *&nbsp;<font face="symbol">p</font>&nbsp;), &nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz2-1
<BR>VF_tantab3[ i ] = tan( i/(2*VF_tabsz3) *&nbsp;<font face="symbol">p</font>&nbsp;), &nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz3-1
<BR>VF_tantab2[ VF_tabsz2 ] = VF_tantab3[ VF_tabsz3 ] = 0;
<P>These look-up tables of tangent values for arguments between 0 and <font face="symbol">p</font>/2 are used by <I><a href="#tanrpi">VF_tanrpi2</a></I> and the other functions of that family and are also available for other purposes. Since the tangent of <font face="symbol">p</font>/2 is not defined, zero is stored at its place. 
<BR><u>C/C++:</u> The symbols VF_tabsz2 etc., denoting the size of the tables, are defined in &lt;xmath.h&gt;.
<BR><u>Pascal/Delphi:</u> The symbols VF_tabsz2 etc. are defined in the same units as the tables themselves.
<BR><u>FreePascal/Lazarus:</u> These tables are not available for FreePascal/Lazarus.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tanrpi">VF_tanrpi2</a>,&nbsp;&nbsp; <a href="#sintab2">VF_sintab2</a>,&nbsp;&nbsp; <a href="#cosectab2">VF_cosectab2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="trunc"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunc</b></font></td><td width="33%"><font size="+1"><b>VD_trunc</b></font></td><td><font size="+1"><b>VE_trunc</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoI</b></font></td><td><font size="+1"><b>VE_trunctoI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoBI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoBI</b></font></td><td><font size="+1"><b>VE_trunctoBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoSI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoSI</b></font></td><td><font size="+1"><b>VE_trunctoSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoLI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoLI</b></font></td><td><font size="+1"><b>VE_trunctoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoQI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoQI</b></font></td><td><font size="+1"><b>VE_trunctoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoU</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoU</b></font></td><td><font size="+1"><b>VE_trunctoU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoUB</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoUB</b></font></td><td><font size="+1"><b>VE_trunctoUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoUS</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoUS</b></font></td><td><font size="+1"><b>VE_trunctoUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoUL</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoUL</b></font></td><td><font size="+1"><b>VE_trunctoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoUQ</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoUQ</b></font></td><td><font size="+1"><b>VE_trunctoUQ</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoUI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoUI</b></font></td><td><font size="+1"><b>VE_trunctoUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Rounding by &quot;truncating&quot; toward zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_trunc( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VF_trunctoI( iVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);
<BR>int VF_trunctoU( uVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::trunc( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;int&gt;::trunctoI( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);
<BR>int vector&lt;unsigned&gt;::trunctoU( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_trunc( Y,&nbsp;X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VF_trunctoI( Y:iVector; X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VF_trunctoLI( Y:liVector; X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_trunc( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVF_trunctoI( iVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_trunc( fVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);
<BR>int VFcu_trunctoI( iVector&nbsp;h_Y, fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_trunc( d_Y, d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_trunctoI( d_Y:iVector; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_trunc( h_Y, h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_trunctoI( h_Y:iVector; h_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions are identical to those of the <I><a href="#chop">VF_chop</a></I> family. They have been defined in order to maintain consistency with the Pascal/Delphi function <I>trunc</I>. For details, see <I><a href="#chop">VF_chop</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="UtoF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UtoF</b></font></td><td width="33%"><font size="+1"><b>V_UtoD</b></font></td><td><font size="+1"><b>V_UtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UBtoF</b></font></td><td width="33%"><font size="+1"><b>V_UBtoD</b></font></td><td><font size="+1"><b>V_UBtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UStoF</b></font></td><td width="33%"><font size="+1"><b>V_UStoD</b></font></td><td><font size="+1"><b>V_UStoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_ULtoF</b></font></td><td width="33%"><font size="+1"><b>V_ULtoD</b></font></td><td><font size="+1"><b>V_ULtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UQtoF</b></font></td><td width="33%"><font size="+1"><b>V_UQtoD</b></font></td><td><font size="+1"><b>V_UQtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UItoF</b></font></td><td width="33%"><font size="+1"><b>V_UItoD</b></font></td><td><font size="+1"><b>V_UItoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type interconversions. See <I><a href="#ItoF">V_ItoF</a></I>!</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="varianceC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_varianceC</b></font></td><td width="33%"><font size="+1"><b>VD_varianceC</b></font></td><td><font size="+1"><b>VE_varianceC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Variance of a one-dimensional distribution with respect to a pre-set value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_varianceC( fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::varianceC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_varianceC( X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_varianceC( float *h_RetVal, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_varianceC( float *d_RetVal, fVector&nbsp;d_X, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>float VFcu_varianceC( fVector&nbsp;h_X, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_varianceC( var h_RetVal:Single; d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_varianceC( d_RetVal:PSingle; d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_varianceC( h_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>var = (1 / size) *&nbsp;sum( (X<sub>i</sub> - C)<sup>2</sup>&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The variance is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#varianceV">VF_varianceV</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="varianceCwW"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_varianceCwW</b></font></td><td width="33%"><font size="+1"><b>VD_varianceCwW</b></font></td><td><font size="+1"><b>VE_varianceCwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Variance with weights&quot; of a one-dimensional distribution with respect to a pre-set value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_varianceCwW( fVector&nbsp;X, fVector&nbsp;Wt, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::varianceCwW( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Wt, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_varianceCwW( X, Wt:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_varianceCwW( float *h_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Wt, ui&nbsp;size, float&nbsp;C&nbsp;);
<BR>int cusdVF_varianceCwW( float *d_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Wt, ui&nbsp;size, float&nbsp;*d_C&nbsp;);
<BR>float VFcu_varianceCwW( fVector&nbsp;h_X, fVector&nbsp;h_Wt, ui&nbsp;size, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_varianceCwW( var h_RetVal:Single; d_X,&nbsp;d_Wt:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_varianceCwW( d_RetVal:PSingle; d_X,&nbsp;d_Wt:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>function VFcu_varianceCwW( h_X,&nbsp;h_Wt:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>var = (1 / sum( Wt<sub>i</sub>&nbsp;)) *&nbsp;sum( Wt<sub>i</sub> *&nbsp;(X<sub>i</sub> - C)<sup>2</sup>&nbsp;)
<BR>The weights need not be normalized.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>variance of the distribution.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#varianceC">VF_varianceC</a>,&nbsp;&nbsp; <a href="#varianceVwW">VF_varianceVwW</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="varianceV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_varianceV</b></font></td><td width="33%"><font size="+1"><b>VD_varianceV</b></font></td><td><font size="+1"><b>VE_varianceV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Variance between two one-dimensional distributions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_varianceV( fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::varianceV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_varianceV( X,&nbsp;Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_varianceV( float *h_RetVal, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>int cusdVF_varianceV( float *d_RetVal, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>float VFcu_varianceV( fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_varianceV( var h_RetVal:Single; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_varianceV( d_RetVal:PSingle; d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_varianceV( h_X, h_Y:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>var = (1 / size) *&nbsp;sum( (X<sub>i</sub> - Y<sub>i</sub>)<sup>2</sup>&nbsp;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The variance is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#varianceC">VF_varianceC</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevV">VF_ssqdevV</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="varianceVwW"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_varianceVwW</b></font></td><td width="33%"><font size="+1"><b>VD_varianceVwW</b></font></td><td><font size="+1"><b>VE_varianceVwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Variance with weights&quot; between two one-dimensional distributions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_varianceVwW( fVector&nbsp;X, fVector&nbsp;Y, fVector&nbsp;Wt, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::varianceVwW( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Wt&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_varianceVwW( X, Y, Wt:fVector; size:UIntSize&nbsp;):</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_varianceVwW( float *h_RetVal, fVector&nbsp;X, fVector&nbsp;Y, fVector&nbsp;d_Wt, ui&nbsp;size&nbsp;);
<BR>int cusdVF_varianceVwW( float *d_RetVal, fVector&nbsp;X, fVector&nbsp;Y, fVector&nbsp;d_Wt, ui&nbsp;size&nbsp;);
<BR>float VFcu_varianceVwW( fVector&nbsp;h_X, fVector&nbsp;h_Y, fVector&nbsp;h_Wt, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_varianceVwW( var h_RetVal:Single; d_X,&nbsp;d_Y,&nbsp;d_Wt:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_varianceVwW( d_RetVal:PSingle; d_X,&nbsp;d_Y,&nbsp;d_Wt:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function VFcu_varianceVwW( h_X,&nbsp;h_Y,&nbsp;h_Wt:fVector; size:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>var = (1 / sum(Wt<sub>i</sub>)) *&nbsp;sum( Wt<sub>i</sub> *&nbsp;(X<sub>i</sub> - Y<sub>i</sub>)<sup>2</sup>&nbsp;)
<BR>The weights need not be normalized.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>weighted variance</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#chi2">VF_chi2</a>,&nbsp;&nbsp; <a href="#varianceV">VF_varianceV</a>,&nbsp;&nbsp; <a href="#varianceCwW">VF_varianceCwW</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="vector"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_vector</b></font></td><td width="34%"><font size="+1"><b>VD_vector</b></font></td><td><font size="+1"><b>VE_vector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_vector</b></font></td><td width="34%"><font size="+1"><b>VCD_vector</b></font></td><td><font size="+1"><b>VCE_vector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_vector</b></font></td><td width="34%"><font size="+1"><b>VPD_vector</b></font></td><td><font size="+1"><b>VPE_vector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_vector</b></font></td><td width="17%"><font size="+1"><b>VBI_vector</b></font></td><td width="17%"><font size="+1"><b>VSI_vector</b></font></td><td width="17%"><font size="+1"><b>VLI_vector</b></font></td><td width="17%"><font size="+1"><b>VQI_vector</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_vector</b></font></td><td width="17%"><font size="+1"><b>VUB_vector</b></font></td><td width="17%"><font size="+1"><b>VUS_vector</b></font></td><td width="17%"><font size="+1"><b>VUL_vector</b></font></td><td width="17%"><font size="+1"><b>VUQ_vector</b></font></td><td><font size="+1"><b>VUI_vector</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Memory allocation for a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>fVector&nbsp;VF_vector( ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function VF_vector( size:UIntSize&nbsp;):&nbsp;fVector;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>fVector&nbsp;cudaVF_vector( ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_vector( size:UIntSize&nbsp;):&nbsp;fVector;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Based on memory model and environment, the most appropriate allocation procedure is chosen by these functions. Failure to allocate memory always leads to an error message and a subsequent program abort (similar to the error handling of the &quot;new&quot; operator). To release the memory thus allocated, <I><a href="#free">V_free</a>,&nbsp;&nbsp; <a href="#freeAll">V_freeAll</a></I>, or <I><a href="#nfree">V_nfree</a></I> should be used (the latter only in C/C++).
<BR>Note: the declaration of a vector (e.g., as fVector) reserves only a name, but no memory!
<BR>See <a href="HANDBOOK.HTM#chap4_1">chapter&nbsp;4.1</a> if you are interested in details of the implementation.
<BR>Do not use this function in connection with the object-oriented interface <I>VecObj</I>. It has its own automated memory allocation procedure incorporated into the constructors, see <a href="HANDBOOK.HTM#chap3">chapter&nbsp;3</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.
<BR>32-bit:
<BR>If more than 4 GB of memory are requested, an error message &quot;Vector&nbsp;&gt; 4 GB not possible&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Pointer to the allocated memory</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I>malloc,&nbsp;&nbsp; calloc, &nbsp;&nbsp;<a href="#pinnedVector">cudaVF_pinnedVector</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="vector0"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_vector0</b></font></td><td width="34%"><font size="+1"><b>VD_vector0</b></font></td><td><font size="+1"><b>VE_vector0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_vector0</b></font></td><td width="34%"><font size="+1"><b>VCD_vector0</b></font></td><td><font size="+1"><b>VCE_vector0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_vector0</b></font></td><td width="34%"><font size="+1"><b>VPD_vector0</b></font></td><td><font size="+1"><b>VPE_vector0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_vector0</b></font></td><td width="17%"><font size="+1"><b>VBI_vector0</b></font></td><td width="17%"><font size="+1"><b>VSI_vector0</b></font></td><td width="17%"><font size="+1"><b>VLI_vector0</b></font></td><td width="17%"><font size="+1"><b>VQI_vector0</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_vector0</b></font></td><td width="17%"><font size="+1"><b>VUB_vector0</b></font></td><td width="17%"><font size="+1"><b>VUS_vector0</b></font></td><td width="17%"><font size="+1"><b>VUL_vector0</b></font></td><td width="17%"><font size="+1"><b>VUQ_vector0</b></font></td><td><font size="+1"><b>VUI_vector0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Memory allocation for a vector and initialization of all elements with 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>fVector&nbsp;VF_vector0( ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function VF_vector0( size:UIntSize&nbsp;):&nbsp;fVector;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>fVector&nbsp;cudaVF_vector0( ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_vector0( size:UIntSize&nbsp;):&nbsp;fVector;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The functions of this family are almost identical to those of the <I><a href="#vector">VF_vector</a></I> family; in addition to allocating memory, they initialize all elements with 0. (Calls to <I><a href="#vector">VF_vector</a></I> and <I>VF_vector0</I> may be mixed; they use the same tables to keep track of the handles and pointers). For further information, see <I><a href="#vector">VF_vector</a></I>.
<BR>Do not use this function in connection with the object-oriented interface. It has its own automated memory allocation procedure incorporated into the constructors, see <a href="HANDBOOK.HTM#chap3">chapter&nbsp;3</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.
<BR>16-bit models (except HUGE):
<BR>If more than 64 kB of memory are requested, an error message &quot;Vector&nbsp;&gt; 64 kB not possible&quot; is displayed and the program aborted.
<BR>32-bit:
<BR>If more than 4 GB of memory are requested, an error message &quot;Vector&nbsp;&gt; 4 GB not possible&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>A pointer to the allocated memory is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I>malloc,&nbsp;&nbsp; calloc, &nbsp;&nbsp;<a href="#pinnedVector0">cudaVF_pinnedVector0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="visC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_visC</b></font></td><td width="33%"><font size="+1"><b>VD_visC</b></font></td><td><font size="+1"><b>VE_visC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Visibility (or contrast) function of a vector with respect to a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_visC( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::visC( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_visC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>#include &lt;cudaVDmath.h&gt;
<BR>int cudaVF_visC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);
<BR>int cusdVF_visC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float *d_C&nbsp;);
<BR>void VFcu_visC( fVector&nbsp;d_Y, fVector&nbsp;d_X, ui&nbsp;size, float C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath, VDmath;
<BR>function cudaVF_visC( d_Y, d_X:fVector; size:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVF_visC( d_Y, d_X:fVector; size:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VF_visC( Y,&nbsp;X:fVector; size:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = vis( X<sub>i</sub>, C&nbsp;) = (X<sub>i</sub> - C) / (X<sub>i</sub> + C)
<BR>These functions are generalizations of the &quot;visibility&quot; or &quot;contrast&quot; function used in optics, where the contrast between two intensities is defined as their difference divided by their sum.
<BR>For X<sub>i</sub>=C, the visibility is defined as 0, even in the case of X<sub>i</sub>=C=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#redV">VF_redV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="visV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_visV</b></font></td><td width="33%"><font size="+1"><b>VD_visV</b></font></td><td><font size="+1"><b>VE_visV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_visV</b></font></td><td width="33%"><font size="+1"><b>VDx_visV</b></font></td><td><font size="+1"><b>VEx_visV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Visibility function of one vector with respect to another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_visV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);
<BR>void VFx_visV( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::visV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);
<BR>void vector&lt;T&gt;::x_visV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;T&amp;&nbsp;A, const&nbsp;T&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_visV( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFx_visV( Z, X,&nbsp;Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFmath.h&gt;
<BR>int cudaVF_visV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y,ui&nbsp;size&nbsp;);
<BR>int cudaVFx_visV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);
<BR>int cusdVFx_visV( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size, float&nbsp;*d_A, float&nbsp;*d_B&nbsp;);
<BR>void VFcu_visV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y,ui&nbsp;size&nbsp;);
<BR>void VFxcu_visV( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size, float&nbsp;A, float&nbsp;B&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function cudaVF_visV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVFx_visV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdVFx_visV( d_Z, d_X,&nbsp;d_Y:fVector; size:UIntSize; d_A,&nbsp;d_B:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_visV( h_Z, h_X, h_Y:fVector; size:UIntSize&nbsp;);
<BR>procedure VFxcu_visV( h_Z, h_X, h_Y:fVector; size:UIntSize; A,&nbsp;B:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: 
<BR>Z<sub>i</sub> = vis( X<sub>i</sub>, Y<sub>i</sub>&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;= (X<sub>i</sub> - Y<sub>i</sub>) / (X<sub>i</sub> + Y<sub>i</sub>)
<BR>expanded versions: 
<BR>Z<sub>i</sub> = vis( A*X<sub>i</sub>+B, Y<sub>i</sub>&nbsp;)
<BR>For X<sub>i</sub>=Y<sub>i</sub>, the visibility is defined as 0, even in the case of X<sub>i</sub>=Y<sub>i</sub>=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Welch"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Welch</b></font></td><td width="33%"><font size="+1"><b>VD_Welch</b></font></td><td><font size="+1"><b>VE_Welch</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Welch&quot; window for use in spectral analysis</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_Welch( fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::Welch();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_Welch( X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_Welch( fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>void VFcu_Welch( fVector&nbsp;h_X, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_Welch( d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_Welch( h_X:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = 1 - ( (i - 0.5*(size - 1)) / (0.5*(size + 1))&nbsp;)<sup>2</sup></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Parzen">VF_Parzen</a>,&nbsp;&nbsp; <a href="#Hann">VF_Hann</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="write"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_write</b></font></td><td width="34%"><font size="+1"><b>VD_write</b></font></td><td><font size="+1"><b>VE_write</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_write</b></font></td><td width="34%"><font size="+1"><b>VCD_write</b></font></td><td><font size="+1"><b>VCE_write</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_write</b></font></td><td width="34%"><font size="+1"><b>VPD_write</b></font></td><td><font size="+1"><b>VPE_write</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_write</b></font></td><td width="17%"><font size="+1"><b>VBI_write</b></font></td><td width="17%"><font size="+1"><b>VSI_write</b></font></td><td width="17%"><font size="+1"><b>VLI_write</b></font></td><td width="17%"><font size="+1"><b>VQI_write</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_write</b></font></td><td width="17%"><font size="+1"><b>VUB_write</b></font></td><td width="17%"><font size="+1"><b>VUS_write</b></font></td><td width="17%"><font size="+1"><b>VUL_write</b></font></td><td width="17%"><font size="+1"><b>VUQ_write</b></font></td><td><font size="+1"><b>VUI_write</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Write a vector in ASCII format to a stream.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_write( FILE *stream, fVector&nbsp;X, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::write( FILE *stream&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_write( var Stream:Text; X:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_write( FILE *stream, fVector&nbsp;d_X, ui&nbsp;size&nbsp;);
<BR>int cudaVF_write_buf( FILE *stream, fVector&nbsp;d_X, ui&nbsp;size, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_write( var Stream:Text; d_X:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaVF_write_buf( var Stream:Text; d_X:fVector; size:UIntSize; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>size elements of X are written to stream in ASCII format. By default, one element is written per line. To use these functions, stream must already be open for write operations in text format.
<P>The number format and the separation of consecutive elements may be specified using <I><a href="#setWriteFormat">VF_setWriteFormat</a></I> (C/C++ only) and <I><a href="#setWriteSeparate">VF_setWriteSeparate</a></I>, respectively. See these functions for details.
<P>Storing data in ASCII format is useful if the data have to be readable by human eyes, or if they are to be exported into other programs which are not able to read machine-format numbers. If avoidable, these functions should not be used for the storage of intermediate results that later have again to be read in. Instead, the function pairs of the <I><a href="#store">VF_store</a></I> / <I><a href="#recall">VF_recall</a></I> family are recommended for the following reasons: conversion into ASCII format is slow, may lead to round-off errors, and requires much more disk memory than storage in machine format.
<P>CUDA versions only: <i>cudaV?_write_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as X. By avoiding the need of <i>cudaV?_write</i> to allocate its own buffer memory, <i>cudaV?_write_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setWriteFormat">VF_setWriteFormat</a>,&nbsp;&nbsp; <a href="#setWriteSeparate">VF_setWriteSeparate</a>,&nbsp;&nbsp; <a href="#nwrite">VF_nwrite</a>,&nbsp;&nbsp; <a href="#read">VF_read</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; <a href="#cprint">VF_cprint</a>,&nbsp;&nbsp; <a href="#print">VF_print</a>,&nbsp;&nbsp; fprintf</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xcorr"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_xcorr</b></font></td><td width="33%"><font size="+1"><b>VD_xcorr</b></font></td><td><font size="+1"><b>VE_xcorr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cross-correlation function of two vectors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_xcorr( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xcorr( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_xcorr( Z, X,&nbsp;Y:fVector; size:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_xcorr( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;size&nbsp;);
<BR>void VFcu_xcorr( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;size&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_xcorr( d_Z,&nbsp;d_X,&nbsp;d_Y:fVector; size:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_xcorr( h_Z,&nbsp;h_X,&nbsp;h_Y:fVector; size:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The cross-correlation function (CCF) of X and Y is calculated and stored in Z in wrap-around order: Z<sub>0</sub> to Z<sub>size/2-1</sub> contain the CCF for zero and positive lags. Beginning with the most negative lag in Z<sub>size/2+1</sub>, the elements up to Z<sub>size-1</sub> contain the CCF for negative lags. Since this function assumes X to be periodic, the CCF for the most positive lag is identical to the CCF for the most negative lag. This element is stored as Z<sub>size/2</sub>.
<BR>To get the CCF into normal order, you may call
<BR><font face="courier new"> <a href="#rotate">VF_rotate</a>( Z, Z, size, size/2&nbsp;);</font>
<BR>After that, the zero point is at the position size/2.
<P>In case X is non-periodic, end effects should be avoided by the methods described in connection with <I><a href="#convolve">VF_convolve</a></I>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_xcorr</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xor"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VI_xor</b></font></td><td width="17%"><font size="+1"><b>VBI_xor</b></font></td><td width="17%"><font size="+1"><b>VSI_xor</b></font></td><td width="17%"><font size="+1"><b>VLI_xor</b></font></td><td width="17%"><font size="+1"><b>VQI_xor</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="16%"><font size="+1"><b>VU_xor</b></font></td><td width="17%"><font size="+1"><b>VUB_xor</b></font></td><td width="17%"><font size="+1"><b>VUS_xor</b></font></td><td width="17%"><font size="+1"><b>VUL_xor</b></font></td><td width="17%"><font size="+1"><b>VUQ_xor</b></font></td><td><font size="+1"><b>VUI_xor</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Bit-wise &quot;XOR&quot; operation.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_xor( iVector&nbsp;Y, iVector&nbsp;X, ui&nbsp;size, int&nbsp;C&nbsp;);
<BR>void VUL_xor( ulVector&nbsp;Y, ulVector&nbsp;X, ui&nbsp;size, unsigned long C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xor( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_xor( Y,&nbsp;X:iVector; size:UIntSize; C:Integer&nbsp;);
<BR>procedure VUL_xor( Y,&nbsp;X:ulVector; size:UIntSize; C:ULong&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVImath.h&gt;
<BR>int cudaVI_xor( iVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size, int&nbsp;C&nbsp;);
<BR>int cusdVI_xor( iVector&nbsp;d_Y, iVector&nbsp;d_X, ui&nbsp;size, int&nbsp;*d_C&nbsp;);
<BR>void VIcu_xor( iVector&nbsp;h_Y, iVector&nbsp;h_X, ui&nbsp;size, int&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>function cudaVI_xor( d_Y, d_X:iVector; size:UIntSize; C:Integer&nbsp;):&nbsp;IntBool;
<BR>function cusdVI_xor( d_Y, d_X:iVector; size:UIntSize; d_C:PInteger&nbsp;):&nbsp;IntBool;
<BR>procedure VIcu_xor( h_Y, h_X:iVector; size:UIntSize; C:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = (X<sub>i</sub>) ^ C
<BR>The bit-wise &quot;exclusive OR&quot; operation is performed on each element X<sub>i</sub> with the bit-mask given by C (i.e., a bit is 0 in Y<sub>i</sub>, if it was either 0 or 1 both in X<sub>i</sub> and C simultaneously. It is 1 if X<sub>i</sub> and C differed in this bit position).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#not">VI_not</a>,&nbsp;&nbsp; <a href="#and">VI_and</a>,&nbsp;&nbsp; <a href="#or">VI_or</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xprod"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_xprod</b></font></td><td width="33%"><font size="+1"><b>VD_xprod</b></font></td><td><font size="+1"><b>VE_xprod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cross-product of two vectors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_xprod( fVector&nbsp;Z, fVector&nbsp;X, fVector&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xprod( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_xprod( Z, X,&nbsp;Y:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaVFstd.h&gt;
<BR>int cudaVF_xprod( fVector&nbsp;d_Z, fVector&nbsp;d_X, fVector&nbsp;d_Y&nbsp;);
<BR>void VFcu_xprod( fVector&nbsp;h_Z, fVector&nbsp;h_X, fVector&nbsp;h_Y&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function cudaVF_xprod( d_Z,&nbsp;d_X,&nbsp;d_Y:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure VF_xprod( h_Z,&nbsp;h_X,&nbsp;h_Y:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z = X x Y
<BR>The cross-product of X and Y is calculated. Since this operation is defined specifically for vectors representing three dimensions in the geometrical sense, there is no parameter &quot;size&quot; for this function. The number of elements is 3 for each of the participating vectors, implicitly.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#scalprod">VF_scalprod</a>,&nbsp;&nbsp; <a href="#Euclid">VF_Euclid</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xyAutoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_xyAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VD_xyAutoPlot</b></font></td><td><font size="+1"><b>VE_xyAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_xyAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_xyAutoPlot</b></font></td><td><font size="+1"><b>VSI_xyAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_xyAutoPlot</b></font></td><td><font size="+1"><b>VQI_xyAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_xyAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_xyAutoPlot</b></font></td><td><font size="+1"><b>VUS_xyAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_xyAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUQ_xyAutoPlot</b></font></td><td><font size="+1"><b>VUI_xyAutoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Draws a Cartesian coordinate system and plots a Y-vector against an X-vector into it.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VF_xyAutoPlot( fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xyAutoPlot( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_xyAutoPlot( X,&nbsp;Y:fVector; size:UIntSize; form:UInt; color:COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian coordinate system is drawn with automatic scaling of the axes and the vector Y is plotted against the vector X. Prior to calling <I>VF_xyAutoPlot</I>, the plotting routines have to be initialized by <I><a href="#initPlot">V_initPlot</a></I>.
<BR>The VecObj version of this function has to be called as a member function of Y (rather than of X).
<BR>The font of the axis tick labels is the text font of the current device context.
<P>The style of the plot is determined by the parameter <i>form</i> which should be constructed using the symbolic constants defined in &lt;Vgraph.h&gt; (C/C++) or in the unit Vgraph (Pascal/Delphi).
<BR>For the line styles, Borland's old BGI notation is still supported along with the standard Windows notation; the necessary macros for the translation are included in &lt;Vgraph.h&gt; and in the unit Vgraph.
<P><u> 1. Style of lines connecting adjacent data points:</u>
<BR>&nbsp;
<table border width="100%">
<tr valign="top"><td><U>Windows style</U></td><td><U>BGI C/C++</U></td><td><U>BGI Pascal</U></td><td><U>appearance</U></td></tr>
<tr valign="top"><td>PS_SOLID</td><td>SOLID_LINE</td><td>SolidLn</td><td>&#x2013;&#x2013;&#x2013;&#x2013; (default)</td></tr>
<tr valign="top"><td>PS_DOT</td><td>DOTTED_LINE</td><td>DottedLn</td><td>&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;</td></tr>
<tr valign="top"><td>PS_DASH</td><td>DASHED_LINE</td><td>DashedLn</td><td>- - - -</td></tr>
<tr valign="top"><td>PS_DASHDOT</td><td>CENTER_LINE</td><td>CenterLn</td><td>- &#183; - &#183; -</td></tr>
<tr valign="top"><td>PS_DASHDOTDOT</td><td>&nbsp;</TD><td>&nbsp;</TD><td>- &#183; &#183; - &#183; &#183;</td></tr>
<tr valign="top"><td>PS_NULL</td><td>NULL_LINE</td><td>NullLn</td><td>(no line at all)</td></tr></table>
<P><u> 2. Symbols used to mark data points:</u>
<BR>&nbsp;
<table border width="100%">
<tr valign="top"><td>SY_NULL</td><td>(no symbol at all)&nbsp;&nbsp;&nbsp;(default)</td></tr>
<tr valign="top"><td>SY_CROSS</td><td>&#x2715;</td></tr>
<tr valign="top"><td>SY_PLUS</td><TD>+</td></tr>
<tr valign="top"><td>SY_STAR</td><TD>*</td></tr>
<tr valign="top"><td>SY_CIRCLE</td><TD>&#x25CB;</td></tr>
<tr valign="top"><td>SY_BOX</td><TD>&#x0860;</td></tr>
<tr valign="top"><td>SY_DIAMOND</td><td>&#x25C7;</td></tr>
<tr valign="top"><td>SY_TRIANGLEUP</td><td>&#x25B3;</td></tr>
<tr valign="top"><td>SY_TRIANGLEDOWN</td><td>&#x25BD;</td></tr></table>
<P><u>3. Fill-style of the symbols:</u>
<BR>&nbsp;
<table border width="100%">
<tr valign="top"><td>SY_HOLLOW</td><td>no filling&nbsp;&nbsp;(default)</td></tr>
<tr valign="top"><td>SY_FILLED</td><td>filled</td></tr>
<tr valign="top"><td>SY_DOTTED</td><td>hollow, with a dot at the exact position of the data point</td></tr></table>
<P>The parameter form has to be constructed by adding the appropriate line style, the symbol and its fill-style, e.g. (SOLID_LINE + SY_TRIANGLEUP). Alternatively, the bit-wise &quot;OR&quot; operation may be used, e.g. (PS_SOLID | SY_CIRCLE | SY_DOTTED&nbsp;).
<BR>In Pascal terms, these examples read:
<BR>(SolidLn + SY_TRIANGLEUP), and (PS_SOLID <b>or</b> SY_CIRCLE <b>or</b> SY_DOTTED).
<P>Note that NULL_LINE or PS_NULL has to be explicitly specified, if the data points are not to be connected by lines. Just writing, e.g. (SY_BOX | SY_HOLLOW) would be interpreted as using the default line style, which is SOLID_LINE.
<P>SY_NULL and SY_HOLLOW need not be specified, since these are the default symbol and fill-style, resp. For SY_NULL, SY_CROSS, SY_PLUS, and SY_STAR, the choice of fill-style has no effect.
<P>The parameter <i>color</i> denotes the colour that is to be used for the plot (the data type COLORREF is unsigned long / ULong). The "standard" colors BLACK, BLUE, GREEN, CYAN, RED, MAGENTA, BROWN, LIGHTGRAY, DARKGRAY, LIGHTBLUE, LIGHTGREEN, LIGHTCYAN, LIGHTRED, LIGHTMAGENTA, YELLOW, and WHITE are defined in &lt;Vgraph.h&gt; (or the unit Vgraph) by analogy with the COLORS defined for the old BGI. Nevertheless, it is recommended to use fine-tuned colors defined by the RGB macro, instead of the predefined colors.
<P>The size of the symbols may be modified with the function <I><a href="#setSymbolSize">V_setSymbolSize</a></I>. The thickness of the lines may be modified using <I><a href="#setLineThickness">V_setLineThickness</a></I>.<BR>For examples, see the demo programs VDEMO and FITDEMO.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#xyDataPlot">VF_xyDataPlot</a>,&nbsp;&nbsp; <a href="#yAutoPlot">VF_yAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a>,&nbsp;&nbsp; <a href="#setSymbolSize">V_setSymbolSize</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xy2AutoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_xy2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VD_xy2AutoPlot</b></font></td><td><font size="+1"><b>VE_xy2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_xy2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_xy2AutoPlot</b></font></td><td><font size="+1"><b>VSI_xy2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_xy2AutoPlot</b></font></td><td><font size="+1"><b>VQI_xy2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_xy2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_xy2AutoPlot</b></font></td><td><font size="+1"><b>VUS_xy2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_xy2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUQ_xy2AutoPlot</b></font></td><td><font size="+1"><b>VUI_xy2AutoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Draws a Cartesian coordinate system and plots two X-Y vector pairs into it.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VF_xy2AutoPlot( fVector&nbsp;X1, fVector&nbsp;Y1, ui&nbsp;size1, unsigned form1, COLORREF color1, fVector&nbsp;X2, fVector&nbsp;Y2, ui&nbsp;size2, unsigned form2, COLORREF color2&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xy2AutoPlot( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X1, unsigned form1, COLORREF color1, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X2, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y2, unsigned form2, COLORREF color2&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_xy2AutoPlot( X1, Y1:fVector; size1:UIntSize; form1:UInt; color1:COLORREF; X2, Y2:fVector; size2:UIntSize; form2:UInt; color2:COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector Y1 is plotted against the vector X1 and Y2 against X2 after automatically drawing a Cartesian coordinate system. For a description of the parameters form1, form2, and color1, color2, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. Prior to calling <I>VF_xy2AutoPlot</I>, the plotting routines have to be initialized by <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I>.
<BR>The VecObj version of this function has to be called as a member function of Y1 (rather than of X1).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#yAutoPlot">VF_yAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xyDataPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_xyDataPlot</b></font></td><td width="33%"><font size="+1"><b>VD_xyDataPlot</b></font></td><td><font size="+1"><b>VE_xyDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_xyDataPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_xyDataPlot</b></font></td><td><font size="+1"><b>VSI_xyDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_xyDataPlot</b></font></td><td><font size="+1"><b>VQI_xyDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_xyDataPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_xyDataPlot</b></font></td><td><font size="+1"><b>VUS_xyDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_xyDataPlot</b></font></td><td width="33%"><font size="+1"><b>VUQ_xyDataPlot</b></font></td><td><font size="+1"><b>VUI_xyDataPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>X-Y-plot into an existing Cartesian coordinate system.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VF_xyDataPlot( fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;size, unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xyDataPlot( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_xyDataPlot( X,&nbsp;Y:fVector; size:UIntSize; form:UInt; color:COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector Y is plotted against the vector X into a Cartesian coordinate system drawn by a prior call to one of the AutoPlot functions or to <I><a href="#drawAxes">V_drawAxes</a></I>. For a description of the parameters form and color, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>.
<BR>The VecObj version of this function has to be called as a member function of Y (rather than of X).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#yAutoPlot">VF_yAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="yAutoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_yAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VD_yAutoPlot</b></font></td><td><font size="+1"><b>VE_yAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_yAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_yAutoPlot</b></font></td><td><font size="+1"><b>VSI_yAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_yAutoPlot</b></font></td><td><font size="+1"><b>VQI_yAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_yAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_yAutoPlot</b></font></td><td><font size="+1"><b>VUS_yAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_yAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUQ_yAutoPlot</b></font></td><td><font size="+1"><b>VUI_yAutoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Draws a Cartesian coordinate system and plots each element of a Y-vector against its index.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;.
<BR>void VF_yAutoPlot( fVector&nbsp;Y, ui&nbsp;size, unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::yAutoPlot( unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_yAutoPlot( Y:fVector; size:UIntSize; form:UInt; color:COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian coordinate system is automatically scaled and drawn. Each element of the vector Y is plotted against its index into this coordinate system. For a description of the parameters form and color, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. The plotting routines have to be initialized by <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I> prior to calling <I>VF_yAutoPlot</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#yDataPlot">VF_yDataPlot</a>,&nbsp;&nbsp; <a href="#y2AutoPlot">VF_y2AutoPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="y2AutoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_y2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VD_y2AutoPlot</b></font></td><td><font size="+1"><b>VE_y2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_y2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_y2AutoPlot</b></font></td><td><font size="+1"><b>VSI_y2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_y2AutoPlot</b></font></td><td><font size="+1"><b>VQI_y2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_y2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_y2AutoPlot</b></font></td><td><font size="+1"><b>VUS_y2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_y2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUQ_y2AutoPlot</b></font></td><td><font size="+1"><b>VUI_y2AutoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Draws a Cartesian coordinate system and plots two Y-vectors, taking the index as the X-axis.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VF_y2AutoPlot( fVector&nbsp;Y1, ui&nbsp;size1, unsigned form1, COLORREF color1, fVector&nbsp;Y2, ui&nbsp;size2, unsigned form2, COLORREF color2&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::y2AutoPlot( unsigned form1, COLORREF color1, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y2, unsigned form2, COLORREF color2&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_y2AutoPlot( Y1:fVector; size1:UIntSize; form1:UInt; color1:COLORREF; Y2:fVector; size2:UIntSize; form2:UInt; color2:COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian coordinate system is automatically scaled and drawn. Each element of the vectors Y1 and Y2 is plotted at the X-position given by its index. For a description of the parameters form1, form2, and color1, color2, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. The plotting routines have to be initialized by <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I> prior to calling <I><a href="#yAutoPlot">VF_yAutoPlot</a></I>.
<BR>The VecObj version of this function has to be called as a member function of Y1.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#yDataPlot">VF_yDataPlot</a>,&nbsp;&nbsp; VF_y2AutoPlot,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="yDataPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_yDataPlot</b></font></td><td width="33%"><font size="+1"><b>VD_yDataPlot</b></font></td><td><font size="+1"><b>VE_yDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_yDataPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_yDataPlot</b></font></td><td><font size="+1"><b>VSI_yDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_yDataPlot</b></font></td><td><font size="+1"><b>VQI_yDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_yDataPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_yDataPlot</b></font></td><td><font size="+1"><b>VUS_yDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_yDataPlot</b></font></td><td width="33%"><font size="+1"><b>VUQ_yDataPlot</b></font></td><td><font size="+1"><b>VUI_yDataPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Plots a Y-vector into an existing Cartesian coordinate system, taking the index as the X-axis.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VF_yDataPlot( fVector&nbsp;Y, ui&nbsp;size, unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::yDataPlot( unsigned form, COLORREF color&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_yDataPlot( Y:fVector; size:UIntSize; form:UInt; color:COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of the vector Y is plotted into a Cartesian coordinate system that has to be already drawn by a prior call to one of the DataPlot functions or to <I><a href="#drawAxes">V_drawAxes</a></I>. The X-position is given by the index of the Y-element to be plotted. For a description of the parameters form and color, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#yAutoPlot">VF_yAutoPlot</a>,&nbsp;&nbsp; <a href="#y2AutoPlot">VF_y2AutoPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>&nbsp;

<P><a name="chap9"></a>
<HR width="100%"><H1>9. Scalar (non-vectorized) Functions </H1>
There are a few non-vectorized functions, stemming from <I>CMATH</I> and <I>XMATH</I>, which are necessary to use <I>VectorLib</I>. They are described here:

<P>&nbsp;<P><a name="fcplx"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>fcplx</b></font></td><td width="33%"><font size="+1"><b>dcplx</b></font></td><td><font size="+1"><b>ecplx</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialization of cartesian-complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>fComplex fcplx( float ReVal, float ImVal&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>dcplx,&nbsp;&nbsp; ecplx</I>)</td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function fcplx( xRe, xIm: Single&nbsp;):&nbsp;fComplex;</font>
<BR>alternative Syntax (a bit clumsy, but slightly more efficient):<font face="courier new">
<BR>procedure fcplx( var zy:fComplex; xRe, xIm: Single&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>dcplx,&nbsp;&nbsp; ecplx</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions allow to generate complex numbers of the three cartesian data types fComplex, dComplex, and eComplex. <I>CMATH</I> offers overloaded versions of these functions for C++. See <a href="CMATH.HTM#chap2_1">CMATH.HTM, chapter 2.1</a> for details.
<BR><I>fcplx</I> may be used whenever temporary complex variables are needed as arguments for functions. In this case, fcplx replaces the less elegant direct assignment of the real and imaginary parts, e.g.:
<BR><font face="courier new">&nbsp;&nbsp;z.Re = 3.0; z.Im = 4.0;
<BR>&nbsp;&nbsp;VCF_equC( X, size, z&nbsp;); /*&nbsp;less convenient */
<BR>&nbsp;&nbsp;VCF_equC( Y, size, fcplx( 3.0, 4.0&nbsp;)); /*&nbsp;easier */</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the generated complex number</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#fpolr">fpolr</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="isint"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>isint</b></font></td><td width="33%"><font size="+1"><b>isintl</b></font></td><td><font size="+1"><b>isintd</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>tests if a number is a whole number</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>int isint( double x&nbsp;);
<BR>int isintl( long double x&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses xmath;
<BR>function isint( x:Extended&nbsp;):&nbsp;IntBool;
<BR>function isintd( x:Double&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Returns TRUE (a value different from 0), if x is an integer number. FALSE (0) is returned, if x contains a non-zero fractional part.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>see above</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="isipow2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>isipow2</b></font></td><td width="33%"><font size="+1"><b>sisipow2</b></font></td><td><font size="+1"><b>lisipow2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>tests if an unsigned integer is an integer power of 2</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>int isipow2( unsigned x&nbsp;);
<BR>int sisipow2( unsigned short x&nbsp;);
<BR>int lisipow2( unsigned long x&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses xmath;
<BR>function isipow2( x:UInt&nbsp;):&nbsp;IntBool;
<BR>function sisipow2( x:USmall&nbsp;):&nbsp;IntBool;
<BR>function lisipow2( x:ULong&nbsp;):&nbsp;IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Returns TRUE (non-zero), if x is an integer power of 2:
<BR>x = 2<sup>n</sup>,&nbsp;&nbsp;&nbsp;n=1,2,3,...
<BR>Otherwise, FALSE (0) is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>see above</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="scal_log"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>log</b></font></td><td><font size="+1"><b>logd</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Natural logarithm: Pascal/Delphi only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax</td><td><font face="courier new">uses xmath;
<BR>function log( x:Extended x&nbsp;):&nbsp;Extended;
<BR>function logd( x:double x&nbsp;):&nbsp;Double;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The logarithm of the argument to the basis <I>e</I> is calculated and the result returned. The &quot;extended&quot; version of this function is almost identical to the built-in Pascal function <I>Ln</I>. Only the error handling occurs via the same handler as for the other <I>OptiVec</I> functions, rather than via the built-in handler of Pascal. The &quot;double&quot;-version, <I>logd</I>, is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>A DOMAIN error with NAN (&quot;not-a-number&quot;) as return value results from x &lt; 0 (including -0). A SING error with -HUGE_VAL as return value results from x=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The natural logarithm of the argument is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#scal_log2">log2</a>,&nbsp;&nbsp; <a href="#scal_log2">log2d</a>,&nbsp;&nbsp; <a href="#scal_log10">log10</a>,&nbsp;&nbsp; <a href="#scal_log10">log10d</a>,&nbsp;&nbsp; <a href="#log">VF_log</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="scal_log2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>log2</b></font></td><td width="33%"><font size="+1"><b>log2l</b></font></td><td><font size="+1"><b>log2d</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Binary logarithm</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log2( double x&nbsp;);
<BR>long double&nbsp;&nbsp;log2l( long double x&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses xmath;
<BR>function log2( x:Extended&nbsp;):&nbsp;Extended;
<BR>function log2d( x:Double&nbsp;):&nbsp;Double;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The logarithm of the argument to the basis 2 is calculated and the result returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>A DOMAIN error with NAN (&quot;not-a-number&quot;) as return value results from x &lt; 0 (including -0). A SING error with -HUGE_VAL as return value results from x=0.
<BR>In C/C++, the handling of both errors can be modified via <I>_matherr</I> or <I>_matherrl</I>, resp.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The binary logarithm of the argument is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#scal_log">log</a>,&nbsp;&nbsp; <a href="#scal_log10">log10</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="scal_log10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>log10</b></font></td><td><font size="+1"><b>log10d</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Decadic logarithm: Pascal/Delphi only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax</td><td><font face="courier new">uses xmath;
<BR>function log10( x:Extended x&nbsp;):&nbsp;Extended;
<BR>function log10d( x:double x&nbsp;):&nbsp;Double;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The logarithm of the argument to the basis 10 is calculated and the result returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>A DOMAIN error with NAN (&quot;not-a-number&quot;) as return value results from x &lt; 0 (including -0). A SING error with -HUGE_VAL as return value results from x=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The decadic logarithm of the argument is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I>log,&nbsp;&nbsp; <a href="#scal_log">logd</a>,&nbsp;&nbsp; <a href="#scal_log2">log2</a>,&nbsp;&nbsp; <a href="#scal_log2">log2d</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="fpolr"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>fpolr</b></font></td><td width="33%"><font size="+1"><b>dpolr</b></font></td><td><font size="+1"><b>epolr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialization of polar-complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>fPolar fpolr( float MagVal, float&nbsp;ArgVal&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>dpolr,&nbsp;&nbsp; epolr</I>)</td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function fpolr( xMag,&nbsp;xArg:Single&nbsp;):&nbsp;fPolar;</font>
<BR>alternative Syntax (a bit clumsy, but slightly more efficient):<font face="courier new">
<BR>procedure fpolr( var py:fPolar; xMag,&nbsp;xArg:Single&nbsp;);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>dpolr,&nbsp;&nbsp; epolr</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions allow to generate numbers of the three polar-complex data types fPolar, dPolar, and ePolar. <I>CMATH</I> offers overloaded versions of these functions for C++. See <a href="CMATH.HTM#chap2_1">CMATH.HTM, chapter 2.1</a> for details.
<BR><I>fpolr</I> may be used whenever temporary complex variables are needed as arguments for functions. In this case, fpolr replaces the less elegant direct assignment of the Mag and Arg parts, e.g.:
<BR><font face="courier new">&nbsp;&nbsp;p.Mag = 3.0; p.Arg = 1.5708;
<BR>&nbsp;&nbsp;VPF_equC( X, size, p&nbsp;); /*&nbsp;less convenient */
<BR>&nbsp;&nbsp;VPF_equC( Y, size, fpolr( 3.0, 1.5708&nbsp;)); /*&nbsp;easier */</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the generated polar-complex number</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#fcplx">fcplx</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="quadtod"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>quadtod</b></font></td><td><font size="+1"><b>_quadtold</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>convert a quad into a double or long double: C/C++ only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quadtod( quad x&nbsp;);
<BR>long double&nbsp;_quadtold( quad x&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions, along with their counterpart, <I><a href="#setquad">setquad</a></I>, provide the necessary interface for the use of the data type quad with Borland C++ (where <i>OptiVec</i> still maintains compatibility with earlier versions that had no complete built-in support for 64-bit integers). If, e.g., the value of a quad (say, of x) has to be printed, this must be done by a function call like
<BR><font face="courier new">printf( &quot;% 20.0Lf&quot;, <I>_quadtold</I>( x&nbsp;));</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the value of x is returned as a double or long double.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setquad"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>setquad</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>converts a long double into a quad: C/C++ only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>quad setquad( long double x&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function, along with its counterparts, <I><a href="#quadtod">quadtod</a></I> and <I><a href="#quadtod">_quadtold</a></I>, provides the necessary interface for the use of the data type quad with Borland C++ (where <i>OptiVec</i> still maintains compatibility with earlier versions that had no complete built-in support for 64-bit integers).
<BR>If, e.g., quad parameters are required by a function, they have to be passed either as existing variables of this data type, or else as in the following example:
<BR><font face="courier new"><a href="#addC">VQI_addC</a>( QI2, QI1,size, setquad( 53563369.L&nbsp;));</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the value of x is returned as a quad.</td></tr></table></td></tr>
</table>

<BR>&nbsp;<BR><H1>E N D </H1>
Copyright for <I>OptiVec</I> software and documentation
<BR>&copy; 1996-2017 <I>OptiCode</I> - Dr. Martin Sander Software Dev.
<BR>All rights reserved!
</body>
</html>