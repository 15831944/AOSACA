<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
   <meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <title>OptiVec: MatrixLib</title>
   <link rel="stylesheet" media="screen" type="text/css" href="stylesheet.css">
</head>
<body>
<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR><TD><IMG SRC="optivec.gif" BORDER=0 WIDTH=280 alt="OptiVec logo">&nbsp;
</TD><TD><h1><i><b><font size="+4">OptiVec</font></b></i><BR>&nbsp;<BR>Version 7</h1>
<BR><h2>for C/C++ and for Pascal / Delphi</h2>
</td></tr><tr><TD>
<i>OptiCode</i>
<BR>Dr. Martin Sander Software Development
<BR>Brahmsstr. 6
<BR>D-32756 Detmold
<BR>Germany
<BR><a href="http://www.optivec.com">http://www.optivec.com</a>
<BR>e-mail: <A HREF="mailto:optivec@gmx.de">optivec@gmx.de</A>
</TD><TD><h1>Part II: <I>MatrixLib</I></h1>
</TD></TR></TABLE>&nbsp;
<BR>A general description of <i>OptiVec</i> is given in <a href="HANDBOOK.HTM">HANDBOOK.HTM</a>.
<BR><a href="HANDBOOK.HTM#chap1_2">Chapter 1.2</a> of that file contains the licence terms for the Shareware version, <a href="HANDBOOK.HTM#chap1_3">Chapter 1.3</a> for the Registered version.
<BR>See <a href="FUNCREF.HTM">FUNCREF.HTM</a> for the description of individual <i>VectorLib</i> functions,
<BR>and <a href="CMATH.HTM">CMATH.HTM</a> for <i>CMATH</i> functions.


<P><A NAME="TOC"></A>
<BR>&nbsp;<BR><HR WIDTH="100%"><H1>Contents </H1>

&nbsp;&nbsp;<a href="#chap1">1. Introduction</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap1_1">1.1 Matrix Data Types</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap1_2">1.2 Prefixes of <i>MatrixLib</i> Functions</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap1_3">1.3 C/C++ Specifics</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap1_3_1">1.3.1 <I>MatObj</I>, the object-oriented interface for matrix functions</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap1_3_2">1.3.2 Direct-pointer form of matrix function calls</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap1_4">1.4 Pascal/Delphi Specifics</a>
<BR>&nbsp;&nbsp;<a href="#chap2">2. Management of Dynamically Generated Matrices</a>
<BR>&nbsp;&nbsp;<a href="#chap3">3. Initialization of Matrices</a>
<BR>&nbsp;&nbsp;<a href="#chap4">4. Data-Type Conversions</a>
<BR>&nbsp;&nbsp;<a href="#chap5">5. Symmetry Operations (Transposing, Rotating, Reflecting),&nbsp; Interpolation, Augmenting, Deleting, Extracting, and Filling Parts of a Matrix</a>
<BR>&nbsp;&nbsp;<a href="#chap6">6. Arithmetic Operations Performed on a Single Row, Column, or the Diagonal</a>
<BR>&nbsp;&nbsp;<a href="#chap7">7. Operations Performed Along All Rows or All Columns Simultaneously, or the Diagonal; Center Of Gravity</a>
<BR>&nbsp;&nbsp;<a href="#chap8">8. Operations Involving Two Rows or Two Colums</a>
<BR>&nbsp;&nbsp;<a href="#chap9">9. Whole-Matrix Arithmetics: Addition, Multiplication</a>
<BR><a href="#chap10">10. Linear Algebra </a>
<BR><a href="#chap11">11. Eigenvalues and Eigenvectors, Matrix Square-Root</a>
<BR><a href="#chap12">12. Fourier-Transform Methods</a>
<BR><a href="#chap13">13. Data Fitting</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap13_1">13.1 Polynomials</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap13_2">13.2 General Linear Model Functions</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap13_3">13.3 Non-Linear Models</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap13_4">13.4 Fitting Multiple Data Sets</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap13_5">13.5 Helper Functions for Nonlinear Fits</a>
<BR><a href="#chap14">14. Matrix Input and Output</a>
<BR><a href="#chap15">15. Graphical Representation of Matrices</a>
<BR><a href="#chap16">16. Alphabetical Reference for <I>MatrixLib</I></a>

<P><a name="chap1"></a>
<HR width="100%"><H2>1. Introduction</H2>
The <I>MatrixLib</I> part of <I>OptiVec</I> builds upon the principles established in the <I>VectorLib</I> part. You may wish to refer to the introductory chapters of <a href="HANDBOOK.HTM">HANDBOOK.HTM</a>, before reading on for <I>MatrixLib</I>.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_1"></a>
<H3>1.1 Matrix Data Types</H3>
As <i>VectorLib</i> defines vector data types, here are the matrix data types, defined in <i>MatrixLib</i>:
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><B>fMatrix</B></TD><TD>matrix of <B>float</B>s</TD></TR>
<TR><TD><B>dMatrix</B></TD><TD>matrix of <B>double</B>s</TD></TR>
<TR><TD><B>eMatrix</B></TD><TD>matrix of <B>extended (long double)</B></TD></TR>
<TR><TD><B>cfMatrix</B></TD><TD>matrix of <B>fComplex (complex&lt;float&gt;)</B></TD></TR>
<TR><TD><B>cdMatrix</B></TD><TD>matrix of <B>dComplex (complex&lt;double&gt;)</B></TD></TR>
<TR><TD><B>ceMatrix</B></TD><TD>matrix of <B>eComplex (complex&lt;extended&gt;)</B></TD></TR>
<TR><TD><B>iMatrix</B></TD><TD>matrix of <B>int</B></TD></TR>
<TR><TD><B>uMatrix</B></TD><TD>matrix of <B>unsigned int</B></TD></TR>
<TR><TD>and so on</TD><TD>for all other integer data types</TD></TR>
</TABLE>
&nbsp;
<BR>The ordering of elements is the same as in the two-dimensional arrays provided by the respective target compilers. This means that the matrices are stored row-wise in <I>MatrixLib</I> versions for C and C++ compilers, but column-wise in the Pascal/Delphi versions.

<P>While we recommend to exclusively use these dynamically allocated matrix types, static matrices defined, e.g., as 
<BR><font face="courier new"> float&nbsp;MX[4][6]; </font> (for C/C++), or
<BR><font face="courier new"> MX: array[0..3][0..5] of Single; </font> (for Pascal/Delphi)
<BR>can be used in all <i>MatrixLib</i> functions with the exception of the <I><a href="#multiLinfit">multiLinfit</a></I>
and <I><a href="#multiNonlinfit">multiNonlinfit</a></I> routines.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_2"></a>
<H3>1.2 Prefixes of <I>MatrixLib</I> Functions</H3>
Each <i>MatrixLib</i> function has a prefix defining the data type on which it acts:
<TABLE BORDER WIDTH="100%" >
<TR><TD><B>Prefix:</B></TD> <TD><B>Arguments:</B></TD></TR>
<TR><TD WIDTH="25%">MF_</TD><TD><B>fMatrix</B>, <B>float</B> and <B>fVector</B></TD></TR>
<TR><TD>MD_</TD><TD><B>dMatrix</B>, <B>double</B> and <B>dVector</B></TD></TR>
<TR><TD>ME_</TD><TD><B>eMatrix</B>, <B>extended (long double)</B> and <B>eVector</B></TD></TR>
<TR><TD>MCF_</TD><TD><B>cfMatrix</B>, <B>fComplex</B> and <B>cfVector</B></TD></TR>
<TR><TD>MCD_</TD><TD><B>cdMatrix</B>, <B>dComplex</B> and <B>cdVector&nbsp;</B></TD></TR>
<TR><TD>MCE_</TD><TD><B>ceMatrix</B>, <B>eComplex</B> and <B>ceVector</B></TD></TR>
<TR><TD>MI_</TD><TD><B>iMatrix</B>, <B>int</B> and <B>iVector</B></TD></TR>
<TR><TD>MU_</TD><TD><B>uMatrix</B>, <B>unsigned int</B> and <B>uVector</B></TD></TR>
<TR><TD>&nbsp;</TD><TD>similarly for all other integer types</TD></TR>
</TABLE>&nbsp;

<BR>In a few cases, the prefix is augmented by a three-letter code denoting special matrix properties:
<UL>
<LI><B><I>MFdia_</I></B> means that the function expects a diagonal matrix (i.e., a square matrix which has non-zero elements only on the diagonal); as there is no sense in storing all the zeros, diagonal matrix are actually stored as vectors, holding only the diagonal elements.
<BR>&nbsp;<LI><I><B>MFsym_ </B></I> denotes a function which expects the input matrix to be symmetric. At present, only <I><a href="#eigenvalues">MFsym_eigenvalues</a></I> and <I><a href="#sqrt">MFsym_sqrt</a></I> make use of this assumption.
<BR>&nbsp;<LI><I><B>MFtrd_</B></I> means the function is for a tridiagonal matrix (i.e., a square matrix with non-zero elements only on the diagonal plus or minus one column). A tridiagonal matrix has to be entered in the form of a matrix with three rows, representing the three vectors actually containing non-zero data. In other words, the original matrix 
<BR>&nbsp;<table border cellspacing=1><tr valign="top"><td>d<sub>0</sub></td><td>u<sub>0</sub></td><td>0</td><td>&#183;&#183;&#183;</td><td>&nbsp;</TD><td>&nbsp;</TD></tr>
<tr valign="top"><td>l<sub>1</sub></td><td>d<sub>1</sub></td><td>u<sub>1</sub></td><td>0</td><td>&#183;&#183;&#183;</td><td>&nbsp;</TD></tr>
<tr valign="top"><td>0</td><td>l<sub>2</sub></td><td>d<sub>2</sub></td><td>u<sub>2</sub></td><td>0</td><td>&#183;&#183;&#183;</td></tr>
<tr valign="top"><td>&nbsp;</TD><td>&nbsp;</TD><td>&nbsp;</TD><td>&#183;&#183;&#183;</td><td>&nbsp;</TD><td>&nbsp;</TD></tr>
<tr valign="top"><td>&nbsp;</TD><td>&nbsp;</TD><td>&nbsp;</TD><td>l<sub>N-2</sub></td><td>d<sub>N-2</sub></td><td>u<sub>N-2</sub></td></tr>
<tr valign="top"><td>&nbsp;</TD><td>&nbsp;</TD><td>&nbsp;</TD><td>0</td><td>l<sub>N-1</sub></td><td>d<sub>N-1</sub></td></tr>
</table>&nbsp;
<BR>is compacted into the form<BR>&nbsp;
<table border cellspacing=1><tr valign="top"><td>u<sub>0</sub>&nbsp;</td><td>u<sub>1</sub>&nbsp;</td><td>u<sub>2</sub>&nbsp;</td><td>&#183;&#183;&#183;&nbsp;</td><td>u<sub>N-2</sub>&nbsp;</td><td> *&nbsp;</td></tr>
<tr valign="top"><td>d<sub>0</sub></td><td>d<sub>1</sub></td><td>d<sub>2</sub></td><td>&#183;&#183;&#183;</td><td>d<sub>N-2</sub></td><td>d<sub>N-1</sub>&nbsp;</td></tr>
<tr valign="top"><td> *&nbsp;</td><td>l<sub>1</sub></td><td>l<sub>2</sub></td><td>&#183;&#183;&#183;</td><td>l<sub>N-2</sub></td><td>l<sub>N-1</sub></td></tr>
</table>&nbsp;
<BR>The elements l<sub>0</sub> and u<sub>N-1</sub>, marked with an asterisk, are undefined and never used.
</UL>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap1_3"></a>
<H3>1.3 C/C++ Version Specifics</H3>
<a name="chap1_3_1"></a>
<H3>1.3.1 <I>MatObj</I>, the object-oriented interface for matrix functions</H3>
Similarly to the <a href="HANDBOOK.HTM#chap3">vector objects of <I>VecObj</I></a>, the object-oriented interface for the matrix functions is contained in the include-files &lt;fMatObj.h&gt;, &lt;dMatObj.h&gt; etc., with one include-file for each of the data-types supported in <I>OptiVec</I>. Remember that, in order to get the whole interface (for all data types at once),
<BR><font face="courier new">#include &lt;OptiVec.h&gt;.</font>
<BR>For access to any of the vector graphics functions, always include &lt;OptiVec.h&gt;.
<P>By analogy with the alias names of the vector objects, the matrix objects get the alias names fMatObj, dMatObj, and so on, with the data-type signalled by the first one or two letters of the class name.
<P>The matrix constructors are:
<BR>matrix(); // no memory allocated, dimensions set to 0
<BR>matrix( ui&nbsp;ht, ui&nbsp;len&nbsp;); // ht by len matrix allocated
<BR>matrix( ui&nbsp;ht, ui&nbsp;len, T fill&nbsp;); // as before, but initialized with value &quot;fill&quot;
<BR>matrix( matrix &lt;T&gt; init&nbsp;); //  creates a copy of the matrix &quot;init&quot;

<P>For the matrix classes, the arithmetic operators
<BR>+&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;+=&nbsp;&nbsp;&nbsp;&nbsp;-=&nbsp;&nbsp;&nbsp;&nbsp;*=
<BR>are defined. 
<BR><B>While the vector-vector operator *&nbsp;refers to element-wise multiplication, the matrix-matrix, vector-matrix, or matrix-vector operator *&nbsp;means true matrix-matrix or matrix-vector multiplication.</B>

<P>If you ever need to process a <I>MatObj</I> matrix in a &quot;classic&quot; plain-C <I>OptiVec</I> function, you may use the member functions<BR>
<I>getHt()</I> and <I>getLen()</I> to retrieve the matrix dimensions, <BR>
<I>getMatrix</I> to obtain the actual matrix pointer of the data type fMatrix etc., or<BR>
<I>getM0</I> for the vector M[0] of the data type fVector&nbsp;etc., which is actually a pointer to the first matrix element.

<P>The syntax of all <I>MatObj</I> functions is described <a href="#chap16">below</a> together with
the basic <I>MatrixLib</I> functions for which <I>tMatObj</I> serves as a wrapper.

<P>Please note the following restrictions, coming from the tight control of matrix dimensions for compatibility:
<UL><LI>With the "normal" <I>MF_</I> functions, one can use some large matrix as working space for 
matrices of smaller dimensions. As long as one does not access individual elements or rows, but uses only whole matrices, this allows to use one and the same working space, say for an [n *&nbsp;n] and an [m *&nbsp;n] matrix (m &lt; n: neglect one or more rows). This is not possible in <I>MatObj</I>, where the matrix dimensions are encapsulated, and no distinction between "actual" and "used" dimensions can be made.
<LI>It is not even possible to overwrite, e.g., a non-square matrix with its transpose, even if you were willing to sacrifice the row pointers, and even if the number of matrix elements obviously stays the same.
<LI>All <I>MatObj</I> <I>Dia_...</I> functions require square matrices (ht = len), whereas <I>MF_Dia_...</I> functions work, in principle, with non-square matrices, as long as the parameter "len" in the function call corresponds to the smaller dimension.
<LI>The <I>multifit</I> functions are not encapsulated, as the <a href="#chap13_4EXPERIMENT">VF_EXPERIMENT and MF_EXPERIMENT</a> structures need pointers rather than objects anyway.
</UL>

<a name="chap1_3_2"></a>
<H3>1.3.2 Direct-pointer form of matrix function calls</H3>
In the C/C++ version of <i>MatrixLib</i>, all functions taking matrix arguments exist in a second form. In this form, all matrix arguments are replaced by pointers to the first elements of the respective matrices. You can explicitly use the second form by leaving away the underbar of the function-name prefix. Calling
<BR><font face="courier new"> <a href="#mulM">MF_mulM</a>( MC,&nbsp;MA,&nbsp;MB, htA,&nbsp;lenA,&nbsp;lenB&nbsp;);</font>
<BR>is equivalent to calling
<BR><font face="courier new">MFmulM(&amp;(MC[0][0]),&amp;(MA[0][0]),&amp;(MB[0][0]),htA,lenA,lenB);</font> or 
<BR><font face="courier new">MFmulM( MC[0], MA[0], MB[0], htA,&nbsp;lenA,&nbsp;lenB&nbsp;);</font>
<BR>Actually, the run-time routines are in the second form, and the <I>MatObj</I> member functions as well as the macros defined in &lt;MFstd.h&gt; etc. convert calls to the first form into calls to the second form.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap1_4"></a>
<H3>1.4 Pascal/Delphi Version Specifics:</H3>
In the Pascal/Delphi version of <i>MatrixLib</i>, matrices of all data types are actually defined as pointers to the element M[0][0]. This means you can pass static matrices (like <font face="courier new">MX: array[0..5][0..5] of Single; </font>) to <i>MatrixLib</i> functions with the address operator:
<BR><font face="courier new"><a href="#equ1">MF_equ1</a>( @(MX[0][0]), 6&nbsp;);</font>
<P>The situation is somewhat different for dynamic arrays in Delphi. While, in the one-dimensional case, they they can be used with all <i>VectorLib</i> functions by simply type-casting fArrays into fVectors, two-dimensional arrays require a different approach: Dynamic two-dimensional arrays can be created in Delphi by declaring them as &quot;array of fArray&quot;, &quot;array of dArray&quot;, etc. Short-cut definitions for these types are also given in the <i>VecLib</i> unit, as f2DArray, d2DArray, etc. As a consequence of the described way of defining 2D-Arrays in Delphi, each row of a matrix is stored in a separate vector. This means that the matrix elements do no longer occupy a single, contiguous memory space. Therefore, 2DArrays cannot be used directly with <i>MatrixLib</i> functions.
Instead, they have to be copied into matrices by calling <I><a href="#2DArrayToMatrix">MF_2DArrayToMatrix</a></I> etc., before <i>MatrixLib</i> functions can be used on them. The reverse conversion is available as <I><a href="#MatrixTo2DArray">MF_MatrixTo2DArray</a></I>.
<P>In the following chapters, a brief summary of all <i>MatrixLib</i> function is given, ordered into groups according to their functionality. At the end of this file, <a href="#chap16">chapter&nbsp;16</a> describes all <I>MatrixLib</I>functions in alphabetical order.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap2"></a>
<HR width="100%"><H2>2. Management of Dynamically Generated Matrices</H2>
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#matrix">MF_matrix</a></TD><TD>allocate memory for a matrix</TD></TR>
<TR><TD><a href="#matrix0">MF_matrix0</a></TD><TD>allocate memory and set all elements 0</TD></TR>
<TR><TD><a href="#free">M_free</a></TD><TD>free one matrix (data-type independent)</TD></TR>
<TR><TD><a href="#nfree">M_nfree</a></TD><TD>free n matrices (data-type independent; only C/C++)</TD></TR>
<TR><TD><a href="#freeAll">V_freeAll</a></TD><TD>free all existing vectors and matrices</TD></TR>
</TABLE>&nbsp;
<BR><I>OptiVec</I>'s dynamically allocated matrices are aligned on 32-byte boundaries, which allows for optimum cache-line matching for the Pentium processor and its currently available successors and competitors.
<P><U>C/C++ version only:</U>
<BR><i>OptiVec</i>'s dynamically allocated matrices can be addressed just like two-dimensional static arrays of C/C++. If you have, e.g., an <font face="courier new">fMatrix&nbsp;X;</font> and a variable <font face="courier new">float&nbsp;a;</font>, you can write a line like
<BR><font face="courier new"> a = MX[3][5];</font>

<P><U>Both C/C++ and Pascal/Delphi versions:</U>
<BR>There are two functions addressing single elements. These functions are the only means to address elements in Pascal/Delphi, and are also needed for getting around the pointer arithmetics bug in some older versions of Borland C++:
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#Pelement">MF_Pelement</a></TD><TD>Pointer to a specific matrix element</TD></TR>
<TR><TD><a href="#element">MF_element</a></TD><TD>value of a specific matrix element</TD></TR>
</TABLE>

<BR>To assign a value to a specific matrix element, you should use the syntax
<BR><font face="courier new"> *(MF_Pelement( MX, ht,&nbsp;len,&nbsp;3, 4&nbsp;)) = 3.0; /*&nbsp;for C/C++*/ 
<BR>MF_Pelement( MX, ht,&nbsp;len,&nbsp;3, 4&nbsp;)^ := 3.0; (*&nbsp;for Pascal/Delphi *)</font>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap3"></a>
<HR width="100%"><H2>3. Initialization of Matrices</H2>
In order to initialize all matrix elements with the same value, or to perform the same arithmetic operation on all matrix elements simultaneously, please use the respective <i>VectorLib</i> function. You can do so, because all matrices are in fact stored as vectors, occupying a contiguous space in memory. All you have to do is to pass the first row of the matrix (rather than the matrix itself) to the vector function. Fore example, you can initialize all matrix elements with a constant C by calling
<BR><font face="courier new"> <a href="FUNCREF.HTM#equC">VF_equC</a>( MA[0], ht*len, C&nbsp;); /*&nbsp;C/C++ */
<BR>VF_equC( MA, ht*len, C&nbsp;); (*&nbsp;Pascal/Delphi *)</font>
<BR>As you shall see, some of the most common operations of this kind are also explicitly defined in <i>MatrixLib</i>, like initialization with zero, <I><a href="#equ0">MF_equ0</a></I>, or multiplication by a constant, available as <I><a href="#mulC">MF_mulC</a></I> (see <a href="#chap9">chapter&nbsp;9</a>). Here are the typical matrix initialization functions:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#equ0">MF_equ0</a></TD><TD>set all elements to 0</TD></TR>
<TR><TD><a href="#equ1">MF_equ1</a></TD><TD>identity matrix: set all diagonal elements to 1.0, all others to 0</TD></TR>
<TR><TD><a href="#equm1">MF_equm1</a></TD><TD>negative identity matrix: set all diagonal elements to -1.0, all others to 0</TD></TR>
<TR><TD><a href="#random">MF_random</a></TD><TD>fill with random numbers</TD></TR>
<TR><TD><a href="#outerprod">MF_outerprod</a></TD><TD>matrix formed by the &quot;outer product&quot; of two vectors</TD></TR>
<TR><TD><a href="#Row_equ0">MF_Row_equ0</a></TD><TD>set all elements of one specific row to 0</TD></TR>
<TR><TD><a href="#Col_equ0">MF_Col_equ0</a></TD><TD>set all elements of one specific column to 0</TD></TR>
<TR><TD><a href="#Dia_equ0">MF_Dia_equ0</a></TD><TD>set all diagonal elements to 0</TD></TR>
<TR><TD><a href="#Row_equC">MF_Row_equC</a></TD><TD>set all elements of one specific row to the constant C</TD></TR>
<TR valign="top"><TD><a href="#Col_equC">MF_Col_equC</a></TD><TD>set all elements of one specific column to the constant C</TD></TR>
<TR><TD><a href="#Dia_equC">MF_Dia_equC</a></TD><TD>set all diagonal elements to the constant C</TD></TR>
<TR><TD><a href="#Row_equV">MF_Row_equV</a></TD><TD>copy a vector into one specific row</TD></TR>
<TR><TD><a href="#Col_equV">MF_Col_equV</a></TD><TD>copy a vector into one specific column</TD></TR>
<TR><TD><a href="#Dia_equV">MF_Dia_equV</a></TD><TD>copy a vector into the diagonal</TD></TR>
<TR><TD><a href="#Trd_equM">MF_Trd_equM</a></TD><TD>copy a compacted tridiagonal matrix into a general matrix</TD></TR>
<TR><TD><a href="#equM">MF_equM</a></TD><TD>make one matrix the copy of another</TD></TR>
<TR><TD><a href="#neg">MF_neg</a></TD><TD>make one matrix the negative of another</TD></TR>
<TR><TD><a href="#conj">MCF_conj</a></TD><TD>make one matrix the complex conjugate of another</TD></TR>
<TR><TD><a href="#hermconj">MCF_hermconj</a></TD><TD>make one matrix the Hermitian conjugate of another: MB = MA<SUP>T*</SUP></TD></TR>
<TR valign="top"><TD><a href="#UequL">MF_UequL</a></TD><TD>copy lower-diagonal elements into upper-diagonal by index-reflection, so as to get a symmetric matrix</TD></TR>
<TR><TD><a href="#LequU">MF_LequU</a></TD><TD>copy upper-diagonal elements into lower-diagonal</TD></TR>
</TABLE>
&nbsp;
<BR>Two-dimensional windows for spectral analysis are provided by:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#Hann">MF_Hann</a></TD><TD>Hann window</TD></TR>
<TR><TD><a href="#Parzen">MF_Parzen</a></TD><TD>Parzen window</TD></TR>
<TR><TD><a href="#Welch">MF_Welch</a></TD><TD>Welch window</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap4"></a>
<HR width="100%"><H2>4. Data-Type Conversions</H2>
Matrices of every data type can be converted into every other. Only a few examples are given; the rest should be obvious.
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#FtoD">M_FtoD</a></TD><TD><B>fMatrix</B> to <B>dMatrix</B></TD></TR>
<TR><TD><a href="#FtoD">M_EtoD</a></TD><TD><B>eMatrix</B> to <B>dMatrix</B> (with overflow protection)</TD></TR>
<TR><TD><a href="#FtoD">M_CDtoCF</a></TD><TD><B>cdMatrix</B> to <B>cfMatrix</B> (with overflow protection)</TD></TR>
<TR><TD><a href="#FtoD">M_DtoE</a></TD><TD><B>dMatrix</B> to <B>eMatrix</B></TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap5"></a>
<HR width="100%"><H2>5. Symmetry Operations (Transposing, Rotating, Reflecting),<BR>
Interpolation, Augmenting, Deleting, Extracting, and Filling Parts of a Matrix</H2>
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#transpose">MF_transpose</a></TD><TD>transpose a matrix: MB = MA<SUP>T</SUP></TD></TR>
<TR><TD><a href="#hermconj">MCF_hermconj</a></TD><TD>Hermitian conjugate: MB = MA<SUP>T*</SUP></TD></TR>
<TR><TD><a href="#rotate90">MF_rotate90</a></TD><TD>clockwise rotation by 90&deg;</TD></TR>
<TR><TD><a href="#rotate180">MF_rotate180</a></TD><TD>rotation by 180&deg;</TD></TR>
<TR><TD><a href="#rotate270">MF_rotate270</a></TD><TD>clockwise rotation by 270&deg; (or counter-clockwise rotation by 90 &deg;)</TD></TR>
<TR><TD><a href="#Rows_rev">MF_Rows_rev</a></TD><TD>reverse the element order along rows; this corresponds to a reflection of the matrix at the Y axis</TD></TR>
<TR><TD><a href="#Cols_rev">MF_Cols_rev</a></TD><TD>reverse the element order along columns; this corresponds to a reflection of the matrix at the X axis</TD></TR>
<TR><TD><a href="#Rows_reflect">MF_Rows_reflect</a></TD><TD>set the upper halves of all rows equal to their reversed lower halves</TD></TR>
<TR><TD><a href="#Cols_reflect">MF_Cols_reflect</a></TD><TD>set the upper halves of all columns equal to their reversed lower halves</TD></TR>
<TR valign="top"><TD><a href="#UequL">MF_UequL</a></TD><TD>copy lower-diagonal elements into upper-diagonal by index-reflection, so as to get a symmetric matrix</TD></TR>
<TR><TD><a href="#LequU">MF_LequU</a></TD><TD>copy upper-diagonal elements into lower-diagonal</TD></TR></TABLE>
&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#polyinterpol">MF_polyinterpol</a></TD><TD>polynomial interpolation</TD></TR>
<TR><TD><a href="#ratinterpol">MF_ratinterpol</a></TD><TD>rational interpolation</TD></TR>
<TR><TD><a href="#natCubSplineInterpol">MF_natCubSplineInterpol</a></TD><TD>natural cubic spline interpolation</TD></TR>
<TR><TD><a href="#equMblock">MF_equMblock</a></TD><TD>extract a block, i.e. a submatrix for which the sampling interval both along rows and along columns is 1</TD></TR>
<TR><TD><a href="#equMblockT">MF_equMblockT</a></TD><TD>extract the transpose of a block</TD></TR>
<TR><TD><a href="#submatrix">MF_submatrix</a></TD><TD>extract a submatrix with sampling intervals along rows and/or columns possibly different from 1</TD></TR>
<TR valign="top"><TD><a href="#block_equM">MF_block_equM</a></TD><TD>copy a matrix back into a block of another (normally larger) matrix</TD></TR>
<TR valign="top"><TD><a href="#block_equMT">MF_block_equMT</a></TD><TD>copy the transpose of a matrix into a block of another (normally larger) matrix</TD></TR>
<TR valign="top"><TD><a href="#submatrix_equM">MF_submatrix_equM</a></TD><TD>copy a submatrix back into another (normally larger) matrix</TD></TR>
<TR><TD><a href="#Row_extract">MF_Row_extract</a></TD><TD>extract a single row and copy it into a vector</TD></TR>
<TR><TD><a href="#Col_extract">MF_Col_extract</a></TD><TD>extract a single column and copy it into a vector</TD></TR>
<TR valign="top"><TD><a href="#Dia_extract">MF_Dia_extract</a></TD><TD>extract the diagonal and copy it into a vector</TD></TR>
<TR><TD><a href="#Trd_extract">MF_Trd_extract</a></TD><TD>extract a tridiagonal matrix from a general matrix</TD></TR>
<TR><TD><a href="#Row_insert">MF_Row_insert</a></TD><TD>augment a matrix by insertion of one row</TD></TR>
<TR><TD><a href="#Col_insert">MF_Col_insert</a></TD><TD>augment a matrix by insertion of one column</TD></TR>
<TR><TD><a href="#Row_delete">MF_Row_delete</a></TD><TD>delete one row of a matrix</TD></TR>
<TR><TD><a href="#Col_delete">MF_Col_delete</a></TD><TD>delete one column of a matrix</TD></TR>
</TABLE>&nbsp;
<BR>Note that, in contrast to the <i>VectorLib</i> functions <I><a href="FUNCREF.HTM#insert">VF_insert</a></I> and <I><a href="FUNCREF.HTM#delete">VF_delete</a></I>, insertion and deletion of rows or columns of matrices is not done in-place. Rather, the <I>MF_Row_insert</I> etc. store the augmented or truncated input matrix MA in an output matrix MB. If augmenting, be sure that MB is large enough to accommodate the enlarged output matrix! Normally, this means that you have to create a new matrix MB before calling <I>MF_???_insert</I> and possibly discarding MA by calling
<font face="courier new"><a href="#free">M_free</a>( MA&nbsp;);</font> afterwards.
<BR>If this process is repeated more often, you might wish to avoid the inefficiency of these &quot;create new&quot; - &quot;copy&quot; - &quot;delete old&quot; cycles. In this case, you can create MA from the outset with the maximum dimensions that will eventually be reached (or, if these are not known beforehand, with the upper limits of both ht and len). During the build-up process then, you have to keep track of the actual dimensions and use these (not the maxima
used for allocation!) in all <i>MatrixLib</i> function calls. Now you may overwrite the original matrix by the augmented one in each call to <I>MF_???_insert</I> as, e.g., in:
<BR><font face="courier new">MF_Row_insert( MA, MA, ++actualhtA, actuallenA, 0, X&nbsp;);</font>
<P><u>C++ with dynamic matrices only:</u>
<BR>If you overwrite MA by MB in the column insertion/deletion functions, you lose the possibility of accessing individual matrix elements by writing <font face="courier new">MB[i][j]</font>. This is no longer possible, as the row pointers of the output matrix will still remain those of the input matrix. Then, you can only use <I><a href="#element">MF_element</a></I> and <I><a href="#Pelement">MF_Pelement</a></I> to access individual elements. If you are exclusively inserting/deleting rows rather than columns, on the other hand, the row pointers remain valid.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap6"></a>
<HR width="100%"><H2>6. Arithmetic Operations Performed on a Single Row, Column, or the Diagonal</H2>
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#Row_neg">MF_Row_neg</a></TD><TD>multiply all elements of a specific row by -1</TD></TR>
<TR><TD><a href="#Col_neg">MF_Col_neg</a></TD><TD>multiply all elements of a specific column by -1</TD></TR>
<TR><TD><a href="#Row_addC">MF_Row_addC</a></TD><TD>add a constant to all elements of a specific row</TD></TR>
<TR><TD><a href="#Col_addC">MF_Col_addC</a></TD><TD>add a constant to all elements of a specific column</TD></TR>
<TR><TD><a href="#Dia_addC">MF_Dia_addC</a></TD><TD>add a constant to all diagonal elements</TD></TR>
<TR><TD><a href="#Row_addV">MF_Row_addV</a></TD><TD>add corresponding vector elements to all elements of a specific row</TD></TR>
<TR><TD><a href="#Col_addV">MF_Col_addV</a></TD><TD>add corresponding vector elements to all elements of a specific column</TD></TR>
<TR><TD><a href="#Dia_addV">MF_Dia_addV</a></TD><TD>add corresponding vector elements to the diagonal elements</TD></TR>
</TABLE>
&nbsp;
<BR>A few examples should suffice for the other functions of this family:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#Row_subC">MF_Row_subC</a></TD><TD>subtract a constant from all elements of a specific row</TD></TR>
<TR><TD><a href="#Col_subrC">MF_Col_subrC</a></TD><TD>reverse substraction: difference between column elements and a constant</TD></TR>
<TR><TD><a href="#Dia_mulV">MF_Dia_mulV</a></TD><TD>multiply the diagonal elements with corresponding vector elements</TD></TR>
<TR><TD><a href="#Row_divV">MF_Row_divV</a></TD><TD>divide all elements of a specific row by corresponding vector elements</TD></TR>
<TR><TD><a href="#Col_divrC">MF_Col_divrC</a></TD><TD>reverse division: division of a constant by the individual column elements</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap7"></a>
<HR width="100%"><H2>7. Operations Performed Along All Rows or All Columns Simultaneously, or Along the Diagonal of a Square Matrix<br>
Distribution (Histogram), Center of Gravity</H2>
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#Rows_max">MF_Rows_max</a></TD><TD>store the maxima of all rows in a column vector</TD></TR>
<TR><TD><a href="#Cols_max">MF_Cols_max</a></TD><TD>store the maxima of all colums in a row vector</TD></TR>
<TR><TD><a href="#Dia_max">MF_Dia_max</a></TD><TD>return the maximum of the diagonal as a scalar</TD></TR>
<TR><TD><a href="#Rows_absmax">MF_Rows_absmax</a></TD><TD>store the absolute maxima of all rows in a column vector</TD></TR>
<TR><TD><a href="#Cols_absmax">MF_Cols_absmax</a></TD><TD>store the absolute maxima of all colums in a row vector</TD></TR>
<TR><TD><a href="#Dia_absmax">MF_Dia_absmax</a></TD><TD>return the absolute maximum of the diagonal as a scalar</TD></TR>
<TR><TD><a href="#Rows_sum">MF_Rows_sum</a></TD><TD>sum, taken along rows and stored in a column vector</TD></TR>
<TR><TD><a href="#Cols_sum">MF_Cols_sum</a></TD><TD>sum, taken along colums and stored in a row vector</TD></TR>
<TR><TD><a href="#Dia_sum">MF_Dia_sum</a></TD><TD>sum of the diagonal elements</TD></TR>
<TR><TD><a href="#Rows_prod">MF_Rows_prod</a></TD><TD>product, taken along rows and stored in a column vector</TD></TR>
<TR><TD><a href="#Cols_prod">MF_Cols_prod</a></TD><TD>product, taken along colums and stored in a row vector</TD></TR>
<TR><TD><a href="#Dia_prod">MF_Dia_prod</a></TD><TD>product of the diagonal elements</TD></TR>
<TR><TD><a href="#Rows_runsum">MF_Rows_runsum</a></TD><TD>running sum along rows</TD></TR>
<TR><TD><a href="#Cols_runsum">MF_Cols_runsum</a></TD><TD>running sum along columns</TD></TR>
<TR><TD><a href="#Rows_runprod">MF_Rows_runprod</a></TD><TD>running product along rows</TD></TR>
<TR><TD><a href="#Cols_runprod">MF_Cols_runprod</a></TD><TD>running product along columns</TD></TR>
<TR><TD><a href="#Rows_rotate">MF_Rows_rotate</a></TD><TD>rotate all rows by a specified number of positions</TD></TR>
<TR><TD><a href="#Rows_rotate_buf">MF_Rows_rotate_buf</a></TD><TD>rotate all rows by a specified number of positions, using a specified buffer as work-space</TD></TR>
<TR><TD><a href="#Cols_rotate">MF_Cols_rotate</a></TD><TD>rotate all columns by a specified number of positions</TD></TR>
<TR><TD><a href="#Cols_rotate_buf">MF_Cols_rotate_buf</a></TD><TD>rotate all columns by a specified number of positions, using a specified buffer as work-space</TD></TR>
<TR><TD><a href="#Rows_reflect">MF_Rows_reflect</a></TD><TD>set the upper halves of all rows equal to their reversed lower halves</TD></TR>
<TR><TD><a href="#Cols_reflect">MF_Cols_reflect</a></TD><TD>set the upper halves of all columns equal to their reversed lower halves</TD></TR>
<TR><TD><a href="#Rows_rev">MF_Rows_rev</a></TD><TD>reverse the element order along rows; this corresponds to a reflection of the matrix at the Y axis</TD></TR>
<TR><TD><a href="#Cols_rev">MF_Cols_rev</a></TD><TD>reverse the element order along columns; this corresponds to a reflection of the matrix at the X axis</TD></TR>
<TR><TD><a href="#Rows_FFT">MF_Rows_FFT</a></TD><TD>Fourier Transform along rows</TD></TR>
<TR><TD><a href="#Cols_FFT">MF_Cols_FFT</a></TD><TD>Fourier Transform along columns</TD></TR>
<TR><TD><a href="#Rows_distribution">MF_Rows_distribution</a></TD><TD>Histogram (one-dimensional distribution function) along rows</TD></TR>
<TR><TD><a href="#Cols_distribution">MF_Cols_distribution</a></TD><TD>Histogram (one-dimensional distribution function) along colums</TD></TR>
</TABLE>
<P>Please note that multiplying all rows or all columns by one and the same vector is equivalent to a multiplication by a diagonal matrix, which is provided by <I><a href="#mulMdia">MF_mulMdia</a></I> and <I><a href="#TmulMdia">MF_TmulMdia</a></I>.
<BR>For all of the above functions involving maxima (<I>...max, &nbsp;...absmax</I>), the corresponding minima are found by the functions named <I>...min,&nbsp; ...absmin</I>. 
<BR>For complex numbers, maxima can be defined by various criteria. The following table summarizes the functions finding them (again, of course, the corresponding functions for the minima exist as well):<BR>&nbsp;

<TABLE BORDER WIDTH="100%" >
<TR VALIGN="TOP"><TD><a href="#Rows_absmax">MCF_Rows_absmax</a></TD><TD>store the maxima of the absolute values of all rows in a (real-valued) column vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Cols_absmax">MCF_Cols_absmax</a></TD><TD>store the maxima of the absolute values of all colums in a (real-valued) row vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Dia_absmax">MCF_Dia_absmax</a></TD><TD>return the maximum of the absolute values of the diagonal elements as a (real) scalar</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Rows_absmaxReIm">MCF_Rows_absmaxReIm</a></TD><TD>find the maximum absolute values of all real and of all imaginary parts separately along the rows of a matrix; merge the maxima into complex numbers, and store them in a column vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Cols_absmaxReIm">MCF_Cols_absmaxReIm</a></TD><TD>find the maximum absolute values of all real and of all imaginary parts separately along the columns of a matrix; merge the maxima into complex numbers, and store them in a row vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Dia_absmaxReIm">MCF_Dia_absmaxReIm</a></TD><TD>find the maximum absolute values of all real and of all imaginary parts separately along the diagonal of a square matrix; merge these two maxima into one complex number and return it as a scalar</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Rows_cabsmax">MCF_Rows_cabsmax</a></TD><TD>find the complex numbers of largest magnitude along rows and store these row maxima in a (complex) column vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Cols_cabsmax">MCF_Cols_cabsmax</a></TD><TD>find the complex numbers of largest magnitude along columns and store these column maxima in a (complex) row vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Dia_cabsmax">MCF_Dia_cabsmax</a></TD><TD>find the complex number of largest magnitude along the diagonal of a square matrix and return it as a (complex) scalar</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Rows_maxReIm">MCF_Rows_maxReIm</a></TD><TD>find the maxima of all real and of all imaginary parts separately along the rows of a matrix; merge the maxima into complex numbers, and store them in a column vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Cols_maxReIm">MCF_Cols_maxReIm</a></TD><TD>find the maxima of all real and of all imaginary parts separately along the columns of a matrix; merge the maxima into complex numbers, and store them in a row vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Dia_maxReIm">MCF_Dia_maxReIm</a></TD><TD>find the maximum of all real and of all imaginary parts separately along the diagonal of a square matrix; merge these two maxima into one complex number and return it as a scalar</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Rows_sabsmax">MCF_Rows_sabsmax</a></TD><TD>find the complex numbers of largest sum |Re|+|Im| along rows and store these row maxima in a (complex) column vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Cols_sabsmax">MCF_Cols_sabsmax</a></TD><TD>find the complex numbers of largest sum |Re|+|Im| along columns and store these column maxima in a (complex) row vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Dia_sabsmax">MCF_Dia_sabsmax</a></TD><TD>find the complex number of largest sum |Re|+|Im| along the diagonal of a square matrix and return it as a (complex) scalar</TD></TR>
</TABLE>

<P>To determine the center of gravity of a matrix, you have the choice between the following two functions:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR VALIGN="TOP"><TD><a href="#COGI">MF_centerOfGravityInd</a></TD><TD>center of gravity, returned as interpolated element indices</TD></TR>
<TR VALIGN="TOP"><TD><a href="#COGV">MF_centerOfGravityV</a></TD><TD>center of gravity of an MZ matrix with explicitly given X and Y axes</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap8"></a>
<HR width="100%"><H2>8. Operations Involving Two Rows or Two Colums</H2>

<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#Rows_exchange">MF_Rows_exchange</a></TD><TD>exchange two rows</TD></TR>
<TR><TD><a href="#Cols_exchange">MF_Cols_exchange</a></TD><TD>exchange two columns</TD></TR>
<TR><TD><a href="#Rows_add">MF_Rows_add</a></TD><TD>add one row to another (destination += source)</TD></TR>
<TR><TD><a href="#Cols_add">MF_Cols_add</a></TD><TD>add one column to another</TD></TR>
<TR><TD><a href="#Rows_sub">MF_Rows_sub</a></TD><TD>subtract one row from another (destination -= source)</TD></TR>
<TR><TD><a href="#Cols_sub">MF_Cols_sub</a></TD><TD>subtract one column from another</TD></TR>
<TR><TD><a href="#Rows_Cadd">MF_Rows_Cadd</a></TD><TD>add scaled row to another (destination += C *&nbsp;source)</TD></TR>
<TR><TD><a href="#Cols_Cadd">MF_Cols_Cadd</a></TD><TD>add scaled column to another</TD></TR>
<TR><TD><a href="#Rows_lincomb">MF_Rows_lincomb</a></TD><TD>linear combination of two rows</TD></TR>
<TR><TD><a href="#Cols_lincomb">MF_Cols_lincomb</a></TD><TD>linear combination of two columns</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap9"></a>
<HR width="100%"><H2>9. Whole-Matrix Arithmetics: Addition, Multiplication</H2>
<B>a) Element-wise operations</B>
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD WIDTH="25%"><a href="#addM">MF_addM</a></TD><TD>add two matrices</TD></TR>
<TR valign="top"><TD><a href="#addMT">MF_addMT</a></TD><TD>add one matrix and the transpose of another matrix<BR>
MC = MA + MB<sup>T</sup></TD></TR>
<TR valign="top"><TD><a href="#subM">MF_subM</a></TD><TD>subtract one matrix from another</TD></TR>
<TR valign="top"><TD><a href="#subMT">MF_subMT</a></TD><TD>subtract a transposed matrix<BR>
MC = MA - MB<sup>T</sup></TD></TR>
<TR valign="top"><TD><a href="#subrMT">MF_subrMT</a></TD><TD>subtract a matrix from another, transposed, matrix<BR>
MC = MB<sup>T</sup> - MA</TD></TR>
<TR valign="top"><TD><a href="#mulC">MF_mulC</a></TD><TD>multiply all matrix elements by a constant</TD></TR>
<TR valign="top"><TD><a href="#mulC">MCF_mulReC</a></TD><TD>multiply all elements of a complex matrix by a real number</TD></TR>
<TR valign="top"><TD><a href="#divC">MF_divC</a></TD><TD>divide all matrix elements by a constant</TD></TR>
<TR valign="top"><TD><a href="#divC">MCF_divReC</a></TD><TD>divide all elements of a complex matrix by a real number</TD></TR>
<TR valign="top"><TD><a href="#addM">MFs_addM</a></TD><TD>scaled addition of two matrices:<BR>
MC = c *&nbsp;(MA + MB)</TD></TR>
<TR valign="top"><TD><a href="#addMT">MFs_addMT</a></TD><TD>scaled addition of one matrix and the transpose of another:<BR>MC = c *&nbsp;(MA + MB<sup>T</sup>)</TD></TR>
<TR valign="top"><TD><a href="#subM">MFs_subM</a></TD><TD>scaled subtraction of two matrices:<BR>
MC = c *&nbsp;(MA - MB)</TD></TR>
<TR valign="top"><TD><a href="#subMT">MFs_subMT</a></TD><TD>scaled subtraction of one matrix and the transpose of another:<BR>MC = c *&nbsp;(MA - MB<sup>T</sup>)</TD></TR>
<TR valign="top"><TD><a href="#subrMT">MFs_subrMT</a></TD><TD>scaled reverse subtraction of one matrix and the transpose of another:<BR>MC = c *&nbsp;(MB<sup>T</sup> - MA)</TD></TR>
<TR valign="top"><TD><a href="#lincomb">MF_lincomb</a></TD><TD>linear combination:<BR>
MC = ca *&nbsp;MA + cb *&nbsp;MB</TD></TR>
</TABLE>
<P><B>b) Matrix multiplication:</B>
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD WIDTH="25%"><a href="#mulV">MF_mulV</a></TD><TD>multiply a matrix by a column vector:<BR>
Y = MA *&nbsp;X</TD></TR>
<TR valign="top"><TD><a href="#TmulV">MF_TmulV</a></TD><TD>multiply the transpose of a matrix by a column vector:<BR>
Y = MA<SUP>T</SUP> *&nbsp;X</TD></TR>
<TR valign="top"><TD><a href="#mulM">VF_mulM</a></TD><TD>multiply a row vector by a matrix:<BR>
Y = X *&nbsp;MA</TD></TR>
<TR valign="top"><TD><a href="#mulMT">VF_mulMT</a></TD><TD>multiply a row vector by the transpose of a matrix:<BR>
Y = X *&nbsp;MA<SUP>T</SUP></TD></TR>
<TR valign="top"><TD><a href="#mulM">MF_mulM</a></TD><TD>multiply two matrices:<BR>
MC = MA *&nbsp;MB</TD></TR>
<TR valign="top"><TD><a href="#mulMT">MF_mulMT</a></TD><TD>multiply one matrix by the transpose of another matrix:<BR>
MC = MA *&nbsp;MB<SUP>T</SUP></TD></TR>
<TR valign="top"><TD><a href="#TmulM">MF_TmulM</a></TD><TD>multiply the transpose of a matrix by another matrix:<BR>
MC = MA<SUP>T</SUP> *&nbsp;MB</TD></TR>
<TR valign="top"><TD><a href="#TmulMT">MF_TmulMT</a></TD><TD>multiply the transpose of one matrix by the transpose of another matrix:<BR>
MC = MA<SUP>T</SUP> *&nbsp;MB<SUP>T</SUP></TD></TR>
<TR valign="top"><TD><a href="#mulMH">MCF_mulMH</a></TD><TD>multiply one matrix by the hermitian conjugate of another matrix:<BR>
MC = MA *&nbsp;MB<SUP>T *</SUP></TD></TR>
<TR valign="top"><TD><a href="#HmulM">MCF_HmulM</a></TD><TD>multiply the hermitian conjugate of a matrix by another matrix:<BR>
MC = MA<SUP>T *</SUP> *&nbsp;MB</TD></TR>
<TR valign="top"><TD><a href="#TmulMH">MCF_TmulMH</a></TD><TD>multiply the transpose of one matrix by the hermitian conjugate of another matrix:<BR>
MC = MA<SUP>T</SUP> *&nbsp;MB<SUP>T*</SUP></TD></TR>
</TABLE>
<P><B>c) Multiplications of general matrices by diagonal matrices or <I>vice versa</I></B>
<BR>The diagonal matrix is passed to the respective function as a vector.
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD WIDTH="25%"><a href="#mulMdia">MF_mulMdia</a></TD><TD>multiply a general matrix by a diagonal matrix:<BR>
MC = MA *&nbsp;MBDia</TD></TR>
<TR valign="top"><TD><a href="#TmulMdia">MF_TmulMdia</a></TD><TD>multiply the transpose of a matrix by a diagonal matrix:<BR>
MC = MA<SUP>T</SUP> *&nbsp;MBDia</TD></TR>
<TR valign="top"><TD><a href="#dia_mulM">MFdia_mulM</a></TD><TD>multiply a diagonal matrix by a general matrix:<BR>
MC = MADia *&nbsp;MB</TD></TR>
<TR valign="top"><TD><a href="#dia_mulMT">MFdia_mulMT</a></TD><TD>multiply a diagonal matrix by the transpose of a general matrix:<BR>
MC = MADia *&nbsp;MB<SUP>T</SUP></TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap10"></a>
<HR width="100%"><H2>10. Linear Algebra</H2>
There are three groups of linear algebra functions. The first group consists of &quot;easy-to-use&quot; versions which can be used as black-box functions without caring about their internal working. The second group consists of functions for LU decomposition and its applications. The third group, finally, is devoted to Singular Value Decomposition (SVD). Except for the functions based on SVD, the linear algebra functions are available both for real and for complex matrices.
<BR>Here are the &quot;easy-to-use&quot; versions of linear algebra functions:
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#solve">MF_solve</a></TD>
<TD>solve simultaneous linear equations (using LU decomposition)</TD></TR>
<TR><TD><a href="#inv">MF_inv</a></TD><TD>invert a matrix</TD></TR>
<TR><TD><a href="#det">MF_det</a></TD><TD>determinant of a matrix</TD></TR>
<TR><TD><a href="#solveBySVD">MF_solveBySVD</a></TD><TD>solve simultaneous linear equations, using Singular Value Decomposition</TD></TR>
<TR><TD><a href="#safeSolve">MF_safeSolve</a></TD><TD>tries first solution by LUD; if that fails, SVD is done</TD></TR>
</TABLE>&nbsp;
<BR>Now some functions for explicit LU decomposition and for treatment of LU decomposed matrices:
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#LUdecompose">MF_LUdecompose</a>&nbsp;</TD><TD>decompose into LU form</TD></TR>
<TR><TD><a href="#LUDresult">MF_LUDresult</a></TD><TD>check if <a href="#LUdecompose">MF_LUdecompose</a> was successful</TD></TR>
<TR><TD><a href="#LUDsetEdit">MF_LUDsetEdit</a></TD><TD>set editing threshold for <a href="#LUdecompose">MF_LUdecompose</a>; may be used to work around singularities</TD></TR>
<TR><TD><a href="#LUDgetEdit">MF_LUDgetEdit</a></TD><TD>retrieve currently set threshold</TD></TR>
<TR><TD><a href="#LUsolve">MF_LUsolve</a></TD><TD>solve simultaneous linear equations, given the matrix in LU form</TD></TR>
<TR><TD><a href="#LUimprove">MF_LUimprove</a></TD><TD>improve the accuracy of the solution of an LU-decomposed linear system by iteration</TD></TR>
<TR><TD><a href="#LUinv">MF_LUinv</a></TD><TD>invert matrix already composed into LU form</TD></TR>
<TR><TD><a href="#LUdet">MF_LUdet</a></TD><TD>determinant of matrix already composed into LU form</TD></TR>
</TABLE>&nbsp;
<BR>Singular Value Decomposition and related functions are offered as:
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#SVdecompose">MF_SVdecompose</a>&nbsp;</TD><TD>Singular Value Decomposition</TD></TR>
<TR><TD><a href="#SVsort">MF_SVsort</a>&nbsp;</TD><TD>Sorting of Singular Values in descending order with comcomitant re-ordering of left and right singular vectors</TD></TR>
<TR><TD><a href="#SVsolve">MF_SVsolve</a></TD><TD>solve SV-decomposed set of linear equations</TD></TR>
<TR><TD><a href="#SVDsetEdit">MF_SVDsetEdit</a></TD><TD>set threshold for Singular Value editing</TD></TR>
<TR><TD><a href="#SVDgetEdit">MF_SVDgetEdit</a></TD><TD>retrieve current threshold for Singular Value editing</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap11"></a>
<HR width="100%"><H2>11. Eigenvalues and Eigenvectors, Matrix Square-Root</H2>
At present, only the special, but most frequent case of symmetric real matrices is covered:
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#eigenvalues">MFsym_eigenvalues</a>&nbsp;</TD>
<TD>eigenvalues with or without eigenvectors of a symmetric real matrix</TD></TR>
<TR><TD><a href="#sqrt">MFsym_sqrt</a>&nbsp;</TD>
<TD>square-root of a symmetric, positive definite matrix</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap12"></a>
<HR width="100%"><H2>12. Fourier-Transform Methods</H2>
By analogy with the corresponding one-dimensional Fourier Transform methods described in the <a href="HANDBOOK.HTM#chap4_8"><i>VectorLib</i> handbook</a>, the following functions for the two-dimensional case are available in <i>MatrixLib</i>:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD WIDTH="20%"><a href="#FFT">MF_FFTtoC</a></TD><TD>Forward Fast Fourier Transform (FFT) of a real matrix; the result is a cartesian complex matrix</TD></TR>
<TR valign="top"><TD><a href="#FFT">MF_FFT</a></TD><TD>Forward and backward FFT of real matrices; using symmetry relations, the complex result is packed into a real matrix of the same size as the input matrix</TD></TR>
<TR valign="top"><TD><a href="#FFT">MCF_FFT</a></TD><TD>Forward and backward FFT of complex matrices</TD></TR>
<TR valign="top"><TD><a href="#convolve">MF_convolve</a></TD><TD>Convolution with a spatial response function</TD></TR>
<TR><TD><a href="#deconvolve">MF_deconvolve</a></TD><TD>Deconvolution</TD></TR>
<TR><TD><a href="#filter">MF_filter</a></TD><TD>Spatial filtering</TD></TR>
<TR><TD><a href="#autocorr">MF_autocorr</a></TD><TD>Spatial autocorrelation</TD></TR>
<TR><TD><a href="#xcorr">MF_xcorr</a></TD><TD>Spatial cross-correlation</TD></TR>
<TR><TD><a href="#spectrum">MF_spectrum</a></TD><TD>Spatial frequency spectrum</TD></TR>
</TABLE>
<BR>The one-dimensional Fourier Transform along rows or along columns is available as:
<TABLE BORDER WIDTH="100%" >
<TR><TD width="20%"><a href="#Rows_FFT">MF_Rows_FFTtoC</a></TD><TD>Fourier Transform along rows (real input and complex output matrix)</TD></TR>
<TR><TD><a href="#Cols_FFT">MF_Cols_FFTtoC</a></TD><TD>Fourier Transform along columns (real input and complex output matrix)</TD></TR>
<TR><TD><a href="#Rows_FFT">MF_Rows_FFT</a></TD><TD>Fourier Transform along rows (real input and packed output matrix)</TD></TR>
<TR><TD><a href="#Cols_FFT">MF_Cols_FFT</a></TD><TD>Fourier Transform along columns (real input and packed output matrix)</TD></TR>
<TR><TD><a href="#Rows_FFT">MCF_Rows_FFT</a></TD><TD>Fourier Transform along rows (complex input and output matrices)</TD></TR>
<TR><TD><a href="#Cols_FFT">MCF_Cols_FFT</a></TD><TD>Fourier Transform along columns (complex input and output matrices)</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap13"></a>
<HR width="100%"><H2>13. Data Fitting</H2>
<i>MatrixLib</i> provides a broad range of data fitting functions for various classes of model functions. Let us first show you an overview over the available functions, before we describe the various classes of model functions and their treatment in <I>OptiVec</I> fitting functions in detail.<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#linregress">VF_linregress</a></TD>
<TD>equally-weighted linear regression on X-Y data</TD></TR>
<TR><TD><a href="FUNCREF.HTM#linregress">VF_linregresswW</a></TD>
<TD>the same with non-equal weighting</TD></TR>
<TR><TD><a href="#polyfit">VF_polyfit</a></TD>
<TD>fitting of one X-Y data set to a polynomial</TD></TR>
<TR><TD><a href="#polyfit">VF_polyfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#linfit">VF_linfit</a></TD>
<TD>fitting of one X-Y data set to an arbitrary function linear in its parameters</TD></TR>
<TR><TD><a href="#linfit">VF_linfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#nonlinfit">VF_nonlinfit</a></TD>
<TD>fitting of one X-Y data set to an arbitrary, possibly non-linear function</TD></TR>
<TR><TD><a href="#nonlinfit">VF_nonlinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#multiLinfit">VF_multiLinfit</a></TD>
<TD>fitting of multiple X-Y data sets to one common linear function</TD></TR>
<TR><TD><a href="#multiLinfit">VF_multiLinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#multiNonlinfit">VF_multiNonlinfit</a></TD>
<TD>fitting of multiple X-Y data sets to one common nonlinear function</TD></TR>
<TR><TD><a href="#multiNonlinfit">VF_multiNonlinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#Mlinfit">MF_linfit</a></TD><TD>fit X-Y-Z data to a function linear in its parameters</TD></TR>
<TR><TD><a href="#Mlinfit">MF_linfitwW</a></TD><TD>the same with non-equal weighting of individual data points</TD></TR>
<TR><TD><a href="#Mnonlinfit">MF_nonlinfit</a></TD><TD>fit X-Y-Z data to an arbitrary, possibly non-linear function</TD></TR>
<TR><TD><a href="#Mnonlinfit">MF_nonlinfitwW</a></TD><TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#MmultiLinfit">MF_multiLinfit</a></TD><TD>fit multiple X-Y-Z data sets to one common linear function</TD></TR>
<TR><TD><a href="#MmultiLinfit">MF_multiLinfitwW</a></TD><TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#MmultiNonlinfit">MF_multiNonlinfit</a></TD><TD>fit multiple X-Y-Z data sets to one common nonlinear function</TD></TR>
<TR><TD><a href="#MmultiNonlinfit">MF_multiNonlinfitwW</a>&nbsp;</TD><TD>the same for non-equal data-point weighting</TD></TR>
</TABLE>&nbsp;
<BR>Now let us have a look at the various classes of model functions. The most simple one is a straight line, 
<BR><font face="courier new">Y<sub>i</sub> = a *&nbsp;X<sub>i</sub> + b;</font>
<BR>Fitting <font face="courier new">Y = f(X)</font> data to a straight line is called &quot;linear regression&quot; and accomplished by <a href="FUNCREF.HTM#linregress">VF_linregress</a>. 
<BR>The next level of sophistication are polynomials, described in the following paragraph:

<P><a name="chap13_1"></a>
<H3>13.1 Polynomials</H3>
Polynomials are functions of the form
<BR><font face="courier new"> Y<sub>i</sub> = a<sub>0</sub> + a<sub>1</sub>X<sub>i</sub> + a<sub>2</sub>X<sub>i</sub><sup>2</sup> ... a<sub>n</sub>X<sub>i</sub><sup>n</sup></font>
<BR>Just as linear regression, polynomial fitting is available for Y-X data (<a href="#polyfit">VF_polyfit</a>), but not for MZ=f(X,Y) data. In polynomial fitting, you are interested in the coefficients <I>a<sub>i</sub></I> up to a certain limit, the degree <I>n</I> of the polynomial. In the simplest form, all coefficients are treated as free parameters, without the possibility of &quot;fixing&quot; those whose values you happen to know beforehand. Polynomial fitting is most useful for degrees of 2 to 4. With degrees higher than 5, you will be able to fit almost any data - but the resulting coefficients will be at best inaccurate and at worst useless, as already very little experimental noise will strongly influence the balance of the higher terms. If you do need polynomials of higher degrees, you should carefully examine your problem to see which terms you can eliminate. This leads us from polynomials to the next class of fitting functions, namely:

<P><a name="chap13_2"></a>
<H3>13.2 General Linear Model Functions</H3>
In the general linear case, you have to write the model function yourself and pass it as an argument to the fitting routine. The word &quot;linear&quot; means that the model function consists of a linear combination of basis functions each of which depends linearly on the fitting coefficients:
<BR><font face="courier new"> y = a<sub>0</sub>f<sub>0</sub>(x) + a<sub>1</sub>f<sub>1</sub>(x) + a<sub>2</sub>f<sub>2</sub>(x)...</font>
<BR>The individual functions f<sub>i</sub>(x) may be non-linear in x, but not in the coefficients <I>a<sub>i</sub></I>. For example, <BR>
<font face="courier new"> y = a<sub>0</sub>sin(x)+ a<sub>1</sub>cos(x)</font><BR>
is a valid linear fitting function, but <BR>
<font face="courier new">y = sin(a<sub>0</sub>x)+ cos(a<sub>1</sub>x)</font><BR>
is not.

<BR>For general linear fits, the model function has to be provided in a form which calculates the individual basis functions for each x-value present in the data set. The above example with sine and cosine functions would be coded in C/C++ as
<P><font face="courier new"> void LinModel( fVector&nbsp;BasFuncs, float&nbsp;x, unsigned&nbsp;nfuncs&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;BasFuncs[0] = sin(x);
<BR>&nbsp;&nbsp;BasFuncs[1] = cos(x);
<BR>}</font>
<P>Note that the coefficients <I>a<sub>i</sub></I> are not used in the model function itself. The argument <I>nfuncs</I> (which is neglected in the above example) allows to use a variable number of basis functions. It is also possible to switch fitting parameters &quot;on&quot; and &quot;off&quot;, i.e., &quot;free&quot; or &quot;fixed&quot;. To this end, the routine <I><a href="#linfit">VF_linfit</a></I> takes a &quot;status&quot; array as an argument. For all members of the parameter vector that are to be treated as free, the corresponding &quot;status&quot; entry must be set to 1. If status<sub>i</sub> is set to 0, the corresponding parameter, <I>a<sub>i</sub></I>, is treated as fixed at its value upon input.
<BR>Internally, <I>VF_linfit</I> employs a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, Thresh, are
set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.
<P>Having noted above that functions like
<BR><font face="courier new"> y = sin(a<sub>0</sub>x)+ cos(a<sub>1</sub>x)</font>
<BR>require their own treatment, we arrive at the last and most general class of model functions:

<P><a name="chap13_3"></a>
<H3>13.3 Non-Linear Models</H3>
As described above, fits to linear model functions (which include, of course, simple polynomials) are performed internally by solving a set of coupled linear equations - which is basically a simple matrix inversion process. The situation for non-linear model functions is completely different: no closed-form solution exists, and the fitting problem can be solved only iteratively. Therefore, fitting to non-linear models is much more time-consuming (by 3-5 orders of magnitude!) than fitting to linear models. Two non-linear fitting algorithms are offered:
<UL><LI>the Levenberg-Marquardt method, and the
<LI>Downhill-Simplex method by Nelder and Mead.</UL>
As a starting-point, it is normally a good idea to choose a combination of both (choose <font face="courier new">FitOptions.LevelOfMethod = 3</font>, see below).
<BR>All non-linear fitting functions exist in two different syntax variants. One of them expects pointers to a struct <a href="#chap13_3NONLINFITOPTIONS">VF_NONLINFITOPTIONS</a> and to a struct <a href="#chap13_3NONLINFITWORKSPACE">VF_NONLINFITWORKSPACE</a> as arguments. This is the recommended form. It allows to run two or more fits simultaneously with different sets of options. Additionally, it allows to access the <a href="#chap13_5">helper functions for progress monitoring</a>. The second syntax variant does without these two parameters, using the default set of options and generating its own workspace. This second variant, however, does not allow to access the helper functions.
<BR>The fundamental difference between linear and non-linear data fitting is reflected also in the required formulation of the model functions. In contrast to the linear case, here it is not the individual basis functions which are needed. Rather, the model function will be called by <I><a href="#nonlinfit">VF_nonlinfit</a></I> with the whole X-vector as input argument and has to return the whole Y-vector. For the above non-linear sine and cosine example, this could be coded in C/C++ as
<P><font face="courier new"> void NonlinModel( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size)
<BR>{
<BR>&nbsp;&nbsp;for( ui&nbsp;i=0; i&lt;size; i++&nbsp;) 
<BR>&nbsp;&nbsp;Y[i] = sin( a[0]*X[i]&nbsp;) + cos( a[1]*X[i]&nbsp;);
<BR>}</font>
<P>Keeping in mind that a nonlinear fitting routine will spend most of its time in your model function (and its derivatives, see below), you might wish to optimize this function, using vector functions. Suppose you have declared and allocated the fVector&nbsp;YHelp somewhere within your main program. Then you can write:
<P><font face="courier new"> void OptNonlinModel( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size)
<BR>{
<BR>&nbsp;&nbsp;VFx_sin( YHelp, X, size, a[0], 0.0, 1.0 );
<BR>&nbsp;&nbsp;VFx_cos( Y, &nbsp;&nbsp;&nbsp;&nbsp;X, size, a[1], 0.0, 1.0 );
<BR>&nbsp;&nbsp;VF_addV( Y, Y, YHelp, size );
<BR>}</font>
<P>The parameter array &quot;a&quot; should be global. It is passed as an argument to <I>VF_nonlinfit</I>, and its elements are changed during the fitting process. Upon input, &quot;a&quot; must (!) contain your initial &quot;best guess&quot; of the parameters. The better your guess, the faster <I>VF_nonlinfit</I> will converge. If your initial guess is too far off, convergence might be very slow or even never attained.
<P>All <I>nonlinfit</I> functions return the figure-of-merit of the best parameter array &quot;A&quot; found. To perform the fit, these functions need not only the fitting function itself, but also its partial derivatives with respect to the individual coefficients. Therefore, an argument &quot;Derivatives&quot; is required in calling the <I>nonlinfit</I> functions. If you happen to know the partial derivatives analytically, Derivatives should point to a function calculating them. If you do not know them, call with Derivatives = NULL (<B>nil</B> in Pascal/Delphi). In the latter case, all derivatives will be calculated numerically inside the functions. In cases where you know some, but not all of the partial derivatives of Y with respect to the coefficients <I>a<sub>i</sub></I>, you could also calculate dY / d<I>a<sub>i</sub></I> wherever you have an analytic formula, and call <I><a href="#nonlinfit_">VF_nonlinfit_autoDeriv</a></I> for the remaining coefficients. To demonstrate this possibility, here is a function coding the derivatives for our non-linear sine and cosine example:
<P><font face="courier new">VF_NONLINFITWORKSPACE ws;   // &amp;ws must be passed both to VF_nonlinfit and to VF_nonlinfit_autoDeriv
<BR>void DerivModel( fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned iPar&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;switch( iPar&nbsp;)
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 0:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( ui&nbsp;i=0; i&lt;size; i++&nbsp;) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi[i] = X[i] *&nbsp;cos( a[0]*X[i]&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 1: /*&nbsp;say we don't know this derivative: */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_nonlinfit_autoDeriv( dYdAi, X, size:UIntSize; ipar, &amp;ws );
<BR>&nbsp;&nbsp;}
<BR>}</font>
<P>Think twice, however, before resorting to <I>VF_nonlinfit_autoDeriv</I>: The function calls needed to determine the derivatives numerically may easily slow down your fit by a factor of 3 to 5! Anyway, as described above for the model function itself, also its derivatives should be implemented using vector functions. This leads us finally to the optimized version of the derivatives function:
<P><font face="courier new">void OptDerivModel( fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned iPar&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;switch( iPar&nbsp;)
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 0:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VFx_cos( dYdAi, X, size, a[0], 0.0, 1.0 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_mulV( dYdAi, dYdAi, X, size ); break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 1:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VFx_sin( dYdAi, X, size, a[1], 0.0, -1.0 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_mulV( dYdAi, dYdAi, X, size );
<BR>&nbsp;&nbsp;}
<BR>}</font>
<P>For actual working examples for the polynomial, general linear, and general non-linear cases, please see FITDEMO.CPP, FITDEMOW.CPP, FITDEMOB.BPR, FITDEMO.PAS, or FITDEMO.DPR.

<a name="chap13_3NONLINFITOPTIONS"></a>
<H4>VF_NONLINFITOPTIONS</H4>
<P>The nonlinear fitting routines are highly sophisticated and offer the user a lot of different options. These options may be set by the function <I><a href="#setNonlinfitOptions">V_setNonlinfitOptions</a></I>. To retrieve current settings, use
<BR><I><a href="#getNonlinfitOptions">V_getNonlinfitOptions</a></I>.
<BR>All options are packed into a structure (struct in C/C++, record in Pascal/Delphi) named <I>VF_NONLINFITOPTIONS</I>.
It has the following fields:<BR>&nbsp;
<table border width="100%"><tr valign="top"><td width="40%"><font face="courier new">int FigureOfMerit;</font></td><td>0: least squares fitting 
<BR>1: robust fitting, optimizing for minimum absolute deviation
<BR>(default: 0)</td></tr>
<tr valign="top"><td><font face="courier new">float&nbsp;AbsTolChi;</font></td><td>absolute change of <font face="symbol">c</font><sup>2</sup> (default: EPSILON)</td></tr>
<tr valign="top"><td><font face="courier new">float&nbsp;FracTolChi;</font></td><td>fractional change of <font face="symbol">c</font><sup>2</sup> (default: SQRT_EPSILON)</td></tr>
<tr valign="top"><td><font face="courier new">float&nbsp;AbsTolPar;</font></td><td>absolute change of all parameters (default: SQRT_MIN) </td></tr>
<tr valign="top"><td><font face="courier new">float&nbsp;FracTolPar;</font></td><td> fractional change of all parameters (default: SQRT_EPSILON)
<P>The four <font face="courier new">xxxTolChi</font> and <font face="courier new">xxxTolPar</font> parameters describe the convergence conditions: if the changes achieved in successive iterations are smaller than demanded by these criteria, this signals convergence. Criteria
which are not applicable should be set to 0.0.</td></tr>
<tr valign="top"><td><font face="courier new">unsigned HowOftenFulfill;</font></td><td> how often fulfill one of the above conditions before convergence is considered achieved (default: 3)</td></tr>
<tr valign="top"><td><font face="courier new">unsigned LevelOfMethod;</font></td><td>1: Levenberg-Marquardt method,
<BR>2: Downhill Simplex (Nelder and Mead) method,
<BR>3: both methods alternating;
<BR>add 4 to this in order to try breaking out of local minima;
<BR>0: no fit, calculate only <font face="symbol">c</font><sup>2</sup> (and Covar)
<BR>(default: 1)</td></tr>
<tr valign="top"><td><font face="courier new">unsigned LevMarIterations;</font></td><td>max.number of successful iterations of LevMar during one run (default: 100)</td></tr>
<tr valign="top"><td><font face="courier new">unsigned LevMarStarts;</font></td><td>number of LevMar restarts per run (default: 2)</td></tr>
<tr valign="top"><td><font face="courier new">float&nbsp;LambdaStart,
<BR>LambdaMin,
<BR>LambdaMax,
<BR>LambdaDiv,
<BR>LambdaMul; </font></td><td>treatment of LevMar parameter lambda (don't touch, unless you are an expert!)</td></tr>
<tr valign="top"><td><font face="courier new">unsigned DownhillIterations;</font></td><td>max. number of successful iterations in Downhill Simplex method (default: 200)</td></tr>
<tr valign="top"><td><font face="courier new">float&nbsp;DownhillReflection,
<BR>DownhillContraction,
<BR>DownhillExpansion;</font></td><td>treatment of re-shaping of the simplex in Downhill Simplex method (don't touch, unless you are an expert!)</td></tr>
<tr valign="top"><td><font face="courier new">unsigned TotalStarts;</font></td><td>max. number of LevMar/Downhill pairs (default: 16)</td></tr>
<tr valign="top"><td><font face="courier new">fVector&nbsp;UpperLimits,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LowerLimits;</font></td><td> impose upper and/or lower limits on parameters. Default for both: NULL or nil</td></tr>
<tr valign="top"><td><font face="courier new">void (*Restrictions)(void);</font></td><td>pointer to a user-defined function, implementing restrictions on the parameters which cannot be formulated as simple upper/lower limits. The function must check the whole parameter vector and edit the parameters as needed. Default: NULL or nil.</td></tr>
</table>&nbsp;
A set of options, set by <I><a href="#setNonlinfitOptions">V_setNonlinfitOptions</a></I>, is valid only as long as no other set of options is explicitly passed to  <i>VF_nonlinfit</i>. It is only the default value whose use is signalled to <i>VF_nonlinfit</i> by setting the corresponding parameter to NULL / nil (or if the simplified syntax is used which does not contain this parameter in the first place). 

<a name="chap13_3NONLINFITWORKSPACE"></a>
<H4>VF_NONLINFITWORKSPACE</H4>
<P>As described above, all non-linear fitting functions need a set of variables for internal use which, for the <i>VF_nonlinfit</i> family of functions, is contained in a struct (Delphi: record) VF_NONLINFITWORKSPACE. It is passed by its address to the respective function. This set of variables need not be initialized. It does not contain user-retrievable information. In the <i>MF_nonlinfit</i> family of functions, a similar set of internal variables is needed as MF_NONLINFITWORKSPACE.
<BR>A typical call of <i>VF_nonlinfit</i> would look like this in C/C++:
<P><font face="courier new">VF_NONLINFITWORKSPACE ws; 
<BR>VF_NONLINFITOPTIONS fopt;
<BR>V_getNonlinfitOptions( &amp;fopt );
<BR>// at this point, modify fopt as desired...
<BR>VF_nonlinfit( ParValues, AStatus, nParameters, X, Y, sz, ModelFunc, DerivativeFuncs, &amp;ws, &amp;fopt );
</font>
<P>or in Delphi:
<P><font face="courier new">ws: VF_NONLINFITWORKSPACE; 
<BR>fopt:  VF_NONLINFITOPTIONS;
<BR>V_getNonlinfitOptions( @fopt );
<BR>// at this point, modify fopt as desired...
<BR>VF_nonlinfit( ParValues, AStatus, nParameters, X, Y, sz, @ModelFunc, @DerivativeFuncs, @ws, @fopt );
</font>
<P>If you replace the parameter &amp;ws with NULL / nil, <i>VF_nonlinfit</i> will generate its own workspace.

<P><a name="chap13_4"></a>
<H3>13.4 Fitting Multiple Data Sets</H3>
In addition to the fitting functions for single data sets, there are routines for fitting multiple data sets simultaneously. Say, you are a physicist or a chemist and want to measure a rate constant <I>k</I>. You have performed the same kinetic measurement ten times under slightly different conditions. All these measurements have, of course, the same <I>k</I>, but other parameters, like amplitude and time-zero, will differ from experiment to experiment. Now, the usual way would be to perform one fit for each of these ten data sets and average over the resulting <I>k</I>'s. 
<BR>There is a problem with this approach: you don't really know which weight you have to assign to each of the measurements, and how to treat the overlapping error margins of the individual fits. You might want to perform a fit on all your data sets simultaneously, taking the same <I>k</I> for all data sets, and assigning individual amplitudes etc. to each set. This is precisely what the <I><a href="#multiLinfit">multiLinfit</a></I> and <I><a href="#multiNonlinfit">multiNonlinfit</a></I> functions of <i>MatrixLib</i> are designed for. You can fit multiple data-sets both to linear and nonlinear models, for Y = f(X) data as well as for MZ = f(X,Y) data.
<table width="100%"><tr><td width="10%">&nbsp;</TD><td>
<U>Pascal with DOS only:</U>
<BR>The module in which you define your model function must be compiled using the &quot;Force Far Calls&quot; option (Options/Compiler in the IDE or switch {$F+}&nbsp;) !</td></tr></table>&nbsp;
<BR>The <I><a href="#multiLinfit">multiLinfit</a></I> and <I><a href="#multiNonlinfit">multiNonlinfit</a></I> functions need the input data to be passed in structures named VF_EXPERIMENT for X-Y data and MF_EXPERIMENT for X-Y-Z data. In C/C++, <a name="chap13_4EXPERIMENT"></a>VF_EXPERIMENT has the following fields:<BR>&nbsp;
<table border width="100%"><tr valign="top"><td width="40%"><font face="courier new">fVector&nbsp;X, Y;</font></td><td>X and Y vectors: independent variable x and measured y=f(x) data</td></tr>
<tr valign="top"><td><font face="courier new">fVector&nbsp;InvVar;</font></td><td> inverse variances of the individual data points (needed only for the &quot;with weights&quot; functions)</td></tr>
<tr valign="top"><td><font face="courier new">ui&nbsp;size;</font></td><td>the number of data points</td></tr>
<tr valign="top"><td><font face="courier new">float&nbsp;WeightOfExperiment;</font></td><td>individual weight to be assigned to the whole experiment (again needed only for the weighted variants)</td></tr>
</table>&nbsp;
<BR>In C/C++, MF_EXPERIMENT has the following fields:<BR>&nbsp;
<table border width="100%"><tr valign="top"><td width="40%"><font face="courier new">fVector&nbsp;X, Y;</font></td><td>X and Y vectors (independent variables)</td></tr>
<tr valign="top"><td><font face="courier new">fMatrix&nbsp;Z;</font></td><td>measured data z=f(x,y)</td></tr>
<tr valign="top"><td><font face="courier new">fMatrix&nbsp;InvVar;</font></td><td> inverse variances of the individual matrix
elements (needed only for the &quot;with weights&quot; functions)</td></tr>
<tr valign="top"><td><font face="courier new">ui&nbsp;htZ, lenZ;</font></td><td>matrix dimensions</td></tr>
<tr valign="top"><td><font face="courier new">float&nbsp;WeightOfExperiment;</font></td><td>individual weight to be assigned to the whole experiment (again needed only for the weighted variants)</td></tr>
</table>&nbsp;

<BR>In Pascal/Delphi, VF_EXPERIMENT and MF_EXPERIMENT are defined as follows:
<P><font face="courier new">type VF_EXPERIMENT = record
<BR>&nbsp;&nbsp;X, Y, InvVar: fVector;
<BR>&nbsp;&nbsp;size: UIntSize;
<BR>&nbsp;&nbsp;WeightOfExperiment: Single;
<BR>end;
<BR>type PVF_EXPERIMENT = ^VF_EXPERIMENT;

<BR>&nbsp;<BR>type MF_EXPERIMENT = record
<BR>&nbsp;&nbsp;X,&nbsp;Y: fVector;
<BR>&nbsp;&nbsp;MZ, MInvVar: fMatrix;
<BR>&nbsp;&nbsp;htZ, lenZ: UIntSize;
<BR>&nbsp;&nbsp;WeightOfExperiment: Single;
<BR>end;
<BR>type PMF_EXPERIMENT = ^MF_EXPERIMENT;</font>

<P>Both in VF_EXPERIMENT and MF_EXPERIMENT, <I>InvVar</I> and <I>WeightOfExperiment</I> are needed only for the weighted variants of the <I>multifit</I> functions.

<P><a name="chap13_5"></a>
<H3>13.5 Helper Functions for Nonlinear Fits</H3>
As nonlinear fitting tasks - especially with multiple data sets - may become quite tedious and take a very long time (sometimes many hours!) to converge, there is a number of functions which allow to follow the course of nonlinear
fits. The names of these functions are always derived from the fitting function they are used with. For example, the helper functions for <I><a href="#nonlinfit">VF_nonlinfit</a></I> are:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="32%"><a href="#nonlinfit_">VF_nonlinfit_getBestValues</a></td><td>best set of parameters found so far</td></tr>
<tr valign="top"><td><a href="#nonlinfit_">VF_nonlinfit_getChi2</a></td><td>the best figure-of-merit (<font face="symbol">c</font><sup>2</sup>, chi-square) obtained so far</td></tr>
<tr valign="top"><td><a href="#nonlinfit_">VF_nonlinfit_getTestDir</a></td><td>returns the test direction (+1 for upwards, -1 for downwards) during &quot;breakout&quot; attempts (level-of-method greater than 3, see the description of <I><a href="#chap13_3NONLINFITOPTIONS">VF_NONLINFITOPTIONS</a></I> above)</td></tr>
<tr valign="top"><td><a href="#nonlinfit_">VF_nonlinfit_getTestPar</a></td><td>index of the parameter currently under &quot;breakout&quot; investigation</td></tr>
<tr valign="top"><td><a href="#nonlinfit_">VF_nonlinfit_getTestRun</a></td><td>index of the current &quot;breakout&quot; test run (for each fitted parameter, one test run is performed)</td></tr>
<tr valign="top"><td><a href="#nonlinfit_">VF_nonlinfit_stop</a></td><td>stops fitting after completion of the current Levenberg-Marquardt or Downhill cycle</td></tr>
</table>&nbsp;
<BR>For the other nonlinear fitting functions, the corresponding helper-function names are obtained by replacing the &quot;VF_nonlinfit_&quot; prefix with the respective fitting function name, as in <I><a href="#nonlinfit_">VF_nonlinfitwW_getBestValues</a></I>,
<I><a href="#MmultiNonlinfit_">MF_multiNonlinfit_stop</a></I>, and so on.
<BR>There are two possibilities how these functions can be called. The first way is to call them from within your model function. For example, you might install a counter into your model function and, upon reaching a certain number of calls, retrieve the current chi2, parameter set, etc. The second way is open only for multithreaded programs: a thread, different from the one performing the fit, may call any of the above functions to control the progress of the fit.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap14"></a>
<H2>14. Matrix Input and Output</H2>
The matrix input/output functions are all analogous to the corresponding vector functions
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD WIDTH="25%"><a href="#cprint">MF_cprint</a></TD>
<TD>print a matrix to the screen. If necessary, rows are cut off at the screen boundaries. If there are more rows than screen lines, proper paging is applied. For console applications only.</TD></TR>
<TR valign="top"><TD><a href="#print">MF_print</a></TD><TD>print a matrix to the screen (without paging or row cut-off); for console applications only</TD></TR>
<TR><TD><a href="#fprint">MF_fprint</a></TD><TD>print a matrix in ANSI format to a stream</TD></TR>
<TR><TD><a href="#store">MF_store</a></TD><TD>store in binary format</TD></TR>
<TR><TD><a href="#recall">MF_recall</a></TD><TD>retrieve in binary format</TD></TR>
<TR><TD><a href="#write">MF_write</a></TD><TD>write in ASCII format in a stream</TD></TR>
<TR><TD><a href="#read">MF_read</a></TD><TD>read from an ASCII file</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap15"></a>
<HR width="100%"><H2>15. Graphical Representation of Matrices</H2>
True 3D-plotting functions will be included in future versions. For now, only color-density plots are available. In these plots, each data value is translated into a color value by linear interpolation between two colors, specified as <I>mincolor</I> and <I>maxcolor</I>.<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>&nbsp;</TD><TD>Color density map for z=f(x,y) with automatic scaling of the <I>x</I> and <I>y</I> axes and of the color density scale between <I>mincolor</I> and <I>maxcolor</I></TD></TR>
<TR valign="top"><TD><a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a>&nbsp;</TD><TD>z=f(x,y) color density map, plotted into an existing axis frame, and using the color density scale set by the last call to an <I>AutoDensityMap</I> function</TD></TR>
<TR valign="top"><TD><a href="#zAutoDensityMap">MF_zAutoDensityMap</a></TD><TD>Color density map for z=f(i,j) with automatic scaling of the <I>x</I> and <I>y</I> axes and of the color density scale between <I>mincolor</I> and <I>maxcolor</I>. i and j are the indices in <I>x</I> and <I>y</I> direction, respectively</TD></TR>
<TR valign="top"><TD><a href="#zDataDensityMap">MF_zDataDensityMap</a></TD><TD>Color density map for z=f(i,j), plotted into an existing axis frame, and using the color density scale set by the last call to an <I>AutoDensityMap</I> function</TD></TR>
<TR valign="top"><TD><a href="#setDensityBounds">M_setDensityBounds</a></TD><TD>Set a color scale for matrix color-density plots.</TD></TR>
<TR valign="top"><TD><a href="#setDensityMapBounds">M_setDensityMapBounds</a></TD><TD>Set a color scale and draw an X-Y coordinate system for matrix color-density plots.</TD></TR>
<TR valign="top"><TD><a href="#findDensityMapBounds">M_findDensityMapBounds</a></TD><TD>Calculate a color scale and draw an X-Y coordinate system for matrix color-density plots, ensuring that the grid lines of the coordinate system correspond to exact (rather than only rounded) values.</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap16"></a>
<HR width="100%"><H2>16. Alphabetical Reference of <I>MatrixLib</I></H2>
This chapter&nbsp;describes, in alphabetical order, all <i>MatrixLib</i> functions. Similarly to the indexing of the vector functions in <a href="#FUNCREF.HTM#chap8">FUNCREF.HTM</a>, the <i>MF_</i> or <I>M_</I> prefix is neglected in the ordering of entries. The particles &quot;Row_&quot;, &quot;Rows_&quot;, &quot;Col_&quot;, &quot;Cols_&quot;, &quot;Dia_&quot;, and &quot;Trd_&quot;, however, are fully taken into account. For example, &quot;<I>MF_Rows_</I>&quot; functions will come after all &quot;<I>MF_Row_</I>&quot; functions. While most <i>MatrixLib</i> functions have the prefixes <i>MF_</i> or <I>M_</I>, please note that some - notably the X-Y fitting functions - have the prefix <I>VF_</I> as a reminder that they actually work on vectors, even if they rely on matrix methods and form a part of <I>MatrixLib</I>. In cases where both the <I>VF_</I> and the <I>MF_</I> versions exist, contrary to the alphabetical order the <I>VF_</I> version is described first, as it is the simpler one.

<P>&nbsp;<a name="addM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_addM</b></font>
</td><td width="33%"><font size="+1"><b>MD_addM</b></font></td>
<td><font size="+1"><b>ME_addM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFs_addM</b></font></td>
<td width="33%"><font size="+1"><b>MDs_addM</b></font></td>
<td><font size="+1"><b>MEs_addM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_addM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_addM</b></font></td>
<td><font size="+1"><b>MCE_addM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise addition of two matrices</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_addM( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MFs_addM( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::addM( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB);<BR>
void matrix&lt;T&gt;::s_addM( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_addM( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<BR>
procedure MFs_addM( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_addM( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMFs_addM( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMFs_addM( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_addM( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFs_addM( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_addM( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMFs_addM( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMFs_addM( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MF_addM( h_MC, h_MA, h_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);
<BR>procedure MFs_addM( h_MC, h_MA, h_MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: MC<sub>ij</sub> = MA<sub>ij</sub> + MB<sub>ij</sub>
<BR>scaled version: MC<sub>ij</sub> = C *&nbsp;(MA<sub>ij</sub> + MB<sub>ij</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#addMT">MF_addMT</a>,&nbsp;&nbsp; <a href="#subM">MF_subM</a>,&nbsp;&nbsp; <a href="subrM">MF_subrM</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="addMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_addMT</b></font>
</td><td width="33%"><font size="+1"><b>MD_addMT</b></font></td>
<td><font size="+1"><b>ME_addMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFs_addMT</b></font></td>
<td width="33%"><font size="+1"><b>MDs_addMT</b></font></td>
<td><font size="+1"><b>MEs_addMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_addMT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_addMT</b></font></td>
<td><font size="+1"><b>MCE_addMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise addition of one matrix and the transpose of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_addMT( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MFs_addMT( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::addMT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB);<BR>
void matrix&lt;T&gt;::s_addMT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_addMT( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<BR>
procedure MFs_addMT( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_addMT( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMFs_addMT( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMFs_addMT( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_addMT( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFs_addMT( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_addMT( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMFs_addMT( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMFs_addMT( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MF_addMT( h_MC, h_MA, h_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);
<BR>procedure MFs_addMT( h_MC, h_MA, h_MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: MC<sub>ij</sub> = MA<sub>ij</sub> + MB<sup>T</sup><sub>ji</sub>
<BR>scaled version: MC<sub>ij</sub> = C *&nbsp;(MA<sub>ij</sub> + MB<sup>T</sup><sub>ji</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#addM">MF_addM</a>,&nbsp;&nbsp; <a href="#subMT">MF_subMT</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="autocorr"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_autocorr</b></font>
</td><td width="33%"><font size="+1"><b>MD_autocorr</b></font></td>
<td><font size="+1"><b>ME_autocorr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Spatial autocorrelation function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_autocorr( fMatrix&nbsp;Y, fMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::autocorr( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_autocorr( MY,&nbsp;MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_autocorr( fMatrix&nbsp;d_Y, fMatrix&nbsp;d_X, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_autocorr( fMatrix&nbsp;h_Y, fMatrix&nbsp;h_X, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_autocorr( d_MY, d_MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_autocorr( h_MY, h_MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The spatial autocorrelation function (SACF) of MX is calculated and stored in MY in wrap-around order in both dimensions: The row elements MY<sub>i,0</sub> to MY<sub>i,len/2-1</sub> contain the SACF for zero and positive x lags. Beginning with the most negative lag in MY<sub>i,len/2+1</sub>, the elements up to MY<sub>i,len-1</sub> contain the SACF for negative lags. Since this function assumes MX to be periodic, the SACF for the most positive lag is identical to the SACF for the most negative lag. This element is stored as Y<sub>i,len/2</sub>.
<BR>Similarly, the column elements MY<sub>0,j</sub> to MY<sub>len/2-1,j</sub> contain the SACF for zero and positive y lags. Beginning with the most negative lag in MY<sub>len/2+1,j</sub>, the elements up to MY<sub>len-1,j</sub> contain the SACF for negative lags.
<BR>To get the SACF into normal order, you may call
<BR><font face="courier new"> <a href="#Rows_rotate">MF_Rows_rotate</a>( MY, ht,&nbsp;len,&nbsp;len/2&nbsp;);
<BR><a href="#Cols_rotate">MF_Cols_rotate</a>( MY, ht,&nbsp;len,&nbsp;ht/2&nbsp;);</font>
<BR>After that, the zero point is at the position MY<sub>ht/2,len/2</sub>.
<BR>In case MX is non-periodic, you should avoid end effects by the methods described in connection with <I><a href="#convolve">MF_convolve</a></I>.
<BR>Both <I>ht</I> and <I>len</I> must be integer powers of 2.
<BR>About special versions with the prefixes <I>MFl_</I> and <I>MFs_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8 of HANDBOOK.HTM</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either len or ht is not a power of 2, <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I> (on which <I>MF_autocorr</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">MF_convolve</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#chap12">chapter&nbsp;12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="block_equM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_block_equM</b></font>
</td><td width="33%"><font size="+1"><b>MD_block_equM</b></font></td>
<td><font size="+1"><b>ME_block_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_block_equM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_block_equM</b></font></td>
<td><font size="+1"><b>MCE_block_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_block_equM</b></font></td><td width="20%"><font size="+1"><b>MBI_block_equM</b></font></td><td width="20%"><font size="+1"><b>MSI_block_equM</b></font></td><td width="20%"><font size="+1"><b>MLI_block_equM</b></font></td><td><font size="+1"><b>MQI_block_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_block_equM</b></font></td><td width="20%"><font size="+1"><b>MUB_block_equM</b></font></td><td width="20%"><font size="+1"><b>MUS_block_equM</b></font></td><td width="20%"><font size="+1"><b>MUL_block_equM</b></font></td><td><font size="+1"><b>MUQ_block_equM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Copy a matrix into a "block" of another matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void  MF_block_equM( fMatrix&nbsp;Dest, <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned destHt,   unsigned destLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;Srce,  ui&nbsp;srceHt,  ui&nbsp;srceLen&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::block_equM( const&nbsp;ui&nbsp;firstRow,  const&nbsp;ui&nbsp;firstCol, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MSrce);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_block_equM( MDest:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destHt, destLen, firstRow, firstCol:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSrce:fMatrix; srceHt, srceLen:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_block_equM( fMatrix&nbsp;d_Dest, <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned destHt,   unsigned destLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;d_Srce,  ui&nbsp;srceHt,  ui&nbsp;srceLen&nbsp;);
<BR>void MFcu_block_equM( fMatrix&nbsp;h_Dest, <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned destHt,   unsigned destLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;h_Srce,  ui&nbsp;srceHt,  ui&nbsp;srceLen&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_block_equM( d_MDest:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destHt, destLen, firstRow, firstCol:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d_MSrce:fMatrix; srceHt, srceLen:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MF_block_equM( h_MDest:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destHt, destLen, firstRow, firstCol:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h_MSrce:fMatrix; srceHt, srceLen:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MDest<sub>i+firstRow, j+firstCol</sub> = MSrce<sub>i, j</sub>,&nbsp;&nbsp;i=0,...,srceHt-1; &nbsp;j=0,...,srceLen-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#block_equMT">MF_block_equMT</a>,&nbsp;&nbsp; <a href="#equMblock">MF_equMblock</a>,&nbsp;&nbsp; <a href="#submatrix_equM">MF_submatrix_equM</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="block_equMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_block_equMT</b></font>
</td><td width="33%"><font size="+1"><b>MD_block_equMT</b></font></td>
<td><font size="+1"><b>ME_block_equMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_block_equMT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_block_equMT</b></font></td>
<td><font size="+1"><b>MCE_block_equMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_block_equMT</b></font></td><td width="20%"><font size="+1"><b>MBI_block_equMT</b></font></td><td width="20%"><font size="+1"><b>MSI_block_equMT</b></font></td><td width="20%"><font size="+1"><b>MLI_block_equMT</b></font></td><td><font size="+1"><b>MQI_block_equMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_block_equMT</b></font></td><td width="20%"><font size="+1"><b>MUB_block_equMT</b></font></td><td width="20%"><font size="+1"><b>MUS_block_equMT</b></font></td><td width="20%"><font size="+1"><b>MUL_block_equMT</b></font></td><td><font size="+1"><b>MUQ_block_equMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Copy the transpose of a matrix into a "block" of another matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void  MF_block_equMT( fMatrix&nbsp;Dest, <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned destHt,   unsigned destLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;Srce,  ui&nbsp;srceHt,  ui&nbsp;srceLen&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::block_equMT( const&nbsp;ui&nbsp;firstRow,  const&nbsp;ui&nbsp;firstCol, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MSrce);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_block_equMT( MDest:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destHt, destLen, firstRow, firstCol:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSrce:fMatrix; srceHt, srceLen:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_block_equMT( fMatrix&nbsp;d_Dest, <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned destHt,   unsigned destLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;d_Srce,  ui&nbsp;srceHt,  ui&nbsp;srceLen&nbsp;);
<BR>void MFcu_block_equMT( fMatrix&nbsp;h_Dest, <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned destHt,   unsigned destLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;h_Srce,  ui&nbsp;srceHt,  ui&nbsp;srceLen&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_block_equMT( d_MDest:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destHt, destLen, firstRow, firstCol:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d_MSrce:fMatrix; srceHt, srceLen:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MF_block_equMT( h_MDest:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destHt, destLen, firstRow, firstCol:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h_MSrce:fMatrix; srceHt, srceLen:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MDest<sub>i+firstRow, j+firstCol</sub> = MSrce<sub>j, i</sub>,&nbsp;&nbsp;i=0,...,srceLen-1; &nbsp;j=0,...,srceHt-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#block_equM">MF_block_equM</a>,&nbsp;&nbsp; <a href="#equMblockT">MF_equMblockT</a>,&nbsp;&nbsp; <a href="#submatrix_equM">MF_submatrix_equM</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CDtoCF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>M_CDtoCF</b></font></td><td><font size="+1"><b>M_CDtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>M_CEtoCF</b></font></td><td><font size="+1"><b>M_CEtoCD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>M_CFtoCD</b></font></td><td><font size="+1"><b>M_CFtoCE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type conversions. See <I><a href="#FtoD">M_FtoD</a></I>.
</td></tr></table></td></tr></table>

<P>&nbsp;<P><a name="COGI"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_centerOfGravityInd</b></font></td><td width="33%"><font size="+1"><b>MD_centerOfGravityInd</b></font></td><td><font size="+1"><b>ME_centerOfGravityInd</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Center of gravity of a matrix with respect to the element indizes</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;
<BR>fComplex MF_centerOfGravityInd( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex&lt;T&gt; matrix&lt;T&gt;::centerOfGravityInd();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function MF_centerOfGravityInd( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;fComplex</font>
<BR>Alternative syntax for the complex types (obsolete, but still supported):<font face="courier new">
<BR>procedure MF_centerOfGravityInd( var COG:fComplex; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_centerOfGravityInd( fComplex&nbsp;*h_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cusdMF_centerOfGravityInd( fComplex&nbsp;*d_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>fComplex MFcu_centerOfGravityInd( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_centerOfGravityInd( var h_RetVal:fComplex; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_centerOfGravityInd( d_RetVal:PfComplex; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function MFcu_centerOfGravityInd( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;fComplex</font>
<BR>Alternative syntax:<font face="courier new">
<BR>procedure MFcu_centerOfGravityInd( var h_RetVal:fComplex; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The center of gravity of the matrix MA is determined. It is assumend that the values of MA represent point masses situated at the positions given by the element indices. The center of gravity is returned as a complex number whose real part contains the X coordinate and whose imaginary part contains the Y coordinate. Please note that this ordering of the coordinates is different from the ordering of matrix element indices (where the first index gives the i-th row, in other words, the Y coordinate). If all elements of MA are 0, there is no mass and, strictly speaking, no center of gravity. In this case, the center of gravity is assumed as the geometrical center of MA, i.e. as (&nbsp;(len-1)&nbsp;/&nbsp;2;&nbsp;(&nbsp;(ht-1)&nbsp;/&nbsp;2;&nbsp;).
<BR>In order to calculate the center of gravity of an MZ matrix over explicitly given X-Y coordinates, call <I><a href="#COGV">MF_centerOfGravityV</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>(Interpolated) coordinates of the center of gravity</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#COGV">MF_centerOfGravityV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="COGV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_centerOfGravityInd</b></font></td><td width="33%"><font size="+1"><b>MD_centerOfGravityInd</b></font></td><td><font size="+1"><b>ME_centerOfGravityInd</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Center of gravity of an MZ matrix over explicitly given X and Y axes</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;
<BR>fComplex MF_centerOfGravityV( fVector&nbsp;X, fVector&nbsp;Y, fMatrix&nbsp;MZ, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex&lt;T&gt; matrix&lt;T&gt;::centerOfGravityV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>procedure MF_centerOfGravityV( var COG:fComplex; X,&nbsp;Y:fVector; MZ:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_centerOfGravityV( fComplex&nbsp;*h_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, fMatrix&nbsp;d_MZ, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cusdMF_centerOfGravityV( fComplex&nbsp;*d_RetVal, fVector&nbsp;d_X, fVector&nbsp;d_Y, fMatrix&nbsp;d_MZ, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>fComplex MFcu_centerOfGravityV( fVector&nbsp;h_X, fVector&nbsp;h_Y, fMatrix&nbsp;h_MZ, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_centerOfGravityV( var h_RetVal:fComplex; d_X,&nbsp;d_Y:fVector; d_MZ:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_centerOfGravityV( d_RetVal:PfComplex; d_X,&nbsp;d_Y:fVector; d_MZ:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function MFcu_centerOfGravityV( h_X,&nbsp;h_Y:fVector; h_MZ:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;fComplex</font>
<BR>Alternative syntax:<font face="courier new">
<BR>procedure MFcu_centerOfGravityV( var h_RetVal:fComplex; h_X,&nbsp;h_Y:fVector; h_MZ:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The center of gravity of the matrix MZ is determined. It is assumend that the values of MZ represent point masses situated at the coordinates specified by the vectors X and Y. The center of gravity is returned as a complex number whose real part contains the X coordinate and whose imaginary part contains the Y coordinate. Please note that this ordering of the coordinates is different from the ordering of matrix element indices (where the first index gives the i-th row, in other words, the Y coordinate). If all elements of MA are 0, there is no mass and, strictly speaking, no center of gravity. In this case, the center of gravity is assumed as the geometrical center of MA, i.e. as (&nbsp;(X[size-1)]&nbsp;-&nbsp;X[0])&nbsp;/&nbsp;2;&nbsp;(X[size-1)]&nbsp;-&nbsp;X[0])&nbsp;/&nbsp;2;&nbsp;).
<BR>In order to calculate the center of gravity of an MZ matrix over the element indices, call <I><a href="#COGI">MF_centerOfGravityInd</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>(Interpolated) coordinates of the center of gravity</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#COGI">MF_centerOfGravityInd</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_addC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_addC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_addC</b></font></td>
<td><font size="+1"><b>ME_Col_addC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_addC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_addC</b></font></td>
<td><font size="+1"><b>MCE_Col_addC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>add a constant to all elements of one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_addC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_addC( const&nbsp;ui&nbsp;iCol, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_addC( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_addC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);
<BR>int cusdMF_Col_addC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Col_addC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_addC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Col_addC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_addC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> += C,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_subC">MF_Col_subC</a>,&nbsp;&nbsp; <a href="#Row_addC">MF_Row_addC</a>,&nbsp;&nbsp; <a href="#Col_addV">MF_Col_addV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_addV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_addV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_addV</b></font></td>
<td><font size="+1"><b>ME_Col_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_addV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_addV</b></font></td>
<td><font size="+1"><b>MCE_Col_addV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>add a vector to a column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_addV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_addV( const&nbsp;ui&nbsp;iCol, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_addV( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_addV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Col_addV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_addV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_addV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> += X<sub>i</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_subV">MF_Col_subV</a>,&nbsp;&nbsp; <a href="#Row_addV">MF_Row_addV</a>,&nbsp;&nbsp; <a href="#Col_addC">MF_Col_addC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_conj"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_conj</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_conj</b></font></td>
<td><font size="+1"><b>MCE_Col_conj</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>complex conjugate of all elements of one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_Col_conj( cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;complex&lt;T&gt;&gt;::Col_conj( const&nbsp;ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_Col_conj( MA:cfMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Col_conj( cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);
<BR>void MCFcu_Col_conj( cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Col_conj( d_MA:cfMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Col_conj( h_MA:cfMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = MA*<sub>i,iCol</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_neg">MF_Col_neg</a>, &nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_delete"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_delete</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_delete</b></font></td>
<td><font size="+1"><b>ME_Col_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_delete</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_delete</b></font></td>
<td><font size="+1"><b>MCE_Col_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Col_delete</b></font></td><td width="20%"><font size="+1"><b>MBI_Col_delete</b></font></td><td width="20%"><font size="+1"><b>MSI_Col_delete</b></font></td><td width="20%"><font size="+1"><b>MLI_Col_delete</b></font></td><td><font size="+1"><b>MQI_Col_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Col_delete</b></font></td><td width="20%"><font size="+1"><b>MUB_Col_delete</b></font></td><td width="20%"><font size="+1"><b>MUS_Col_delete</b></font></td><td width="20%"><font size="+1"><b>MUL_Col_delete</b></font></td><td><font size="+1"><b>MUQ_Col_delete</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>delete one column from a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_delete( fMatrix&nbsp;MB, fMatrix&nbsp;MA, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_delete( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;ui&nbsp;iCol);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_delete( MB,&nbsp;MA:fMatrix; htA,&nbsp;lenA,&nbsp;iCol:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_delete( fMatrix&nbsp;d_MB, fMatrix&nbsp;d_MA, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;iCol&nbsp;);
<BR>void MFcu_Col_delete( fMatrix&nbsp;h_MB, fMatrix&nbsp;h_MA, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_delete( d_MB,&nbsp;d_MA:fMatrix; htA,&nbsp;lenA,&nbsp;iCol:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_delete( h_MB,&nbsp;h_MA:fMatrix; htA,&nbsp;lenA,&nbsp;iCol:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>i,j</sub> = MA<sub>i,j</sub>,&nbsp;&nbsp;i=0,..htA-1,&nbsp;&nbsp;j=0,..iCol-1<BR>
MB<sub>i,j</sub> = MA<sub>i,j+1</sub>,&nbsp;&nbsp;i=0,...,htA-1,&nbsp;&nbsp;j=iCol,...,lenA-2<BR>
The parameters htA and lenA refer to the <U>input</U> matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_insert">MF_Col_insert</a>,&nbsp;&nbsp; <a href="#Row_delete">MF_Row_delete</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#delete">VF_delete</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_divC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_divC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_divC</b></font></td>
<td><font size="+1"><b>ME_Col_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_divC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_divC</b></font></td>
<td><font size="+1"><b>MCE_Col_divC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>divide all elements of one column by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_divC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_divC( const&nbsp;ui&nbsp;iCol, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_divC( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_divC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);
<BR>int cusdMF_Col_divC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Col_divC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_divC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Col_divC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_divC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> /= C,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divrC">MF_Col_divrC</a>,&nbsp;&nbsp; <a href="#Row_divC">MF_Row_divC</a>,&nbsp;&nbsp; <a href="#Col_mulC">MF_Col_mulC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_divrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_divrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_divrC</b></font></td>
<td><font size="+1"><b>ME_Col_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_divrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_divrC</b></font></td>
<td><font size="+1"><b>MCE_Col_divrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse division: divide a constant by a column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_divrC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_divrC( const&nbsp;ui&nbsp;iCol, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_divrC( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_divrC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);
<BR>int cusdMF_Col_divrC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Col_divrC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_divrC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Col_divrC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_divrC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = C / MA<sub>i,iCol</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divC">MF_Col_divC</a>,&nbsp;&nbsp; <a href="#Row_divrC">MF_Row_divrC</a>,&nbsp;&nbsp; <a href="#Col_divV">MF_Col_divV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_divrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_divrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_divrV</b></font></td>
<td><font size="+1"><b>ME_Col_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_divrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_divrV</b></font></td>
<td><font size="+1"><b>MCE_Col_divrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse division: divide a vector by a column (element-wise)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_divrV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_divrV( const&nbsp;ui&nbsp;iCol, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_divrV( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_divrV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Col_divrV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_divrV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_divrV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = X<sub>i</sub> / MA<sub>i,iCol</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divV">MF_Col_divV</a>,&nbsp;&nbsp; <a href="#Row_divrV">MF_Row_divrV</a>,&nbsp;&nbsp; <a href="#Col_divrC">MF_Col_divrC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_divV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_divV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_divV</b></font></td>
<td><font size="+1"><b>ME_Col_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_divV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_divV</b></font></td>
<td><font size="+1"><b>MCE_Col_divV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise division of a column by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_divV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_divV( const&nbsp;ui&nbsp;iCol, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_divV( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_divV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Col_divV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_divV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_divV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> /= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divrV">MF_Col_divrV</a>,&nbsp;&nbsp; <a href="#Row_divV">MF_Row_divV</a>,&nbsp;&nbsp; <a href="#Col_divC">MF_Col_divC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_equ0"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_equ0</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_equ0</b></font></td>
<td><font size="+1"><b>ME_Col_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_equ0</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_equ0</b></font></td>
<td><font size="+1"><b>MCE_Col_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Col_equ0</b></font></td><td width="20%"><font size="+1"><b>MBI_Col_equ0</b></font></td><td width="20%"><font size="+1"><b>MSI_Col_equ0</b></font></td><td width="20%"><font size="+1"><b>MLI_Col_equ0</b></font></td><td><font size="+1"><b>MQI_Col_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Col_equ0</b></font></td><td width="20%"><font size="+1"><b>MUB_Col_equ0</b></font></td><td width="20%"><font size="+1"><b>MUS_Col_equ0</b></font></td><td width="20%"><font size="+1"><b>MUL_Col_equ0</b></font></td><td><font size="+1"><b>MUQ_Col_equ0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>set all elements of one column to zero</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_equ0( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_equ0( const&nbsp;ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_equ0( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_equ0( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);
<BR>void MFcu_Col_equ0( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_equ0( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_equ0( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = 0,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equC">MF_Col_equC</a>,&nbsp;&nbsp; <a href="#Row_equ0">MF_Row_equ0</a>,&nbsp;&nbsp; <a href="#Dia_equ0">MF_Dia_equ0</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_equC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_equC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_equC</b></font></td>
<td><font size="+1"><b>ME_Col_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_equC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_equC</b></font></td>
<td><font size="+1"><b>MCE_Col_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Col_equC</b></font></td><td width="20%"><font size="+1"><b>MBI_Col_equC</b></font></td><td width="20%"><font size="+1"><b>MSI_Col_equC</b></font></td><td width="20%"><font size="+1"><b>MLI_Col_equC</b></font></td><td><font size="+1"><b>MQI_Col_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Col_equC</b></font></td><td width="20%"><font size="+1"><b>MUB_Col_equC</b></font></td><td width="20%"><font size="+1"><b>MUS_Col_equC</b></font></td><td width="20%"><font size="+1"><b>MUL_Col_equC</b></font></td><td><font size="+1"><b>MUQ_Col_equC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize all elements of one column with a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_equC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_equC( const&nbsp;ui&nbsp;iCol, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_equC( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_equC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);
<BR>int cusdMF_Col_equC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Col_equC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_equC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Col_equC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_equC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = C,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equV">MF_Col_equV</a>,&nbsp;&nbsp; <a href="#Row_equC">MF_Row_equC</a>,&nbsp;&nbsp; <a href="#Dia_equC">MF_Dia_equC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_equV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_equV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_equV</b></font></td>
<td><font size="+1"><b>ME_Col_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_equV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_equV</b></font></td>
<td><font size="+1"><b>MCE_Col_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Col_equV</b></font></td><td width="20%"><font size="+1"><b>MBI_Col_equV</b></font></td><td width="20%"><font size="+1"><b>MSI_Col_equV</b></font></td><td width="20%"><font size="+1"><b>MLI_Col_equV</b></font></td><td><font size="+1"><b>MQI_Col_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Col_equV</b></font></td><td width="20%"><font size="+1"><b>MUB_Col_equV</b></font></td><td width="20%"><font size="+1"><b>MUS_Col_equV</b></font></td><td width="20%"><font size="+1"><b>MUL_Col_equV</b></font></td><td><font size="+1"><b>MUQ_Col_equV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy a vector into one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_equV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_equV( const&nbsp;ui&nbsp;iCol, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_equV( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_equV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Col_equV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_equV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_equV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = X<sub>i</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equ0">MF_Col_equ0</a>,&nbsp;&nbsp; <a href="#Row_equV">MF_Row_equV</a>,&nbsp;&nbsp; <a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_extract"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_extract</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_extract</b></font></td>
<td><font size="+1"><b>ME_Col_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_extract</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_extract</b></font></td>
<td><font size="+1"><b>MCE_Col_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Col_extract</b></font></td><td width="20%"><font size="+1"><b>MBI_Col_extract</b></font></td><td width="20%"><font size="+1"><b>MSI_Col_extract</b></font></td><td width="20%"><font size="+1"><b>MLI_Col_extract</b></font></td><td><font size="+1"><b>MQI_Col_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Col_extract</b></font></td><td width="20%"><font size="+1"><b>MUB_Col_extract</b></font></td><td width="20%"><font size="+1"><b>MUS_Col_extract</b></font></td><td width="20%"><font size="+1"><b>MUL_Col_extract</b></font></td><td><font size="+1"><b>MUQ_Col_extract</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy one column into a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_extract( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Col_extract( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_extract( Y:fVector; MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_extract( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);
<BR>void MFcu_Col_extract( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_extract( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_extract( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = MA<sub>i,iCol</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_extract">MF_Row_extract</a>,&nbsp;&nbsp; <a href="#Dia_extract">MF_Dia_extract</a>,&nbsp;&nbsp; <a href="#Col_equV">MF_Col_equV</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_insert"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_insert</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_insert</b></font></td>
<td><font size="+1"><b>ME_Col_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_insert</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_insert</b></font></td>
<td><font size="+1"><b>MCE_Col_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Col_insert</b></font></td><td width="20%"><font size="+1"><b>MBI_Col_insert</b></font></td><td width="20%"><font size="+1"><b>MSI_Col_insert</b></font></td><td width="20%"><font size="+1"><b>MLI_Col_insert</b></font></td><td><font size="+1"><b>MQI_Col_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Col_insert</b></font></td><td width="20%"><font size="+1"><b>MUB_Col_insert</b></font></td><td width="20%"><font size="+1"><b>MUS_Col_insert</b></font></td><td width="20%"><font size="+1"><b>MUL_Col_insert</b></font></td><td><font size="+1"><b>MUQ_Col_insert</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>augment a matrix by insertion of one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_insert( fMatrix&nbsp;MB, fMatrix&nbsp;MA, ui&nbsp;htB, ui&nbsp;lenB, ui&nbsp;iCol, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_insert( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;ui&nbsp;iCol, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_insert( MB,&nbsp;MA:fMatrix; htB,&nbsp;lenB,&nbsp;iCol:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_insert( fMatrix&nbsp;d_MB, fMatrix&nbsp;d_MA, ui&nbsp;htB, ui&nbsp;lenB, ui&nbsp;iCol, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Col_insert( fMatrix&nbsp;h_MB, fMatrix&nbsp;h_MA, ui&nbsp;htB, ui&nbsp;lenB, ui&nbsp;iCol, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_insert( d_MB,&nbsp;d_MA:fMatrix; htB,&nbsp;lenB,&nbsp;iCol:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_insert( h_MB,&nbsp;h_MA:fMatrix; htB,&nbsp;lenB,&nbsp;iCol:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>i,j</sub> = MA<sub>i,j</sub>,&nbsp;&nbsp;i=0,...,htB-1,&nbsp;&nbsp;j=0,...,iCol-1<BR>
MB<sub>i,iCol</sub> = X<sub>i</sub>,&nbsp;&nbsp;i=0,...,htB-1<BR>
MB<sub>i,j</sub> = MA<sub>i,j-1</sub>,&nbsp;&nbsp;i=0,...,htB-1,&nbsp;&nbsp;j=iCol,...,lenB-1<BR>
The parameters htB and lenB refer to the <U>output</U> matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_delete">MF_Col_delete</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_mulC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_mulC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_mulC</b></font></td>
<td><font size="+1"><b>ME_Col_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_mulC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_mulC</b></font></td>
<td><font size="+1"><b>MCE_Col_mulC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply all elements of one column by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_mulC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_mulC( const&nbsp;ui&nbsp;iCol, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_mulC( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_mulC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);
<BR>int cusdMF_Col_mulC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Col_mulC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_mulC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Col_mulC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_mulC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> *= C,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divC">MF_Col_divC</a>,&nbsp;&nbsp; <a href="#Row_divC">MF_Row_divC</a>,&nbsp;&nbsp; <a href="#Col_mulV">MF_Col_mulV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_mulV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_mulV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_mulV</b></font></td>
<td><font size="+1"><b>ME_Col_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_mulV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_mulV</b></font></td>
<td><font size="+1"><b>MCE_Col_mulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise multiplication of a column by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_mulV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_mulV( const&nbsp;ui&nbsp;iCol, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_mulV( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_mulV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Col_mulV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_mulV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_mulV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> *= X<sub>i</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divV">MF_Col_divV</a>,&nbsp;&nbsp; <a href="#Row_divV">MF_Row_divV</a>,&nbsp;&nbsp; <a href="#Col_mulC">MF_Col_mulC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_neg"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_neg</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_neg</b></font></td>
<td><font size="+1"><b>ME_Col_neg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_neg</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_neg</b></font></td>
<td><font size="+1"><b>MCE_Col_neg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply all elements of one column by -1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_neg( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_neg( const&nbsp;ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_neg( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_neg( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);
<BR>void MFcu_Col_neg( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_neg( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_neg( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> *= -1,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_mulC">MF_Col_mulC</a>,&nbsp;&nbsp; <a href="#Row_neg">MF_Row_neg</a>,&nbsp;&nbsp; <a href="#Col_conj">MCF_Col_conj</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_subC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_subC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_subC</b></font></td>
<td><font size="+1"><b>ME_Col_subC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_subC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_subC</b></font></td>
<td><font size="+1"><b>MCE_Col_subC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract a constant from all elements of one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_subC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_subC( const&nbsp;ui&nbsp;iCol, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_subC( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_subC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);
<BR>int cusdMF_Col_subC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Col_subC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_subC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Col_subC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_subC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> -= C,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_addC">MF_Col_addC</a>,&nbsp;&nbsp; <a href="#Row_subC">MF_Row_subC</a>,&nbsp;&nbsp; <a href="#Col_subV">MF_Col_subV</a>,&nbsp;&nbsp; <a href="#Col_subrC">MF_Col_subrC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_subrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_subrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_subrC</b></font></td>
<td><font size="+1"><b>ME_Col_subrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_subrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_subrC</b></font></td>
<td><font size="+1"><b>MCE_Col_subrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: a constant minus one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_subrC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_subrC( const&nbsp;ui&nbsp;iCol, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_subrC( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_subrC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);
<BR>int cusdMF_Col_subrC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Col_subrC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_subrC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Col_subrC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_subrC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = C - MA<sub>i,iCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_addC">MF_Col_addC</a>,&nbsp;&nbsp; <a href="#Row_subC">MF_Row_subC</a>,&nbsp;&nbsp; <a href="#Col_subrV">MF_Col_subrV</a>,&nbsp;&nbsp; <a href="#Col_subC">MF_Col_subC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_subrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_subrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_subrV</b></font></td>
<td><font size="+1"><b>ME_Col_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_subrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_subrV</b></font></td>
<td><font size="+1"><b>MCE_Col_subrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: a vector minus one column (element-wise)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_subrV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_subrV( const&nbsp;ui&nbsp;iCol, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_subrV( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_subrV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Col_subrV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_subrV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_subrV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = X<sub>i</sub> - MA<sub>i,iCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_subV">MF_Col_subV</a>,&nbsp;&nbsp; <a href="#Row_subrV">MF_Row_subrV</a>,&nbsp;&nbsp; <a href="#Col_subrC">MF_Col_subrC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_subV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_subV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_subV</b></font></td>
<td><font size="+1"><b>ME_Col_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_subV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_subV</b></font></td>
<td><font size="+1"><b>MCE_Col_subV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract a vector from a column (element-wise)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_subV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Col_subV( const&nbsp;ui&nbsp;iCol, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_subV( MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Col_subV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Col_subV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iCol, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Col_subV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Col_subV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iCol:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> -= X<sub>i</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_subC">MF_Col_subC</a>,&nbsp;&nbsp; <a href="#Row_subV">MF_Row_subV</a>,&nbsp;&nbsp; <a href="#Col_subrC">MF_Col_subrC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_absmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_absmax</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_absmax</b></font></td>
<td><font size="+1"><b>ME_Cols_absmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_absmax</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_absmax</b></font></td>
<td><font size="+1"><b>MCE_Cols_absmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the absolute maxima of all individual columns in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_absmax( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MCF_Cols_absmax( fVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Cols_absmax( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_absmax( Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<BR>
procedure MCF_Cols_absmax( Y:fVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_absmax( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMCF_Cols_absmax( fVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;)
<BR>void MFcu_Cols_absmax( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Cols_absmax( fVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_absmax( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMCF_Cols_absmax( d_Y:fVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_absmax( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);
<BR>procedure MCFcu_Cols_absmax( h_Y:fVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum absolute value of each column <I>j</I> is stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_max">MF_Cols_max</a>,&nbsp;&nbsp; <a href="#Cols_absmin">MF_Cols_absmin</a>,&nbsp;&nbsp; <a href="#Rows_absmax">MF_Rows_absmax</a>,&nbsp;&nbsp; <a href="#Dia_absmax">MF_Dia_absmax</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_absmaxReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_absmaxReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Cols_absmaxReIm</b></font></td>
<td><font size="+1"><b>MCE_Cols_absmaxReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the largest absolute values of the real and imaginary parts of each column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_Cols_absmaxReIm( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt;&nbsp;&gt;::Cols_absmaxReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_Cols_absmaxReIm( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Cols_absmaxReIm( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Cols_absmaxReIm( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Cols_absmaxReIm( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Cols_absmaxReIm( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum absolute values of the real and imaginary parts of each column <I>j</I> are combined into the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmax">MCF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Cols_minReIm">MCF_Cols_minReIm</a>,&nbsp;&nbsp; <a href="#Rows_absmaxReIm">MCF_Rows_absmaxReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_absmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_absmin</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_absmin</b></font></td>
<td><font size="+1"><b>ME_Cols_absmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_absmin</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_absmin</b></font></td>
<td><font size="+1"><b>MCE_Cols_absmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the absolute minima of all individual columns in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_absmin( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MCF_Cols_absmin( fVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Cols_absmin( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);<BR>
void vector&lt;T&gt;::Cols_absmin( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_absmin( Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<BR>
procedure MCF_Cols_absmin( Y:fVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_absmin( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMCF_Cols_absmin( fVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;)
<BR>void MFcu_Cols_absmin( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Cols_absmin( fVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_absmin( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMCF_Cols_absmin( d_Y:fVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_absmin( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);
<BR>procedure MCFcu_Cols_absmin( h_Y:fVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum absolute value of each column <I>j</I> is stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_min">MF_Cols_min</a>,&nbsp;&nbsp; <a href="#Cols_absmax">MF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Rows_absmin">MF_Rows_absmin</a>,&nbsp;&nbsp; <a href="#Dia_absmin">MF_Dia_absmin</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_absminReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_absminReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Cols_absminReIm</b></font></td>
<td><font size="+1"><b>MCE_Cols_absminReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the smallest absolute values of the real and imaginary parts of each column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_Cols_absminReIm( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt;&nbsp;&gt;::Cols_absminReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_Cols_absminReIm( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Cols_absminReIm( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Cols_absminReIm( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Cols_absminReIm( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Cols_absminReIm( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum absolute values of the real and imaginary parts of each column <I>j</I> are combined into the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmin">MCF_Cols_absmin</a>,&nbsp;&nbsp; <a href="#Cols_minReIm">MCF_Cols_minReIm</a>,&nbsp;&nbsp; <a href="#Rows_absminReIm">MCF_Rows_absminReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_add"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_add</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_add</b></font></td>
<td><font size="+1"><b>ME_Cols_add</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_add</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_add</b></font></td>
<td><font size="+1"><b>MCE_Cols_add</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one column the sum of itself and another column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_add( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, unsigned&nbsp;sourceCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_add( const&nbsp;unsigned&nbsp;destCol, const&nbsp;unsigned&nbsp;sourceCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_add( MA:fMatrix; ht,&nbsp;len,&nbsp;destCol,&nbsp;sourceCol:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_add( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, unsigned&nbsp;sourceCol&nbsp;);
<BR>void MFcu_Cols_add( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, unsigned&nbsp;sourceCol&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_add( d_MA:fMatrix; ht,&nbsp;len,&nbsp;destCol,&nbsp;sourceCol:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_add( h_MA:fMatrix; ht,&nbsp;len,&nbsp;destCol,&nbsp;sourceCol:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,destCol</sub> += MA<sub>i,sourceCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_sub">MF_Cols_sub</a>,&nbsp;&nbsp; <a href="#Cols_Cadd">MF_Cols_Cadd</a>,&nbsp;&nbsp; <a href="#Cols_lincomb">MF_Cols_lincomb</a>,&nbsp;&nbsp; <a href="#chap8">chapter&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_cabsmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_cabsmax</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Cols_cabsmax</b></font></td>
<td><font size="+1"><b>MCE_Cols_cabsmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex numbers of largest magnitude along columns and store them in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_Cols_cabsmax( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt; T&gt;::Cols_cabsmax( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_Cols_cabsmax( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Cols_cabsmax( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Cols_cabsmax( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Cols_cabsmax( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Cols_cabsmax( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Within each column j of MA, the complex number of largest magnitude, sqrt(Re<sup>2</sup>+Im<sup>2</sup>),  is found and stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmax">MCF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Cols_cabsmin">MCF_Cols_cabsmin</a>,&nbsp;&nbsp; <a href="#Cols_sabsmax">MCF_Cols_sabsmax</a>,&nbsp;&nbsp; <a href="#Rows_cabsmax">MCF_Rows_cabsmax</a>,&nbsp;&nbsp; <a href="#Dia_cabsmax">MCF_Dia_cabsmax</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_cabsmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_cabsmin</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Cols_cabsmin</b></font></td>
<td><font size="+1"><b>MCE_Cols_cabsmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex numbers of smallest magnitude along columns and store them in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_Cols_cabsmin( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt; T&gt;::Cols_cabsmin( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_Cols_cabsmin( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Cols_cabsmin( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Cols_cabsmin( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Cols_cabsmin( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Cols_cabsmin( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Within each column j of MA, the complex number of smallest magnitude, sqrt(Re<sup>2</sup>+Im<sup>2</sup>),  is found and stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmin">MCF_Cols_absmin</a>,&nbsp;&nbsp; <a href="#Cols_cabsmax">MCF_Cols_cabsmax</a>,&nbsp;&nbsp; <a href="#Cols_sabsmin">MCF_Cols_sabsmin</a>,&nbsp;&nbsp; <a href="#Rows_cabsmin">MCF_Rows_cabsmin</a>,&nbsp;&nbsp; <a href="#Dia_cabsmin">MCF_Dia_cabsmin</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_Cadd"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_Cadd</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_Cadd</b></font></td>
<td><font size="+1"><b>ME_Cols_Cadd</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_Cadd</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_Cadd</b></font></td>
<td><font size="+1"><b>MCE_Cols_Cadd</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one column the sum of itself and another column, scaled by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_Cadd( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned destCol, unsigned sourceCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_Cadd( const&nbsp;unsigned&nbsp;destCol, const&nbsp;unsigned&nbsp;sourceCol, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_Cadd( MA:fMatrix; ht,&nbsp;len,&nbsp;destCol, sourceCol:UIntSize;
C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_Cadd( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, unsigned&nbsp;sourceCol, float&nbsp;C&nbsp;);
<BR>int cusdMF_Cols_Cadd( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, unsigned&nbsp;sourceCol, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Cols_Cadd( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, unsigned&nbsp;sourceCol, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_Cadd( d_MA:fMatrix; ht,&nbsp;len,&nbsp;destCol,&nbsp;sourceCol:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Cols_Cadd( d_MA:fMatrix; ht,&nbsp;len,&nbsp;destCol,&nbsp;sourceCol:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_Cadd( h_MA:fMatrix; ht,&nbsp;len,&nbsp;destCol,&nbsp;sourceCol:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,destCol</sub> += C *&nbsp;MA<sub>i,sourceCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_add">MF_Cols_add</a>,&nbsp;&nbsp; <a href="#Cols_lincomb">MF_Cols_lincomb</a>,&nbsp;&nbsp; <a href="#chap8">chapter&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Cols_distribution"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_distribution</b></font></td><td width="33%"><font size="+1"><b>MD_Cols_distribution</b></font></td><td><font size="+1"><b>ME_Cols_distribution</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Cols_distribution</b></font></td><td width="20%"><font size="+1"><b>MBI_Cols_distribution</b></font></td><td width="20%"><font size="+1"><b>MSI_Cols_distribution</b></font></td><td width="20%"><font size="+1"><b>MLI_Cols_distribution</b></font></td><td><font size="+1"><b>MQI_Cols_distribution</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Cols_distribution</b></font></td><td width="20%"><font size="+1"><b>MUB_Cols_distribution</b></font></td><td width="20%"><font size="+1"><b>MUS_Cols_distribution</b></font></td><td width="20%"><font size="+1"><b>MUL_Cols_distribution</b></font></td><td><font size="+1"><b>MUQ_Cols_distribution</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Histogram or Distribution function along columns</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;
<BR>void MF_Cols_distribution( uiMatrix&nbsp;MAbund, fVector&nbsp;Limits, ui&nbsp;nbins, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;mode&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void matrix&lt;ui&gt;::Cols_distribution( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Limits, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, int&nbsp;mode=0&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>procedure MF_Cols_distribution( MAbund:uiMatrix; Limits:fVector; nbins:UIntSize; MA:fMatrix; ht,&nbsp;len:UIntSize; mode:Integer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_distribution( uiMatrix&nbsp;d_MAbund, fVector&nbsp;d_Limits, ui&nbsp;nbins, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;mode&nbsp;);
<BR>void MFcu_Cols_distribution( uiMatrix&nbsp;h_MAbund, fVector&nbsp;h_Limits, ui&nbsp;nbins, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;mode&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_distribution( d_MAbund:uiMatrix; d_Limits:fVector; nbins:UIntSize; d_MA:fMatrix; ht,&nbsp;len:UIntSize; mode:Integer&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_distribution( h_MAbund:uiMatrix; h_Limits:fVector; nbins:UIntSize; h_MA:fMatrix; ht,&nbsp;len:UIntSize; mode:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each column of MA, this function counts the number of elements falling into each of the intervals defined by Limits. The abundances thus determined are stored in the corresponding columns of MAbund.
<BR>nbins is the number of elements of Limits, i.e. the number of intervals. The size of MAbund is nbins*len.
<P>Limits must be in ascending order. The spacing between the elements of Limits need not necessarily be constant.
<P>The parameter mode specifies how to interpret the values given in Limits.
<BR>mode &gt; 0: Limits contains the upper limits of the intervals
<BR>mode &lt; 0: Limits contains the lower limits of the intervals
<BR>mode = 0: Limits contains the mid-points of the intervals. An element of MA belongs to the Limits value closest to it. In case of exactly equal distances, the interval with the lower index is chosen.
<BR>The interval defined by Limits<sub>0</sub> extends down to -HUGE_VAL, the interval defined by Limits<sub>nbins-1</sub> reaches up to +HUGE_VAL.
<P>In contrast to <I><a href="FUNCREF.HTM#distribution">VF_distribution</a></I>, elements outside the intervals are not taken into account; their number is not returned.
<P>This function may be used for batch processing of several vectors of equal size. To this end, the vectors have to be copied into the columns of a matrix.</P>
<P>At present, these functions are available only in the 64-bit libraries.</P>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="FUNCREF.HTM#distribution">VF_distribution</a> &nbsp;&nbsp;<a href="#Rows_distribution">MF_Rows_distribution</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_exchange"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_exchange</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_exchange</b></font></td>
<td><font size="+1"><b>ME_Cols_exchange</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_exchange</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_exchange</b></font></td>
<td><font size="+1"><b>MCE_Cols_exchange</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Cols_exchange</b></font></td><td width="20%"><font size="+1"><b>MBI_Cols_exchange</b></font></td><td width="20%"><font size="+1"><b>MSI_Cols_exchange</b></font></td><td width="20%"><font size="+1"><b>MLI_Cols_exchange</b></font></td><td><font size="+1"><b>MQI_Cols_exchange</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Cols_exchange</b></font></td><td width="20%"><font size="+1"><b>MUB_Cols_exchange</b></font></td><td width="20%"><font size="+1"><b>MUS_Cols_exchange</b></font></td><td width="20%"><font size="+1"><b>MUL_Cols_exchange</b></font></td><td><font size="+1"><b>MUQ_Cols_exchange</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>exchange two columns</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_exchange( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;i1, unsigned&nbsp;i2&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_exchange( const&nbsp;unsigned&nbsp;i1, const&nbsp;unsigned&nbsp;i2&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_exchange( MA:fMatrix; ht,&nbsp;len,&nbsp;i1,&nbsp;i2:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_exchange( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;i1, unsigned&nbsp;i2&nbsp;);
<BR>void MFcu_Cols_exchange( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;i1, unsigned&nbsp;i2&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_exchange( d_MA:fMatrix; ht,&nbsp;len,&nbsp;i1,&nbsp;i2:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_exchange( h_MA:fMatrix; ht,&nbsp;len,&nbsp;i1,&nbsp;i2:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The elements of the columns i1 and i2 are exchanged.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_exchange">MF_Rows_exchange</a>,&nbsp;&nbsp; <a href="#chap8">chapter&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_FFT"></a><a name="Cols_FFTtoC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MD_Cols_FFT</b></font></td>
<td><font size="+1"><b>ME_Cols_FFT</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>MFb_Cols_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MDb_Cols_FFT</b></font></td>
<td><font size="+1"><b>MEb_Cols_FFT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_FFTtoC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_FFTtoC</b></font></td>
<td><font size="+1"><b>ME_Cols_FFTtoC</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>MFb_Cols_FFTtoC</b></font>
</td><td width="33%"><font size="+1"><b>MDb_Cols_FFTtoC</b></font></td>
<td><font size="+1"><b>MEb_Cols_FFTtoC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_FFT</b></font></td>
<td><font size="+1"><b>MCE_Cols_FFT</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>MCFb_Cols_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MCDb_Cols_FFT</b></font></td>
<td><font size="+1"><b>MCEb_Cols_FFT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Fast Fourier Transform along the columns</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_FFT( fMatrix&nbsp;Y, fMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MCF_Cols_FFT( cfMatrix&nbsp;Y, cfMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MF_Cols_FFTtoC( cfMatrix&nbsp;Y, fMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MFb_Cols_FFT( fMatrix&nbsp;Y, fMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir, fVector&nbsp;Buf&nbsp;);<BR>
void MCFb_Cols_FFT( cfMatrix&nbsp;Y, cfMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir, cfVector&nbsp;Buf&nbsp;);<BR>
void MFb_Cols_FFTtoC( cfMatrix&nbsp;Y, fMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len, cfVector&nbsp;Buf&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_FFT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, int&nbsp;dir&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::FFT( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MX, int&nbsp;dir&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::FFTtoC( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX&nbsp;);<br>
void matrix&lt;T&gt;::b_Cols_FFT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, int&nbsp;dir, vector&lt;T&gt;&amp;&nbsp;Buf&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::b_Cols_FFT( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&nbsp;MX, int&nbsp;dir, vector&lt;complex&lt;T&gt;&nbsp;&gt;&amp;Buf&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::b_Cols_FFTtoC( const&nbsp;matrix&lt;T&gt;&nbsp;MX, vector&lt;complex&lt;T&gt;&gt;&amp;Buf&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_FFT( MY,&nbsp;MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MCF_Cols_FFT( MY,&nbsp;MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MF_Cols_FFTtoC( MY:cfMatrix; MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<br>
procedure MFb_Cols_FFT( MY,&nbsp;MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer; Buf:fVector&nbsp;);<BR>
procedure MCFb_Cols_FFT( MY,&nbsp;MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer; Buf:cfVector&nbsp;);<BR>
procedure MFb_Cols_FFTtoC( MY:cfMatrix; MX:fMatrix; ht,&nbsp;len:UIntSize; Buf:cfVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMF_Cols_FFT( fMatrix&nbsp;d_Y, fMatrix&nbsp;d_X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
int cuda MCF_Cols_FFT( cfMatrix&nbsp;d_Y, cfMatrix&nbsp;d_X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
int cudaMF_Cols_FFTtoC( cfMatrix&nbsp;d_Y, fMatrix&nbsp;d_X, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MFcu_Cols_FFT( fMatrix&nbsp;h_Y, fMatrix&nbsp;h_X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MCFcu_Cols_FFT( cfMatrix&nbsp;h_Y, cfMatrix&nbsp;h_X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MFcu_Cols_FFTtoC( cfMatrix&nbsp;h_Y, fMatrix&nbsp;h_X, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd, MCFstd;
<BR>function cudaMF_Cols_FFT( d_MY,&nbsp;d_MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;):&nbsp;IntBool;<BR>
function cudaMCF_Cols_FFT( d_MY,&nbsp;d_MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;):&nbsp;IntBool;<BR>
function cudaMF_Cols_FFTtoC( d_MY:cfMatrix; d_MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_FFT( h_MY,&nbsp;h_MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MCFcu_Cols_FFT( h_MY,&nbsp;h_MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MFcu_Cols_FFTtoC( h_MY:cfMatrix; h_MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The one-dimensional Fourier transform of all columns of MX is calculated and stored in the corresponding columns of MY. The forward transform is obtained by setting dir = 1, the inverse (or backward) transform by setting dir = -1. By convention, the inverse transform involves scaling the result by the factor <I>1.0/ht</I> (so as to ensure that the result of one forward and one backward transform yields &#x2013; within round-off error &#x2013; the original matrix). Since it is sometimes desirable to skip this implicit scaling, <I>MF_Cols_FFT</I> offers the possibility to do so: specify dir = -2 in this case.
<BR>A Fast Fourier Transform algorithm is used that requires <i>ht</i> to be a power of 2. &nbsp;<i>len</i>&nbsp;may be set arbitrarily, but the function will be most efficient if <i>len</i> is a multiple of 4.
<BR>Complex version: Both MX and the output MY are complex matrices.
<BR>Real-to-complex version: The input matrix MX is real. The output matrix MY is complex. As this function can only perform a forward transform, no argument &quot;dir&quot; is needed.
<BR>Purely real version: For the forward transform, MX is a real matrix. The output MY is also defined as fMatrix, although it consists of complex numbers. The reason is that the symmetry properties of FFT allow to store the result in a packed format, fitting into the same memory space as the input matrix. The order of each column of MY is indicated in the following table. U means the uncompressed result, N is <i>ht</i>.
<table border width="100%">
<tr valign="TOP"><td>Y<sub>0, i</sub></td><td>U<sub>0, i</sub>.Re</td></tr>
<tr valign="TOP"><td>Y<sub>1, i</sub></td><td>U<sub>N/2, i</sub>.Re</td></tr>
<tr valign="TOP"><td>Y<sub>2, i</sub></td><td>U<sub>1, i</sub>.Re</td></tr>
<tr valign="TOP"><td>Y<sub>3, i</sub></td><td>U<sub>1, i</sub>.Im</td></tr>
<tr valign="TOP"><td>&nbsp;&nbsp;.....&nbsp;&nbsp;</td><td>&nbsp;&nbsp;.....&nbsp;&nbsp;</td></tr>
<tr valign="TOP"><td>Y<sub>N-2, i</sub></td><td>U<sub>N/2-1, i</sub>.Re</td></tr>
<tr valign="TOP"><td>Y<sub>N-1, i</sub></td><td>U<sub>N/2-1, i</sub>.Im</td></tr></table>
&nbsp;
<BR>This storage scheme implies that, for C/C++ (where matrices are stored in row-major order), the real and imaginary parts of any element are not adjacent in memory . 
<BR>For inverse real-matrix Cols_FFT, the input matrix has to be of this packed-complex format, and you get a real matrix. If you prefer to get the result of forward FFT in true complex format, use <I>MF_Cols_FFTtoC</I>.
<P><i>MFb_Cols_FFT, MFb_Cols_FFTtoC</i> and <i>MCFb_Cols_FFT</i> take a buffer vector <i>Buf</i> as an additional argument. They are slightly more efficient than the un-buffered versions. <i>Buf</i> must have (at least) the same size as MX and MY (i.e., Buf.size &gt;= ht*len).
<P>For historical reasons, there exist special versions with the prefixes <I>VFp_, &nbsp;VFs_</I> and <I>VFl_</I>. They are deprecated and may be removed in future versions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If ht is not a power of 2, the program is aborted with the error message &quot;Size must be an integer power of 2&quot;.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_FFT">MF_Rows_FFT</a>,&nbsp;&nbsp; <a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#chap12">chapter&nbsp;12</a>,&nbsp;&nbsp; <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8 of HANDBOOK.HTM</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_lincomb"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_lincomb</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_lincomb</b></font></td>
<td><font size="+1"><b>ME_Cols_lincomb</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_lincomb</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_lincomb</b></font></td>
<td><font size="+1"><b>MCE_Cols_lincomb</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>linear combination of two columns</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_lincomb( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, float&nbsp;destC, unsigned&nbsp;srceCol, float&nbsp;srceC&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_lincomb( const&nbsp;unsigned&nbsp;destCol, const&nbsp;T&amp;&nbsp;destC, const&nbsp;unsigned&nbsp;srceCol, const&nbsp;T&amp;&nbsp;srceC&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_lincomb( MA:fMatrix; ht,&nbsp;len:UIntSize; destCol:UIntSize; destC:Single; srceCol:UIntSize; srceC:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_lincomb( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, float&nbsp;destC, unsigned&nbsp;srceCol, float&nbsp;srceC&nbsp;);
<BR>int cusdMF_Cols_lincomb( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, float&nbsp;
d_destC, unsigned&nbsp;srceCol, float&nbsp;*d_srceC&nbsp;);
<BR>void MFcu_Cols_lincomb( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, float&nbsp;destC, unsigned&nbsp;srceCol, float&nbsp;srceC&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_lincomb( d_MA:fMatrix; ht,&nbsp;len:UIntSize; destCol:UIntSize; destC:Single; srceCol:UIntSize; srceC:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Cols_lincomb( d_MA:fMatrix; ht,&nbsp;len:UIntSize; destCol:UIntSize; d_destC:PSingle; srceCol:UIntSize; d_srceC:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_lincomb( h_MA:fMatrix; ht,&nbsp;len:UIntSize; destCol:UIntSize; destC:Single; srceCol:UIntSize; srceC:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,destCol</sub> = destC *&nbsp;MA<sub>i,destCol</sub>+ srceC *&nbsp;MA<sub>i,srceCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_add">MF_Cols_add</a>,&nbsp;&nbsp; <a href="#Cols_Cadd">MF_Cols_Cadd</a>,&nbsp;&nbsp; <a href="#chap8">chapter&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_max"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_max</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_max</b></font></td>
<td><font size="+1"><b>ME_Cols_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Cols_max</b></font></td><td width="20%"><font size="+1"><b>MBI_Cols_max</b></font></td><td width="20%"><font size="+1"><b>MSI_Cols_max</b></font></td><td width="20%"><font size="+1"><b>MLI_Cols_max</b></font></td><td><font size="+1"><b>MQI_Cols_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Cols_max</b></font></td><td width="20%"><font size="+1"><b>MUB_Cols_max</b></font></td><td width="20%"><font size="+1"><b>MUS_Cols_max</b></font></td><td width="20%"><font size="+1"><b>MUL_Cols_max</b></font></td><td><font size="+1"><b>MUQ_Cols_max</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the maxima of all individual columns in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_max( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Cols_max( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_max( Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_max( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Cols_max( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_max( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_max( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum value of each column <I>j</I> is stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmax">MF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Cols_min">MF_Cols_min</a>,&nbsp;&nbsp; <a href="#Rows_max">MF_Rows_max</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_maxReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_maxReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Cols_maxReIm</b></font></td>
<td><font size="+1"><b>MCE_Cols_maxReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the largest values of the real and imaginary parts of each column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_Cols_maxReIm( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt;&nbsp;&gt;::Cols_maxReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_Cols_maxReIm( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Cols_maxReIm( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Cols_maxReIm( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Cols_maxReIm( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Cols_maxReIm( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum values of the real and imaginary parts of each column <I>j</I> are combined into the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmax">MCF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Cols_minReIm">MCF_Cols_minReIm</a>,&nbsp;&nbsp; <a href="#Rows_absmaxReIm">MCF_Rows_absmaxReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_min"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_min</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_min</b></font></td>
<td><font size="+1"><b>ME_Cols_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Cols_min</b></font></td><td width="20%"><font size="+1"><b>MBI_Cols_min</b></font></td><td width="20%"><font size="+1"><b>MSI_Cols_min</b></font></td><td width="20%"><font size="+1"><b>MLI_Cols_min</b></font></td><td><font size="+1"><b>MQI_Cols_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Cols_min</b></font></td><td width="20%"><font size="+1"><b>MUB_Cols_min</b></font></td><td width="20%"><font size="+1"><b>MUS_Cols_min</b></font></td><td width="20%"><font size="+1"><b>MUL_Cols_min</b></font></td><td><font size="+1"><b>MUQ_Cols_min</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the minima of all individual columns in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_min( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Cols_min( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_min( Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_min( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Cols_min( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_min( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_min( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum value of each column <I>j</I> is stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmax">MF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Cols_min">MF_Cols_min</a>,&nbsp;&nbsp; <a href="#Rows_max">MF_Rows_max</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_minReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_minReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Cols_maxReIm</b></font></td>
<td><font size="+1"><b>MCE_Cols_maxReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the largest values of the real and imaginary parts of each column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_Cols_maxReIm( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt;&nbsp;&gt;::Cols_minReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_Cols_minReIm( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Cols_minReIm( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Cols_minReIm( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Cols_minReIm( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Cols_minReIm( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum values of the real and imaginary parts of each column <I>j</I> are combined into the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmin">MCF_Cols_absmin</a>,&nbsp;&nbsp; <a href="#Cols_maxReIm">MCF_Cols_maxReIm</a>,&nbsp;&nbsp; <a href="#Rows_absminReIm">MCF_Rows_absminReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_prod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_prod</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_prod</b></font></td>
<td><font size="+1"><b>ME_Cols_prod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_prod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_prod</b></font></td>
<td><font size="+1"><b>MCE_Cols_prod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>products over all elements of each individual column, stored in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_prod(fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Cols_prod( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_prod(Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_prod( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Cols_prod( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_prod( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_prod( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>j</sub> = prod( MA<sub>i,j</sub>, i=0,..,ht-1),&nbsp;&nbsp;j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_runprod">MF_Cols_runprod</a>,&nbsp;&nbsp; <a href="#Cols_sum">MF_Cols_sum</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_reflect"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_reflect</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_reflect</b></font></td>
<td><font size="+1"><b>ME_Cols_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_reflect</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Cols_reflect</b></font></td>
<td><font size="+1"><b>MCE_Cols_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Cols_reflect</b></font></td><td width="20%"><font size="+1"><b>MBI_Cols_reflect</b></font></td><td width="20%"><font size="+1"><b>MSI_Cols_reflect</b></font></td><td width="20%"><font size="+1"><b>MLI_Cols_reflect</b></font></td><td><font size="+1"><b>MQI_Cols_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Cols_reflect</b></font></td><td width="20%"><font size="+1"><b>MUB_Cols_reflect</b></font></td><td width="20%"><font size="+1"><b>MUS_Cols_reflect</b></font></td><td width="20%"><font size="+1"><b>MUL_Cols_reflect</b></font></td><td><font size="+1"><b>MUQ_Cols_reflect</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Derive the second halves of all columns from their first halves by reflection at the horizontal line through the center of the matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_reflect( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_reflect();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_reflect( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_reflect( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Cols_reflect( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_reflect( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_reflect( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>ht-i-1,j</sub> = MA<sub>i, j</sub>,&nbsp;&nbsp;i=0,..(ht-1)/2;&nbsp;&nbsp;j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_rotate">MF_Cols_rotate</a>,&nbsp;&nbsp; <a href="#Rows_reflect">MF_Rows_reflect</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_rev"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_rev</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_rev</b></font></td>
<td><font size="+1"><b>ME_Cols_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_rev</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Cols_rev</b></font></td>
<td><font size="+1"><b>MCE_Cols_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Cols_rev</b></font></td><td width="20%"><font size="+1"><b>MBI_Cols_rev</b></font></td><td width="20%"><font size="+1"><b>MSI_Cols_rev</b></font></td><td width="20%"><font size="+1"><b>MLI_Cols_rev</b></font></td><td><font size="+1"><b>MQI_Cols_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Cols_rev</b></font></td><td width="20%"><font size="+1"><b>MUB_Cols_rev</b></font></td><td width="20%"><font size="+1"><b>MUS_Cols_rev</b></font></td><td width="20%"><font size="+1"><b>MUL_Cols_rev</b></font></td><td><font size="+1"><b>MUQ_Cols_rev</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse the element ordering along columns. This corresponds to a reflection of the matrix at the X axis.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_rev( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_rev();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_rev( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_rev( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Cols_rev( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_rev( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_rev( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = MA<sub>ht-i-1, j</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="Rows_rev">MF_Rows_rev</a>,&nbsp;&nbsp; <a href="#Cols_reflect">MF_Cols_reflect</a>,&nbsp;&nbsp; <a href="#rotate90">MF_rotate90</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_rotate"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_rotate</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_rotate</b></font></td>
<td><font size="+1"><b>ME_Cols_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_rotate</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_rotate</b></font></td>
<td><font size="+1"><b>MCE_Cols_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Cols_rotate</b></font></td><td width="20%"><font size="+1"><b>MBI_Cols_rotate</b></font></td><td width="20%"><font size="+1"><b>MSI_Cols_rotate</b></font></td><td width="20%"><font size="+1"><b>MLI_Cols_rotate</b></font></td><td><font size="+1"><b>MQI_Cols_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Cols_rotate</b></font></td><td width="20%"><font size="+1"><b>MUB_Cols_rotate</b></font></td><td width="20%"><font size="+1"><b>MUS_Cols_rotate</b></font></td><td width="20%"><font size="+1"><b>MUL_Cols_rotate</b></font></td><td><font size="+1"><b>MUQ_Cols_rotate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>rotate all columns by a specified number of positions; thereby, whole rows are moved</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_rotate( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_rotate( const int&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_rotate( MA:fMatrix; ht,&nbsp;len:UIntSize; pos:Integer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_rotate( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;pos&nbsp;);
<BR>void MFcu_Cols_rotate( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;pos&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_rotate( d_MA:fMatrix; ht,&nbsp;len:UIntSize; pos:Integer&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_rotate( h_MA:fMatrix; ht,&nbsp;len:UIntSize; pos:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = MA<sub>ht-pos+i, j</sub>,&nbsp;&nbsp;&nbsp;i=0,..,pos-1
<BR>MA<sub>i,j</sub> = MA<sub>i-pos, j</sub>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=pos,...,ht-1
<P>This function is rather inefficient, as it needs to internally allocate and de-allocate work-space each time it is called. If your application contains frequent calls to this function, we recommend to allocate some matrix MBuf as buffer memory and replace the calls to <i>MF_Cols_rotate</i> by calls to <i><a href="#Cols_rotate_buf">MF_Cols_rotate_buf</a></i>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_reflect">MF_Cols_reflect</a>,&nbsp;&nbsp; <a href="#Rows_rotate">MF_Rows_rotate</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_rotate_buf"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_rotate_buf</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_rotate_buf</b></font></td>
<td><font size="+1"><b>ME_Cols_rotate_buf</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_rotate_buf</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_rotate_buf</b></font></td>
<td><font size="+1"><b>MCE_Cols_rotate_buf</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Cols_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MBI_Cols_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MSI_Cols_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MLI_Cols_rotate_buf</b></font></td><td><font size="+1"><b>MQI_Cols_rotate_buf</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Cols_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MUB_Cols_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MUS_Cols_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MUL_Cols_rotate_buf</b></font></td><td><font size="+1"><b>MUQ_Cols_rotate_buf</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>efficient column rotation (moving of whole rows), using specified buffer memory</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_rotate_buf( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;pos, fMatrix&nbsp;MBuf&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_rotate_buf( const int&nbsp;pos, const matrix&lt;T&gt;&nbsp;MBuf&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_rotate_buf( MA:fMatrix; ht,&nbsp;len:UIntSize; pos:Integer; MBuf:fMatrix&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_rotate_buf( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;pos, fMatrix&nbsp;d_MBuf&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_rotate_buf( d_MA:fMatrix; ht,&nbsp;len:UIntSize; pos:Integer; d_MBuf:fMatrix&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = MA<sub>ht-pos+i, j</sub>,&nbsp;&nbsp;&nbsp;i=0,..,pos-1
<BR>MA<sub>i,j</sub> = MA<sub>i-pos, j</sub>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=pos,...,ht-1
<P>This function is a more efficient variant of <a href="#Cols_rotate">MF_Cols_rotate</a>. Instead of internally allocating the necessary work-space, it takes the matrix MBuf as buffer memory. MBuf must be a matrix generated by the <i>OptiVec</i> memory management functions (<i><a href="#matrix">MF_matrix</a></i> etc.). The size (i.e., the number of elements, ht*len) of MBuf must be at least the same size as MA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_rotate">MF_Cols_rotate</a>,&nbsp;&nbsp; <a href="#Rows_rotate_buf">MF_Rows_rotate_buf</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_runprod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_runprod</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_runprod</b></font></td>
<td><font size="+1"><b>ME_Cols_runprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_runprod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_runprod</b></font></td>
<td><font size="+1"><b>MCE_Cols_runprod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>running product over column elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_runprod( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_runprod();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_runprod( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_runprod( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Cols_runprod( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_runprod( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_runprod( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For all columns separately, each element is the product of itself and all preceding elements. This function should be used with care: overflow is easily reached, and underflow may lead to all elements from a certain position on being zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_prod">MF_Cols_prod</a>,&nbsp;&nbsp; <a href="#Rows_runprod">MF_Rows_runprod</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_runsum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_runsum</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_runsum</b></font></td>
<td><font size="+1"><b>ME_Cols_runsum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_runsum</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_runsum</b></font></td>
<td><font size="+1"><b>MCE_Cols_runsum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>running sum over column elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_runsum( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_runsum();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_runsum( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_runsum( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Cols_runsum( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_runsum( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_runsum( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For all columns separately, each element is the sum of itself and all preceding elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_sum">MF_Cols_sum</a>,&nbsp;&nbsp; <a href="#Rows_runsum">MF_Rows_runsum</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_sabsmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_sabsmax</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Cols_sabsmax</b></font></td>
<td><font size="+1"><b>MCE_Cols_sabsmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex numbers of largest sum |Re|&nbsp;+&nbsp;|Im|  along columns and store them in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_Cols_sabsmax( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt; T&gt;::Cols_sabsmax( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_Cols_sabsmax( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Cols_sabsmax( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Cols_sabsmax( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Cols_sabsmax( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Cols_sabsmax( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Within each column j of MA, the complex number with the largest sum, |Re|&nbsp;+&nbsp;|Im|,  is found and stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmax">MCF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Cols_cabsmin">MCF_Cols_cabsmin</a>,&nbsp;&nbsp; <a href="#Cols_sabsmax">MCF_Cols_sabsmax</a>,&nbsp;&nbsp; <a href="#Rows_cabsmax">MCF_Rows_cabsmax</a>,&nbsp;&nbsp; <a href="#Dia_cabsmax">MCF_Dia_cabsmax</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_sabsmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_sabsmin</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Cols_sabsmin</b></font></td>
<td><font size="+1"><b>MCE_Cols_sabsmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex numbers of largest sum |Re|&nbsp;+&nbsp;|Im|  along columns and store them in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_Cols_sabsmin( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt; T&gt;::Cols_sabsmin( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_Cols_sabsmin( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Within each column j of MA, the complex number with the largest sum, |Re|&nbsp;+&nbsp;|Im|,  is found and stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Cols_sabsmin( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Cols_sabsmin( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Cols_sabsmin( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Cols_sabsmin( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmin">MCF_Cols_absmin</a>,&nbsp;&nbsp; <a href="#Cols_cabsmax">MCF_Cols_cabsmax</a>,&nbsp;&nbsp; <a href="#Cols_sabsmin">MCF_Cols_sabsmin</a>,&nbsp;&nbsp; <a href="#Rows_cabsmin">MCF_Rows_cabsmin</a>,&nbsp;&nbsp; <a href="#Dia_cabsmin">MCF_Dia_cabsmin</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_sub"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_sub</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_sub</b></font></td>
<td><font size="+1"><b>ME_Cols_sub</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_sub</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_sub</b></font></td>
<td><font size="+1"><b>MCE_Cols_sub</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract one column from another and store the result back into the subtrahend</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_sub( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned destCol, unsigned sourceCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Cols_sub( const&nbsp;unsigned&nbsp;destCol, const&nbsp;unsigned&nbsp;sourceCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_sub( MA:fMatrix; ht,&nbsp;len,&nbsp;destCol, sourceCol:UIntSize;&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_sub( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, unsigned&nbsp;sourceCol&nbsp;);
<BR>void MFcu_Cols_sub( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destCol, unsigned&nbsp;sourceCol&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_sub( d_MA:fMatrix; ht,&nbsp;len,&nbsp;destCol,&nbsp;sourceCol:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_sub( h_MA:fMatrix; ht,&nbsp;len,&nbsp;destCol,&nbsp;sourceCol:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,destCol</sub> -= MA<sub>i,sourceCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_add">MF_Cols_add</a>,&nbsp;&nbsp; <a href="#Cols_Cadd">MF_Cols_Cadd</a>,&nbsp;&nbsp; <a href="#chap8">chapter&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_sum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_sum</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_sum</b></font></td>
<td><font size="+1"><b>ME_Cols_sum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_sum</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_sum</b></font></td>
<td><font size="+1"><b>MCE_Cols_sum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>sums over all columns, returned in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_sum( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Cols_sum( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_sum( Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Cols_sum( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Cols_sum( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Cols_sum( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Cols_sum( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>j</sub> = sum( MA<sub>i,j</sub>, i=0,..,ht-1),&nbsp;&nbsp;j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_prod">MF_Cols_prod</a>,&nbsp;&nbsp; <a href="#Cols_runsum">MF_Cols_runsum</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="conj"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_conj</b></font>
</td><td width="33%"><font size="+1"><b>MCD_conj</b></font></td>
<td><font size="+1"><b>MCE_conj</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>complex conjugate</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_conj( cfMatrix&nbsp;MB, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::conj();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_conj( MB,&nbsp;MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_conj( cfMatrix&nbsp;d_MB, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_conj( cfMatrix&nbsp;h_MB, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_conj( d_MB,&nbsp;d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_conj( h_MB,&nbsp;h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>ij</sub>.Re = MA<sub>ij</sub>.Re<BR>
MB<sub>ij</sub>.Im = -MA<sub>ij</sub>.Im</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#neg">MCF_neg</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="convolve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_convolve</b></font>
</td><td width="33%"><font size="+1"><b>MD_convolve</b></font></td>
<td><font size="+1"><b>ME_convolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>convolution with a spatial response function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_convolve( fMatrix&nbsp;MY, fMatrix&nbsp;MFlt, fMatrix&nbsp;MX, fMatrix&nbsp;MRsp, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::convolve( matrix&lt;T&gt; MFlt, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, const&nbsp;matrix&lt;T&gt; MRsp);<BR>
void matrix&lt;T&gt;::convolve( matrix&lt;T&gt;*&nbsp;MFlt, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, const&nbsp;matrix&lt;T&gt; MRsp);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_convolve( MY,&nbsp;MFlt,&nbsp;MX,&nbsp;MRsp:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_convolve( fMatrix&nbsp;d_MY, fMatrix&nbsp;d_MFlt, fMatrix&nbsp;d_MX, fMatrix&nbsp;d_MRsp, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_convolve( fMatrix&nbsp;h_MY, fMatrix&nbsp;h_MFlt, fMatrix&nbsp;h_MX, fMatrix&nbsp;h_MRsp, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_convolve( d_MY,&nbsp;d_MFlt,&nbsp;d_MX,&nbsp;d_MRsp:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_convolve( h_MY,&nbsp;h_MFlt,&nbsp;h_MX,&nbsp;h_MRsp:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td> The convolution of MX with the response function MRsp is calculated and stored in MY. A filter MFlt is also calculated. If more than one matrix is to be convolved with the same MRsp, use <I><a href="#convolve">MF_convolve</a></I> only once and use <I><a href="#filter">MF_filter</a></I> for the other matrices.
<P>The response has to be stored in MRsp in wrap-around order in both dimensions: in each row i of MRsp, the response for zero and positive x-values is stored in MRsp<sub>i,0</sub> to MRsp<sub>i,len/2</sub> and the response for negative x-values (beginning with the most negative x) in MRsp<sub>i,len/2+1</sub> to MRsp<sub>i,len-1</sub>.
<BR>Similarly, in each column of MRsp, the response for zero and positive y-values is stored in MRsp<sub>0,j</sub> to MRsp<sub>len/2,j</sub> and the response for negative y-values (beginning with the most negative y) in MRsp<sub>len/2+1,j</sub> to MRsp<sub>len-1,j</sub>.
<BR>You may wish to use <I><a href="#Rows_rotate">MF_Rows_rotate</a></I> and <I><a href="#Cols_rotate">MF_Cols_rotate</a></I>, or <I><a href="#Rows_reflect">MF_Rows_reflect</a></I> and <I><a href="#Cols_reflect">MF_Cols_reflect</a></I> to achieve this wrap-around order and to construct the response matrix.<P>The result of the convolution appears scaled with the sum of all elements of MRsp. Normally, therefore, MRsp should be normalized to 1.0.
<P>MX, MY, MRsp, and MFlt must all be of the same dimensions. Both len and ht have to be integer powers of 2. MX may be overwritten by MY, MRsp may be overwritten by MFlt, but MX and MFlt as well as MY and MRsp have to be distinct from each other.
<P>As in the one-dimensional case, the treatment of round-off errors in the construction of MFlt may be modified by <I><a href="FUNCREF.HTM#setRspEdit">VF_setRspEdit</a></I>.
<BR>The input matrix is assumed to be periodic in both dimensions. See the description of <I><a href="FUNCREF.HTM#convolve">VF_convolve</a></I> on how to avoid end effects, in case it is not periodic.
<BR>About special versions with the prefixes <I>MFl_</I> and <I>MFs_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8 of HANDBOOK.HTM</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either len or ht is not a power of 2, <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I> (on which <I>MF_convolve</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#deconvolve">MF_deconvolve</a>,&nbsp;&nbsp; <a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#chap12">chapter&nbsp;12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="cprint"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_cprint</b></font>
</td><td width="33%"><font size="+1"><b>MD_cprint</b></font></td>
<td><font size="+1"><b>ME_cprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_cprint</b></font></td>
<td width="33%"><font size="+1"><b>MCD_cprint</b></font></td>
<td><font size="+1"><b>MCE_cprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_cprint</b></font></td><td width="20%"><font size="+1"><b>MBI_cprint</b></font></td><td width="20%"><font size="+1"><b>MSI_cprint</b></font></td><td width="20%"><font size="+1"><b>MLI_cprint</b></font></td><td><font size="+1"><b>MQI_cprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_cprint</b></font></td><td width="20%"><font size="+1"><b>MUB_cprint</b></font></td><td width="20%"><font size="+1"><b>MUS_cprint</b></font></td><td width="20%"><font size="+1"><b>MUL_cprint</b></font></td><td><font size="+1"><b>MUQ_cprint</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>print a matrix to the screen (console applications only)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_cprint( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::cprint();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_cprint( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_cprint( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMF_cprint_buf( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_cprint( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMF_cprint_buf( d_MA:fMatrix; ht,&nbsp;len:UIntSize; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA is printed to the screen. Each line corresponds to one row of the matrix. The lines are numbered. If necessary, rows are cut off at the screen boundaries. If there are more rows than screen lines, proper paging is applied. 
<P>This family of functions is available only for console applications.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If the number of columns exceeds the maximum number of entries possible in the current text mode, an error message &quot;Cannot use requested format (too many entries per line)!&quot; is generated; in this case, the rows are truncated.
<P>CUDA versions only: <i>cudaM?_cprint_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as d_MA, i.e. ht*len. By avoiding the need of <i>cudaM?_cprint</i> to allocate its own buffer memory, <i>cudaM?_cprint_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#fprint">MF_fprint</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#cprint">VF_cprint</a>,&nbsp;&nbsp; <a href="#chap14">chapter&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="deconvolve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_deconvolve</b></font>
</td><td width="33%"><font size="+1"><b>MD_deconvolve</b></font></td>
<td><font size="+1"><b>ME_deconvolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>spatial deconvolution, edge sharpening</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_deconvolve( fMatrix&nbsp;MY, fMatrix&nbsp;MFlt, fMatrix&nbsp;MX, fMatrix&nbsp;MRsp, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::deconvolve( matrix&lt;T&gt; MFlt, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, const&nbsp;matrix&lt;T&gt; MRsp);<BR>
void matrix&lt;T&gt;::deconvolve( matrix&lt;T&gt;*&nbsp;MFlt, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, const&nbsp;matrix&lt;T&gt; MRsp);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_deconvolve( MY,&nbsp;MFlt,&nbsp;MX,&nbsp;MRsp:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_deconvolve( fMatrix&nbsp;d_MY, fMatrix&nbsp;d_MFlt, fMatrix&nbsp;d_MX, fMatrix&nbsp;d_MRsp, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_deconvolve( fMatrix&nbsp;h_MY, fMatrix&nbsp;h_MFlt, fMatrix&nbsp;h_MX, fMatrix&nbsp;h_MRsp, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_deconvolve( d_MY,&nbsp;d_MFlt,&nbsp;d_MX,&nbsp;d_MRsp:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_deconvolve( h_MY,&nbsp;h_MFlt,&nbsp;h_MX,&nbsp;h_MRsp:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MX is assumed to be the result of a convolution of some &quot;true&quot; profile with the response function MRsp; a deconvolution is attempted and stored in MY. A filter MFlt is also calculated; if more than one matrix is to be deconvolved with the same MRsp, use <I>MF_deconvolve</I> only once and use the filter MFlt thus obtained to deconvolve other matrices by calling <I><a href="#filter">MF_filter</a></I>. The response has to be stored in the wrap-around order described above for <I><a href="#convolve">MF_convolve</a></I>.
<P>As for <I><a href="#convolve">MF_convolve</a></I>, MX, MY, MRsp, and MFlt must all be of the same dimensions, which have to be integer powers of 2. MX may be overwritten by MY, MRsp may be overwritten by MFlt, but MX and MFlt as well as MY and MRsp have to be distinct from each other.
<P>Mathematically, MFlt is the inverse of the Fourier transform of MRsp. If the Fourier transform of MRsp contains elements equal to zero, all information is lost for the respective frequency and no reconstruction is possible. The best one can do in this case is to accept this loss and to deconvolve only up to those frequencies where still something is left to be reconstructed.
<BR>You are therefore advised not to use this function blindly but rather to inspect the Fourier transform of MRsp and decide what to do on the basis of your specific application. If you wish to use this function nevertheless, you may rely on the automatic editing of the filter, built into <I>MF_deconvolve</I>. Thereby, MFlt is set to zero (instead of infinity) at those frequences where all information has been lost. You may set the threshold for this implicit editing by <I><a href="FUNCREF.HTM#setRspEdit">VF_setRspEdit</a></I>. In order to retrieve the threshold actually set, use <I><a href="FUNCREF.HTM#getRspEdit">VF_getRspEdit</a></I>. (These two functions are shared between the one- and two-dimensional FFT functions and described in FUNCREF.HTM.)
<P>This deconvolution is based on the implicit assumption that MX is periodic; if this is not the case, see the description of <I><a href="FUNCREF.HTM#convolve">VF_convolve</a></I> about how to avoid end effects.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either len or ht is not a power of 2, <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I> (on which <I>MF_deconvolve</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.
<BR>If, by <I><a href="FUNCREF.HTM#setRspEdit">VF_setRspEdit</a></I>, you specified Trunc.Re = Trunc.Im = 0, SING errors may occur that are handled by setting MFlt to &#177;HUGE_VAL at the respective frequency. During multiplication with the transform of MX, this may lead to unhandled floating-point overflow errors (in case your guess of MRsp was wrong and there is some information left at the frequencies where you thought it was not).
<BR>About special versions with the prefixes <I>MFl_</I> and <I>MFs_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8 of HANDBOOK.HTM</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#convolve">MF_convolve</a>,&nbsp;&nbsp; <a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#chap12">chapter 12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="det"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_det</b></font>
</td><td width="33%"><font size="+1"><b>MD_det</b></font></td>
<td><font size="+1"><b>ME_det</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_det</b></font></td>
<td width="33%"><font size="+1"><b>MCD_det</b></font></td>
<td><font size="+1"><b>MCE_det</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>determinant of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_det( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T matrix&lt;T&gt;::det();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_det( MA:fMatrix; len:UIntSize&nbsp;):Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The determinant of MA is calculated. For large matrices, this is done <I>via</I> LU decomposition. For small matrices, individual formulae are applied.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>determinant of the matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#LUdecompose">MF_LUdecompose</a>,&nbsp;&nbsp; <a href="#solve">MF_solve</a>,&nbsp;&nbsp; <a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_absmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_absmax</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_absmax</b></font></td>
<td><font size="+1"><b>ME_Dia_absmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_absmax</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_absmax</b></font></td>
<td><font size="+1"><b>MCE_Dia_absmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>absolute maximum of the elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_Dia_absmax( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T matrix&lt;T&gt;::Dia_absmax();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Dia_absmax( MA:fMatrix; len:UIntSize&nbsp;):&nbsp;Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_absmax( float&nbsp;*h_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMF_Dia_absmax( float&nbsp;*d_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>float MFcu_Dia_absmax( fMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_absmax( var&nbsp;h_RetVal:Single; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_absmax( d_RetVal:PSingle; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_absmax( h_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum absolute value of all elements MA<sub>i,i</sub> is returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>absolute maximum of the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_max">MF_Dia_max</a>,&nbsp;&nbsp; <a href="#Dia_absmin">MF_Dia_absmin</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_absmaxReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_absmaxReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Dia_absmaxReIm</b></font></td>
<td><font size="+1"><b>MCE_Dia_absmaxReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the largest absolute values of the real and imaginary parts occurring along the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
fComplex MCF_Dia_absmaxReIm( cfMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
<BR>complex&lt;T&gt; matrix&lt;complex&lt;T&gt;&gt;::Dia_absmaxReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
function MCF_Dia_absmaxReIm( MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCF_Dia_absmaxReIm( var&nbsp;RetVal:fComplex; MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Dia_absmaxReIm( fComplex&nbsp;*h_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMCF_Dia_absmaxReIm( fComplex&nbsp;*d_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>fComplex MCFcu_Dia_absmaxReIm( cfMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Dia_absmaxReIm( var&nbsp;h_RetVal:fComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMCF_Dia_absmaxReIm( d_RetVal:PfComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function MCFcu_Dia_absmaxReIm( h_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCFcu_Dia_absmaxReIm( var&nbsp;h_RetVal:fComplex; h_MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum absolute values of the real and imaginary parts of the diagonal of a square matrix are combined into the complex return value (or, for Pascal/Delphi, into the variable Max).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_absminReIm">MCF_Dia_absminReIm</a>,&nbsp;&nbsp; <a href="#Dia_absmax">MCF_Dia_absmax</a>,&nbsp;&nbsp; <a href="#Dia_maxReIm">MCF_Dia_maxReIm</a>,&nbsp;&nbsp; <a href="#Rows_absmaxReIm">MCF_Rows_absmaxReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_absmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_absmin</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_absmin</b></font></td>
<td><font size="+1"><b>ME_Dia_absmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_absmin</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_absmin</b></font></td>
<td><font size="+1"><b>MCE_Dia_absmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>absolute minimum of the elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_Dia_absmin( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T matrix&lt;T&gt;::Dia_absmin();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Dia_absmin( MA:fMatrix; len:UIntSize&nbsp;):Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_absmin( float&nbsp;*h_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMF_Dia_absmin( float&nbsp;*d_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>float MFcu_Dia_absmin( fMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_absmin( var&nbsp;h_RetVal:Single; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_absmin( d_RetVal:PSingle; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_absmin( h_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum absolute value of all elements MA<sub>i,i</sub> is returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>absolute minimum of the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_min">MF_Dia_min</a>,&nbsp;&nbsp; <a href="#Dia_absmax">MF_Dia_absmax</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_absminReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_absminReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Dia_absminReIm</b></font></td>
<td><font size="+1"><b>MCE_Dia_absminReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the smallest absolute values of the real and imaginary parts occurring along the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
fComplex MCF_Dia_absminReIm( cfMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
<BR>complex&lt;T&gt; matrix&lt;complex&lt;T&gt;&gt;::Dia_absminReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
<BR>function MCF_Dia_absminReIm( MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCF_Dia_absminReIm( var Min:fComplex; MA:cfMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Dia_absminReIm( fComplex&nbsp;*h_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMCF_Dia_absminReIm( fComplex&nbsp;*d_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>fComplex MCFcu_Dia_absminReIm( cfMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Dia_absminReIm( var&nbsp;h_RetVal:fComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMCF_Dia_absminReIm( d_RetVal:PfComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function MCFcu_Dia_absminReIm( h_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCFcu_Dia_absminReIm( var&nbsp;h_RetVal:fComplex; h_MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum absolute values of the real and imaginary parts of the diagonal of a square matrix are combined into the the complex return value (or, for Pascal/Delphi, into the variable Min).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_absmaxReIm">MCF_Dia_absmaxReIm</a>,&nbsp;&nbsp; <a href="#Dia_absmin">MCF_Dia_absmin</a>,&nbsp;&nbsp; <a href="#Dia_minReIm">MCF_Dia_minReIm</a>,&nbsp;&nbsp; <a href="#Rows_absmaxReIm">MCF_Rows_absmaxReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_addC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_addC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_addC</b></font></td>
<td><font size="+1"><b>ME_Dia_addC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_addC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_addC</b></font></td>
<td><font size="+1"><b>MCE_Dia_addC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>add a constant to all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_addC( fMatrix&nbsp;MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_addC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_addC( MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_addC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMF_Dia_addC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Dia_addC( fMatrix&nbsp;h_MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_addC( d_MA:fMatrix; len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_addC( d_MA:fMatrix; len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_addC( h_MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> += C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_addV">MF_Dia_addV</a>,&nbsp;&nbsp; <a href="#Dia_subC">MF_Dia_subC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_addV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_addV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_addV</b></font></td>
<td><font size="+1"><b>ME_Dia_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_addV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_addV</b></font></td>
<td><font size="+1"><b>MCE_Dia_addV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise addition of a vector to the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_addV( fMatrix&nbsp;MA, ui&nbsp;len, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_addV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_addV( MA:fMatrix; len:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_addV( fMatrix&nbsp;d_MA, ui&nbsp;len, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Dia_addV( fMatrix&nbsp;h_MA, ui&nbsp;len, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_addV( d_MA:fMatrix; len:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_addV( h_MA:fMatrix; len:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> += X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_addC">MF_Dia_addC</a>,&nbsp;&nbsp; <a href="#Dia_subV">MF_Dia_subV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_cabsmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_cabsmax</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Dia_cabsmax</b></font></td>
<td><font size="+1"><b>MCE_Dia_cabsmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex number of largest magnitude along the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
fComplex MCF_Dia_cabsmax( cfMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
<BR>complex&lt;T&gt; matrix&lt;complex&lt;T&gt;&gt;::Dia_cabsmax( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
<BR>function MCF_Dia_cabsmax( MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCF_Dia_cabsmax( var Max:fComplex; MA:cfMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Dia_cabsmax( fComplex&nbsp;*h_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMCF_Dia_cabsmax( fComplex&nbsp;*d_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>fComplex MCFcu_Dia_cabsmax( cfMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Dia_cabsmax( var&nbsp;h_RetVal:fComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMCF_Dia_cabsmax( d_RetVal:PfComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function MCFcu_Dia_cabsmax( h_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax for the complex types:<font face="courier new"><BR>
procedure MCFcu_Dia_cabsmax( var&nbsp;h_RetVal:fComplex; h_MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The complex number of largest magnitude, sqrt(Re<sup>2</sup>+Im<sup>2</sup>),  is found.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_cabsmin">MCF_Dia_cabsmin</a>,&nbsp;&nbsp; <a href="#Dia_absmax">MCF_Dia_absmax</a>,&nbsp;&nbsp; <a href="#Dia_maxReIm">MCF_Dia_maxReIm</a>,&nbsp;&nbsp; <a href="#Rows_cabsmax">MCF_Rows_cabsmax</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_cabsmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_cabsmin</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Dia_cabsmin</b></font></td>
<td><font size="+1"><b>MCE_Dia_cabsmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex number of smallest magnitude along the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
fComplex MCF_Dia_cabsmin( cfMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
<BR>complex&lt;T&gt; matrix&lt;complex&lt;T&gt;&gt;::Dia_cabsmin( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
<BR>function MCF_Dia_cabsmin( MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCF_Dia_cabsmin( var Max:fComplex; MA:cfMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Dia_cabsmin( fComplex&nbsp;*h_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMCF_Dia_cabsmin( fComplex&nbsp;*d_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>fComplex MCFcu_Dia_cabsmin( cfMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Dia_cabsmin( var&nbsp;h_RetVal:fComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMCF_Dia_cabsmin( d_RetVal:PfComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function MCFcu_Dia_cabsmin( h_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax for the complex types:<font face="courier new"><BR>
procedure MCFcu_Dia_cabsmin( var&nbsp;h_RetVal:fComplex; h_MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The complex number of smallest magnitude, sqrt(Re<sup>2</sup>+Im<sup>2</sup>),  is found.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_cabsmax">MCF_Dia_cabsmax</a>,&nbsp;&nbsp; <a href="#Dia_absmin">MCF_Dia_absmin</a>,&nbsp;&nbsp; <a href="#Dia_minReIm">MCF_Dia_minReIm</a>,&nbsp;&nbsp; <a href="#Rows_cabsmin">MCF_Rows_cabsmin</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_divC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_divC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_divC</b></font></td>
<td><font size="+1"><b>ME_Dia_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_divC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_divC</b></font></td>
<td><font size="+1"><b>MCE_Dia_divC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>divide all elements of the diagonal of a square matrix by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_divC( fMatrix&nbsp;MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_divC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_divC( MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_divC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMF_Dia_divC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Dia_divC( fMatrix&nbsp;h_MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_divC( d_MA:fMatrix; len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_divC( d_MA:fMatrix; len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_divC( h_MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> /= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_divV">MF_Dia_divV</a>,&nbsp;&nbsp; <a href="#Dia_mulC">MF_Dia_mulC</a>,&nbsp;&nbsp; <a href="#Dia_divrC">MF_Dia_divrC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_divrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_divrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_divrC</b></font></td>
<td><font size="+1"><b>ME_Dia_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_divrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_divrC</b></font></td>
<td><font size="+1"><b>MCE_Dia_divrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse division: divide a constant by the elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_divrC( fMatrix&nbsp;MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_divrC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_divrC( MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_divrC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMF_Dia_divrC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Dia_divrC( fMatrix&nbsp;h_MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_divrC( d_MA:fMatrix; len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_divrC( d_MA:fMatrix; len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_divrC( h_MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = C / MA<sub>i,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_divrV">MF_Dia_divrV</a>,&nbsp;&nbsp; <a href="#Dia_mulC">MF_Dia_mulC</a>,&nbsp;&nbsp; <a href="#Dia_divC">MF_Dia_divC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_divrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_divrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_divrV</b></font></td>
<td><font size="+1"><b>ME_Dia_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_divrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_divrV</b></font></td>
<td><font size="+1"><b>MCE_Dia_divrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse division: divide a vector by the diagonal of a square matrix, storing the result back into the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_divrV( fMatrix&nbsp;MA, ui&nbsp;len, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_divrV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_divrV( MA:fMatrix; len:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_divrV( fMatrix&nbsp;d_MA, ui&nbsp;len, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Dia_divrV( fMatrix&nbsp;h_MA, ui&nbsp;len, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_divrV( d_MA:fMatrix; len:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_divrV( h_MA:fMatrix; len:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = X<sub>i</sub> / MA<sub>i,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_divV">MF_Dia_divV</a>,&nbsp;&nbsp; <a href="#Dia_mulV">MF_Dia_mulV</a>,&nbsp;&nbsp; <a href="#Dia_divrC">MF_Dia_divrC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_divV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_divV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_divV</b></font></td>
<td><font size="+1"><b>ME_Dia_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_divV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_divV</b></font></td>
<td><font size="+1"><b>MCE_Dia_divV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise division of the diagonal of a square matrix by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_divV( fMatrix&nbsp;MA, ui&nbsp;len, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_divV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_divV( MA:fMatrix; len:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_divV( fMatrix&nbsp;d_MA, ui&nbsp;len, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Dia_divV( fMatrix&nbsp;h_MA, ui&nbsp;len, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_divV( d_MA:fMatrix; len:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_divV( h_MA:fMatrix; len:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> / X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_divrV">MF_Dia_divrV</a>,&nbsp;&nbsp; <a href="#Dia_mulV">MF_Dia_mulV</a>,&nbsp;&nbsp; <a href="#Dia_divC">MF_Dia_divC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_equ0"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_equ0</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_equ0</b></font></td>
<td><font size="+1"><b>ME_Dia_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_equ0</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_equ0</b></font></td>
<td><font size="+1"><b>MCE_Dia_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Dia_equ0</b></font></td><td width="20%"><font size="+1"><b>MBI_Dia_equ0</b></font></td><td width="20%"><font size="+1"><b>MSI_Dia_equ0</b></font></td><td width="20%"><font size="+1"><b>MLI_Dia_equ0</b></font></td><td><font size="+1"><b>MQI_Dia_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Dia_equ0</b></font></td><td width="20%"><font size="+1"><b>MUB_Dia_equ0</b></font></td><td width="20%"><font size="+1"><b>MUS_Dia_equ0</b></font></td><td width="20%"><font size="+1"><b>MUL_Dia_equ0</b></font></td><td><font size="+1"><b>MUQ_Dia_equ0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize all elements of the diagonal of a square matrix with zero</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_equ0( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_equ0(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_equ0( MA:fMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_equ0( fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>void MFcu_Dia_equ0( fMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_equ0( d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_equ0( h_MA:fMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = 0,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_equC">MF_Dia_equC</a>,&nbsp;&nbsp; <a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_equC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_equC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_equC</b></font></td>
<td><font size="+1"><b>ME_Dia_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_equC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_equC</b></font></td>
<td><font size="+1"><b>MCE_Dia_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Dia_equC</b></font></td><td width="20%"><font size="+1"><b>MBI_Dia_equC</b></font></td><td width="20%"><font size="+1"><b>MSI_Dia_equC</b></font></td><td width="20%"><font size="+1"><b>MLI_Dia_equC</b></font></td><td><font size="+1"><b>MQI_Dia_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Dia_equC</b></font></td><td width="20%"><font size="+1"><b>MUB_Dia_equC</b></font></td><td width="20%"><font size="+1"><b>MUS_Dia_equC</b></font></td><td width="20%"><font size="+1"><b>MUL_Dia_equC</b></font></td><td><font size="+1"><b>MUQ_Dia_equC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize all elements of the diagonal of a square matrix with a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_equC( fMatrix&nbsp;MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_equC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_equC( MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_equC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMF_Dia_equC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Dia_equC( fMatrix&nbsp;h_MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_equC( d_MA:fMatrix; len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_equC( d_MA:fMatrix; len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_equC( h_MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_equ0">MF_Dia_equ0</a>,&nbsp;&nbsp; <a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_equV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_equV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_equV</b></font></td>
<td><font size="+1"><b>ME_Dia_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_equV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_equV</b></font></td>
<td><font size="+1"><b>MCE_Dia_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Dia_equV</b></font></td><td width="20%"><font size="+1"><b>MBI_Dia_equV</b></font></td><td width="20%"><font size="+1"><b>MSI_Dia_equV</b></font></td><td width="20%"><font size="+1"><b>MLI_Dia_equV</b></font></td><td><font size="+1"><b>MQI_Dia_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Dia_equV</b></font></td><td width="20%"><font size="+1"><b>MUB_Dia_equV</b></font></td><td width="20%"><font size="+1"><b>MUS_Dia_equV</b></font></td><td width="20%"><font size="+1"><b>MUL_Dia_equV</b></font></td><td><font size="+1"><b>MUQ_Dia_equV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy a vector into the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_equV( fMatrix&nbsp;MA, ui&nbsp;len, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_equV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_equV( MA:fMatrix; len:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_equV( fMatrix&nbsp;d_MA, ui&nbsp;len, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Dia_equV( fMatrix&nbsp;h_MA, ui&nbsp;len, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_equV( d_MA:fMatrix; len:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_equV( h_MA:fMatrix; len:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_equ0">MF_Dia_equ0</a>,&nbsp;&nbsp; <a href="#Dia_equC">MF_Dia_equC</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_extract"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_extract</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_extract</b></font></td>
<td><font size="+1"><b>ME_Dia_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_extract</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_extract</b></font></td>
<td><font size="+1"><b>MCE_Dia_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Dia_extract</b></font></td><td width="20%"><font size="+1"><b>MBI_Dia_extract</b></font></td><td width="20%"><font size="+1"><b>MSI_Dia_extract</b></font></td><td width="20%"><font size="+1"><b>MLI_Dia_extract</b></font></td><td><font size="+1"><b>MQI_Dia_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Dia_extract</b></font></td><td width="20%"><font size="+1"><b>MUB_Dia_extract</b></font></td><td width="20%"><font size="+1"><b>MUS_Dia_extract</b></font></td><td width="20%"><font size="+1"><b>MUL_Dia_extract</b></font></td><td><font size="+1"><b>MUQ_Dia_extrac</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy the diagonal of a square matrix into a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_extract( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Dia_extract( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_extract( Y:fVector; MA:fMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_extract( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>void MFcu_Dia_extract( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_extract( d_Y:fVector; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_extract( h_Y:fVector; h_MA:fMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = MA<sub>i,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_max"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_max</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_max</b></font></td>
<td><font size="+1"><b>ME_Dia_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_max</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_max</b></font></td>
<td><font size="+1"><b>MCE_Dia_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Dia_max</b></font></td><td width="20%"><font size="+1"><b>MBI_Dia_max</b></font></td><td width="20%"><font size="+1"><b>MSI_Dia_max</b></font></td><td width="20%"><font size="+1"><b>MLI_Dia_max</b></font></td><td><font size="+1"><b>MQI_Dia_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Dia_max</b></font></td><td width="20%"><font size="+1"><b>MUB_Dia_max</b></font></td><td width="20%"><font size="+1"><b>MUS_Dia_max</b></font></td><td width="20%"><font size="+1"><b>MUL_Dia_max</b></font></td><td><font size="+1"><b>MUQ_Dia_ma;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>maximum of all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_Dia_max( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T matrix&lt;T&gt;::Dia_max();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Dia_max( MA:fMatrix; len:UIntSize&nbsp;):Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_max( float&nbsp;*h_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMF_Dia_max( float&nbsp;*d_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>float MFcu_Dia_max( fMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_max( var&nbsp;h_RetVal:Single; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_max( d_RetVal:PSingle; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_max( h_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>the largest element of the diagonal is returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>maximum of the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_absmax">MF_Dia_absmax</a>,&nbsp;&nbsp; <a href="#Dia_min">MF_Dia_min</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_maxReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_maxReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Dia_maxReIm</b></font></td>
<td><font size="+1"><b>MCE_Dia_maxReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the largest values of the real and imaginary parts occurring along the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
fComplex MCF_Dia_maxReIm( cfMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
<BR>complex&lt;T&gt; matrix&lt;complex&lt;T&gt;&gt;::Dia_maxReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
<BR>function MCF_Dia_maxReIm( MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCF_Dia_maxReIm( var Max:fComplex; MA:cfMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Dia_maxReIm( fComplex&nbsp;*h_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMCF_Dia_maxReIm( fComplex&nbsp;*d_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>fComplex MCFcu_Dia_maxReIm( cfMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Dia_maxReIm( var&nbsp;h_RetVal:fComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMCF_Dia_maxReIm( d_RetVal:PfComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function MCFcu_Dia_maxReIm( h_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCFcu_Dia_maxReIm( var&nbsp;h_RetVal:fComplex; h_MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum values of the real and imaginary parts of the diagonal of a square matrix are combined into the complex return value (or, for Pascal/Delphi, into the variable Max).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_minReIm">MCF_Dia_minReIm</a>,&nbsp;&nbsp; <a href="#Dia_max">MCF_Dia_max</a>,&nbsp;&nbsp; <a href="#Dia_absmaxReIm">MCF_Dia_absmaxReIm</a>,&nbsp;&nbsp; <a href="#Rows_maxReIm">MCF_Rows_maxReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_min"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_min</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_min</b></font></td>
<td><font size="+1"><b>ME_Dia_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_min</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_min</b></font></td>
<td><font size="+1"><b>MCE_Dia_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Dia_min</b></font></td><td width="20%"><font size="+1"><b>MBI_Dia_min</b></font></td><td width="20%"><font size="+1"><b>MSI_Dia_min</b></font></td><td width="20%"><font size="+1"><b>MLI_Dia_min</b></font></td><td><font size="+1"><b>MQI_Dia_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Dia_min</b></font></td><td width="20%"><font size="+1"><b>MUB_Dia_min</b></font></td><td width="20%"><font size="+1"><b>MUS_Dia_min</b></font></td><td width="20%"><font size="+1"><b>MUL_Dia_min</b></font></td><td><font size="+1"><b>MUQ_Dia_min</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>minimum of all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_Dia_min( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T matrix&lt;T&gt;::Dia_min();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Dia_min( MA:fMatrix; len:UIntSize&nbsp;):Single;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_min( float&nbsp;*h_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMF_Dia_min( float&nbsp;*d_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>float MFcu_Dia_min( fMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_min( var&nbsp;h_RetVal:Single; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_min( d_RetVal:PSingle; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_min( h_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;Single;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>the smallest or most negative element of the diagonal is returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>minimum of the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_absmin">MF_Dia_absmin</a>,&nbsp;&nbsp; <a href="#Dia_max">MF_Dia_max</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_minReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_minReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Dia_minReIm</b></font></td>
<td><font size="+1"><b>MCE_Dia_minReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the smallest absolute values of the real and imaginary parts occurring along the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
fComplex MCF_Dia_minReIm( cfMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
<BR>complex&lt;T&gt; matrix&lt;complex&lt;T&gt;&gt;::Dia_minReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
<BR>function MCF_Dia_mubReIm( MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCF_Dia_minReIm( var Min:fComplex; MA:cfMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Dia_minReIm( fComplex&nbsp;*h_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMCF_Dia_minReIm( fComplex&nbsp;*d_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>fComplex MCFcu_Dia_minReIm( cfMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Dia_minReIm( var&nbsp;h_RetVal:fComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMCF_Dia_minReIm( d_RetVal:PfComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function MCFcu_Dia_minReIm( h_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCFcu_Dia_minReIm( var&nbsp;h_RetVal:fComplex; h_MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum absolute values of the real and imaginary parts of the diagonal of a square matrix are combined into the the complex return value (or, for Pascal/Delphi, into the variable Min).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_maxReIm">MCF_Dia_maxReIm</a>,&nbsp;&nbsp; <a href="#Dia_min">MCF_Dia_min</a>,&nbsp;&nbsp; <a href="#Dia_absminReIm">MCF_Dia_absminReIm</a>,&nbsp;&nbsp; <a href="#Rows_absminReIm">MCF_Rows_absminReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_mulC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_mulC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_mulC</b></font></td>
<td><font size="+1"><b>ME_Dia_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_mulC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_mulC</b></font></td>
<td><font size="+1"><b>MCE_Dia_mulC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply all elements of the diagonal of a square matrix by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_mulC( fMatrix&nbsp;MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_mulC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_mulC( MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_mulC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMF_Dia_mulC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Dia_mulC( fMatrix&nbsp;h_MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_mulC( d_MA:fMatrix; len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_mulC( d_MA:fMatrix; len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_mulC( h_MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> *= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_mulV">MF_Dia_mulV</a>,&nbsp;&nbsp; <a href="#Dia_divC">MF_Dia_divC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_mulV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_mulV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_mulV</b></font></td>
<td><font size="+1"><b>ME_Dia_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_mulV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_mulV</b></font></td>
<td><font size="+1"><b>MCE_Dia_mulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise multiplication of the diagonal of a square matrix by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_mulV( fMatrix&nbsp;MA, ui&nbsp;len, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_mulV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_mulV( MA:fMatrix; len:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_mulV( fMatrix&nbsp;d_MA, ui&nbsp;len, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Dia_mulV( fMatrix&nbsp;h_MA, ui&nbsp;len, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_mulV( d_MA:fMatrix; len:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_mulV( h_MA:fMatrix; len:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> *= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_mulC">MF_Dia_mulC</a>,&nbsp;&nbsp; <a href="#Dia_divV">MF_Dia_divV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_prod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_prod</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_prod</b></font></td>
<td><font size="+1"><b>ME_Dia_prod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_prod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_prod</b></font></td>
<td><font size="+1"><b>MCE_Dia_prod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>product of all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_Dia_prod( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T matrix&lt;T&gt;::Dia_prod();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd, MCFstd;<BR>
function MF_Dia_prod( MA:fMatrix; len:UIntSize&nbsp;):&nbsp;Single;
<BR>function MCF_Dia_prod( MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax for the complex types (obsolete, but still supported):<font face="courier new">
<BR>procedure MCF_Dia_prod( var&nbsp;RetVal:fComplex; MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_prod( float&nbsp;*h_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMF_Dia_prod( float&nbsp;*d_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>float MFcu_Dia_prod( fMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd, MCFstd;
<BR>function cudaMF_Dia_prod( var&nbsp;h_RetVal:Single; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_prod( d_RetVal:PSingle; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_prod( h_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;Single;
<BR>function MCFcu_Dia_prod( h_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax for the complex types:<font face="courier new">
<BR>procedure MCFcu_Dia_prod( var&nbsp;h_RetVal:fComplex; h_MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>the product of the diagonal elements is returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>product of the diagonal elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_sum">MF_Dia_sum</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_sabsmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_sabsmax</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Dia_sabsmax</b></font></td>
<td><font size="+1"><b>MCE_Dia_sabsmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex number of largest sum |Re|&nbsp;+&nbsp;|Im| along the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
fComplex MCF_Dia_sabsmax( cfMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
<BR>complex&lt;T&gt; matrix&lt;complex&lt;T&gt;&gt;::Dia_sabsmax( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
<BR>function MCF_Dia_sabsmax( MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCF_Dia_sabsmax( var Max:fComplex; MA:cfMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Dia_sabsmax( fComplex&nbsp;*h_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMCF_Dia_sabsmax( fComplex&nbsp;*d_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>fComplex MCFcu_Dia_sabsmax( cfMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Dia_sabsmax( var&nbsp;h_RetVal:fComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMCF_Dia_sabsmax( d_RetVal:PfComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function MCFcu_Dia_sabsmax( h_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCFcu_Dia_sabsmax( var&nbsp;h_RetVal:fComplex; h_MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The complex number of largest sum |Re|&nbsp;+&nbsp;|Im|,  is found.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_sabsmin">MCF_Dia_sabsmin</a>,&nbsp;&nbsp; <a href="#Dia_absmax">MCF_Dia_absmax</a>,&nbsp;&nbsp; <a href="#Dia_maxReIm">MCF_Dia_maxReIm</a>,&nbsp;&nbsp; <a href="#Rows_sabsmax">MCF_Rows_sabsmax</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_sabsmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_sabsmin</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Dia_sabsmin</b></font></td>
<td><font size="+1"><b>MCE_Dia_sabsmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex number of smallest  sum |Re|&nbsp;+&nbsp;|Im| along the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
fComplex MCF_Dia_sabsmin( cfMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
<BR>complex&lt;T&gt; matrix&lt;complex&lt;T&gt;&gt;::Dia_sabsmin( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
<BR>function MCF_Dia_sabsmin( MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCF_Dia_sabsmin( var Max:fComplex; MA:cfMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Dia_sabsmin( fComplex&nbsp;*h_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMCF_Dia_sabsmin( fComplex&nbsp;*d_RetVal, cfMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>fComplex MCFcu_Dia_sabsmin( cfMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Dia_sabsmin( var&nbsp;h_RetVal:fComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMCF_Dia_sabsmin( d_RetVal:PfComplex; d_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function MCFcu_Dia_sabsmin( h_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax:<font face="courier new"><BR>
procedure MCFcu_Dia_sabsmin( var&nbsp;h_RetVal:fComplex; h_MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The complex number with the smallest  sum |Re|&nbsp;+&nbsp;|Im| is found.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_sabsmax">MCF_Dia_sabsmax</a>,&nbsp;&nbsp; <a href="#Dia_absmin">MCF_Dia_absmin</a>,&nbsp;&nbsp; <a href="#Dia_minReIm">MCF_Dia_minReIm</a>,&nbsp;&nbsp; <a href="#Rows_sabsmin">MCF_Rows_sabsmin</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_subC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_subC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_subC</b></font></td>
<td><font size="+1"><b>ME_Dia_subC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_subC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_subC</b></font></td>
<td><font size="+1"><b>MCE_Dia_subC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract a constant from all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_subC( fMatrix&nbsp;MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_subC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_subC( MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_subC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMF_Dia_subC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Dia_subC( fMatrix&nbsp;h_MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_subC( d_MA:fMatrix; len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_subC( d_MA:fMatrix; len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_subC( h_MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> -= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_subV">MF_Dia_subV</a>,&nbsp;&nbsp; <a href="#Dia_subrC">MF_Dia_subrC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_subrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_subrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_subrC</b></font></td>
<td><font size="+1"><b>ME_Dia_subrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_subrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_subrC</b></font></td>
<td><font size="+1"><b>MCE_Dia_subrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: a constant minus the elements of the diagonal of a square matrix, storing the result back into the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_subrC( fMatrix&nbsp;MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_subrC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_subrC( MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_subrC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMF_Dia_subrC( fMatrix&nbsp;d_MA, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Dia_subrC( fMatrix&nbsp;h_MA, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_subrC( d_MA:fMatrix; len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_subrC( d_MA:fMatrix; len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_subrC( h_MA:fMatrix; len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = C - MA<sub>i,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_subrV">MF_Dia_subrV</a>,&nbsp;&nbsp; <a href="#Dia_subC">MF_Dia_subC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_subrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_subrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_subrV</b></font></td>
<td><font size="+1"><b>ME_Dia_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_subrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_subrV</b></font></td>
<td><font size="+1"><b>MCE_Dia_subrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: subtract the elements of the diagonal of a square matrix from corresponding elements of a vector, storing the result back into the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_subrV( fMatrix&nbsp;MA, ui&nbsp;len, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_subrV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_subrV( MA:fMatrix; len:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_subrV( fMatrix&nbsp;d_MA, ui&nbsp;len, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Dia_subrV( fMatrix&nbsp;h_MA, ui&nbsp;len, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_subrV( d_MA:fMatrix; len:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_subrV( h_MA:fMatrix; len:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = X<sub>i</sub> - MA<sub>i,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_subV">MF_Dia_subV</a>,&nbsp;&nbsp; <a href="#Dia_subrC">MF_Dia_subrC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_subV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_subV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_subV</b></font></td>
<td><font size="+1"><b>ME_Dia_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_subV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_subV</b></font></td>
<td><font size="+1"><b>MCE_Dia_subV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise subtraction of a vector from the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_subV( fMatrix&nbsp;MA, ui&nbsp;len, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Dia_subV( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_subV( MA:fMatrix; len:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_subV( fMatrix&nbsp;d_MA, ui&nbsp;len, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Dia_subV( fMatrix&nbsp;h_MA, ui&nbsp;len, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Dia_subV( d_MA:fMatrix; len:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_subV( h_MA:fMatrix; len:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> -= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_subrV">MF_Dia_subrV</a>,&nbsp;&nbsp; <a href="#Dia_subC">MF_Dia_subC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_sum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_sum</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_sum</b></font></td>
<td><font size="+1"><b>ME_Dia_sum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_sum</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_sum</b></font></td>
<td><font size="+1"><b>MCE_Dia_sum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>sum over all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_Dia_sum( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T matrix&lt;T&gt;::Dia_sum();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Dia_sum( MA:fMatrix; len:UIntSize&nbsp;):Single;
<BR>function MCF_Dia_sum( MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax for the complex types:<font face="courier new">
<BR>procedure MCF_Dia_sum( var&nbsp;RetVal:fComplex; MA:cfMatrix; len:UIntSize&nbsp;);
</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Dia_sum( float&nbsp;*h_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>int cusdMF_Dia_sum( float&nbsp;*d_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>float MFcu_Dia_sum( fMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd, MCFstd;
<BR>function cudaMF_Dia_sum( var&nbsp;h_RetVal:Single; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Dia_sum( d_RetVal:PSingle; d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Dia_sum( h_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;Single;
<BR>function MCFcu_Dia_sum( h_MA:cfMatrix; len:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax for the complex types:<font face="courier new">
<BR>procedure MCFcu_Dia_sum( var&nbsp;h_RetVal:fComplex; h_MA:cfMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>the elements of the diagonal are summed up and returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum over the diagonal elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_prod">MF_Dia_prod</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="divC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_divC</b></font>
</td><td width="33%"><font size="+1"><b>MD_divC</b></font></td>
<td><font size="+1"><b>ME_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_divC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_divC</b></font></td>
<td><font size="+1"><b>MCE_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_divReC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_divReC</b></font></td>
<td><font size="+1"><b>MCE_divReC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>divide all matrix elements by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_divC( fMatrix&nbsp;MB, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::divC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_divC( MB,&nbsp;MA:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_divC( fMatrix&nbsp;d_MB, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMF_divC( fMatrix&nbsp;d_MB, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_divC( fMatrix&nbsp;h_MB, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_divC( d_MB,&nbsp;d_MA:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_divC( d_MB,&nbsp;d_MA:fMatrix; ht,&nbsp;len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_divC( h_MB,&nbsp;h_MA:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>M<sub>i,j</sub> /= C,&nbsp;&nbsp;i=0,...,ht-1;&nbsp;&nbsp;j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulC">MF_mulC</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="DtoF"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>M_DtoF</b></font></td><td><font size="+1"><b>M_DtoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type conversions. See <I><a href="#FtoD">M_FtoD</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="eigenvalues"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFsym_eigenvalues</b></font>
</td><td width="33%"><font size="+1"><b>MDsym_eigenvalues</b></font></td>
<td><font size="+1"><b>MEsym_eigenvalues</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Eigenvalues and/or Eigenvectors of a real symmetric matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MFsym_eigenvalues( fVector&nbsp;EigVals, fMatrix EigVecs, fMatrix&nbsp;MA, ui&nbsp;len, int&nbsp;CalcEigenVec&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
int matrix&lt;T&gt;::sym_eigenvalues( matrix&lt;T&gt; EigVecs, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, int&nbsp;CalcEigenVec&nbsp;);<BR>
int matrix&lt;T&gt;::sym_eigenvalues( matrix&lt;T&gt;*&nbsp;EigVecs, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, int&nbsp;CalcEigenVec&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MFsym_eigenvalues( EigVals:fVector; EigVecs, MA:fMatrix; len:UIntSize; CalcEigenVec:IntBool&nbsp;): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The eigenvalues, with or without the eigenvectors, of MA are calculated. This function is for non-singular symmetric real matrices only! It takes the following arguments:
<UL><LI>EigVals: a vector in which the eigenvalues will be returned
<LI>EigVecs: a matrix whose columns will be filled with the eigenvectors
<LI>MA: the input matrix, which may or may not be overwritten by EigVecs
<LI>len: the length of the rows (which is the same as the height of the columns, as MA must be a symmetric square matrix)
<LI>CalcEigenVec: an int&nbsp;or IntBool, deciding if only the eigenvalues are needed (CalcEigenVec = FALSE or 0), or if the eigenvectors are desired as well (CalcEigenVec = TRUE or 1). Calculating the eigenvalues alone, without the eigenvectors, can speed up the calculation by up to a factor of two.
</UL></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">chapter&nbsp;10</a>,&nbsp;&nbsp; <a href="#chap11">chapter&nbsp;11</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="element"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_element</b></font>
</td><td width="33%"><font size="+1"><b>MD_element</b></font></td>
<td><font size="+1"><b>ME_element</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_element</b></font></td>
<td width="33%"><font size="+1"><b>MCD_element</b></font></td>
<td><font size="+1"><b>MCE_element</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_element</b></font></td><td width="20%"><font size="+1"><b>MBI_element</b></font></td><td width="20%"><font size="+1"><b>MSI_element</b></font></td><td width="20%"><font size="+1"><b>MLI_element</b></font></td><td><font size="+1"><b>MQI_element</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_element</b></font></td><td width="20%"><font size="+1"><b>MUB_element</b></font></td><td width="20%"><font size="+1"><b>MUS_element</b></font></td><td width="20%"><font size="+1"><b>MUL_element</b></font></td><td><font size="+1"><b>MUQ_element</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>read-only access to a matrix element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_element( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n&nbsp;);<BR>
fComplex MCF_element( cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T matrix&lt;T&gt;::element( const&nbsp;unsigned&nbsp;m, const&nbsp;unsigned&nbsp;n&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_element( MA:fMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize&nbsp;):&nbsp;Single;<BR>
function MCF_element( MA:cfMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax for the complex types (obsolete, but still supported):<font face="courier new"><BR>
procedure MCF_element( var&nbsp;RetVal:fComplex; MA:cfMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>float&nbsp;cudaMF_element( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_element( d_MA:fMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize&nbsp;):&nbsp;Single;<BR>
function cudaMCF_element( d_MA:cfMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize&nbsp;):&nbsp;fComplex;</font>
<BR>Alternative syntax for the complex types:<font face="courier new"><BR>
procedure cudaMCF_element( var&nbsp;RetVal:fComplex; MA:cfMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The element MA<sub>m,n</sub> is returned.
<BR><i>MF_element</i> is &quot;read-only&quot;. This means, you c&nbsp;a&nbsp;n&nbsp;n&nbsp;o&nbsp;t write something like
<BR><font face="courier new">MF_element( MX, ht,&nbsp;len,&nbsp;3, 4&nbsp;) := 5;</font><BR>
Write access to individual matrix elements is provided by <I><a href="#setElement">MF_setElement</a></I> and <I><a href="#Pelement">MF_Pelement</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the matrix element m,n (except complex version in Pascal/Delphi)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setElement">MF_setElement</a>,&nbsp;&nbsp; <a href="#Pelement">MF_Pelement</a>,&nbsp;&nbsp; <a href="#chap2">chapter&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="equ0"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_equ0</b></font>
</td><td width="33%"><font size="+1"><b>MD_equ0</b></font></td>
<td><font size="+1"><b>ME_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_equ0</b></font></td>
<td width="33%"><font size="+1"><b>MCD_equ0</b></font></td>
<td><font size="+1"><b>MCE_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_equ0</b></font></td><td width="20%"><font size="+1"><b>MBI_equ0</b></font></td><td width="20%"><font size="+1"><b>MSI_equ0</b></font></td><td width="20%"><font size="+1"><b>MLI_equ0</b></font></td><td><font size="+1"><b>MQI_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_equ0</b></font></td><td width="20%"><font size="+1"><b>MUB_equ0</b></font></td><td width="20%"><font size="+1"><b>MUS_equ0</b></font></td><td width="20%"><font size="+1"><b>MUL_equ0</b></font></td><td><font size="+1"><b>MUQ_equ0;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize a matrix with all elements set to 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_equ0( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::equ0(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_equ0( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_equ0( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_equ0( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_equ0( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_equ0( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#equ1">MF_equ1</a>,&nbsp;&nbsp; <a href="#equM">MF_equM</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="equ1"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_equ1</b></font>
</td><td width="33%"><font size="+1"><b>MD_equ1</b></font></td>
<td><font size="+1"><b>ME_equ1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_equ1</b></font></td>
<td width="33%"><font size="+1"><b>MCD_equ1</b></font></td>
<td><font size="+1"><b>MCE_equ1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_equ1</b></font></td><td width="20%"><font size="+1"><b>MBI_equ1</b></font></td><td width="20%"><font size="+1"><b>MSI_equ1</b></font></td><td width="20%"><font size="+1"><b>MLI_equ1</b></font></td><td><font size="+1"><b>MQI_equ1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_equ1</b></font></td><td width="20%"><font size="+1"><b>MUB_equ1</b></font></td><td width="20%"><font size="+1"><b>MUS_equ1</b></font></td><td width="20%"><font size="+1"><b>MUL_equ1</b></font></td><td><font size="+1"><b>MUQ_equ1</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>identity matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_equ1( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;); </font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::equ1(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_equ1( MA:fMatrix; len:UIntSize&nbsp;); </font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_equ1( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_equ1( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_equ1( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_equ1( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = 1<BR>
MA<sub>i,j</sub> = 0,&nbsp;&nbsp;i != j</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#equ0">MF_equ0</a>,&nbsp;&nbsp; <a href="#equm1">MF_equm1</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="equM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_equM</b></font>
</td><td width="33%"><font size="+1"><b>MD_equM</b></font></td>
<td><font size="+1"><b>ME_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_equM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_equM</b></font></td>
<td><font size="+1"><b>MCE_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_equM</b></font></td><td width="20%"><font size="+1"><b>MBI_equM</b></font></td><td width="20%"><font size="+1"><b>MSI_equM</b></font></td><td width="20%"><font size="+1"><b>MLI_equM</b></font></td><td><font size="+1"><b>MQI_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_equM</b></font></td><td width="20%"><font size="+1"><b>MUB_equM</b></font></td><td width="20%"><font size="+1"><b>MUS_equM</b></font></td><td width="20%"><font size="+1"><b>MUL_equM</b></font></td><td><font size="+1"><b>MUQ_equM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one matrix the copy of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_equM( fMatrix&nbsp;MB, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::equM( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_equM( MB,&nbsp;MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_equM( fMatrix&nbsp;d_MB, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_equM( fMatrix&nbsp;h_MB, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>&nbsp;<BR>int cudaMF_equMhost( fMatrix&nbsp;d_MB, fMatrix&nbsp;h_NA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int MF_equMdevice( fMatrix&nbsp;h_MB, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_equM( d_MB,&nbsp;d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MF_equM( h_MB,&nbsp;h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);
<BR>&nbsp;<BR>function cudaMF_equMhost( d_MB,&nbsp;h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function MF_equMdevice( h_MB,&nbsp;d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>i,j</sub> = MA<sub>i,j</sub>
<P>CUDA versions: <i>cudaMF_equMhost</i> and <i>MF_equMdevice</i> transfer matrices from host to device memory and vice versa.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#transpose">MF_transpose</a>,&nbsp;&nbsp; <a href="#neg">MF_neg</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="equm1"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_equm1</b></font>
</td><td width="33%"><font size="+1"><b>MD_equm1</b></font></td>
<td><font size="+1"><b>ME_equm1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_equm1</b></font></td>
<td width="33%"><font size="+1"><b>MCD_equm1</b></font></td>
<td><font size="+1"><b>MCE_equm1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_equm1</b></font></td><td width="20%"><font size="+1"><b>MBI_equm1</b></font></td><td width="20%"><font size="+1"><b>MSI_equm1</b></font></td><td width="20%"><font size="+1"><b>MLI_equm1</b></font></td><td><font size="+1"><b>MQI_equm1</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>negative identity matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_equm1( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;); </font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::equm1(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_equm1( MA:fMatrix; len:UIntSize&nbsp;); </font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_equm1( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_equm1( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_equm1( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_equm1( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = -1<BR>
MA<sub>i,j</sub> = 0,&nbsp;&nbsp;i != j</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#equ0">MF_equ0</a>,&nbsp;&nbsp; <a href="#equm1">MF_equ1</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="equMblock"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_equMblock</b></font>
</td><td width="33%"><font size="+1"><b>MD_equMblock</b></font></td>
<td><font size="+1"><b>ME_equMblock</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_equMblock</b></font></td>
<td width="33%"><font size="+1"><b>MCD_equMblock</b></font></td>
<td><font size="+1"><b>MCE_equMblock</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_equMblock</b></font></td><td width="20%"><font size="+1"><b>MBI_equMblock</b></font></td><td width="20%"><font size="+1"><b>MSI_equMblock</b></font></td><td width="20%"><font size="+1"><b>MLI_equMblock</b></font></td><td><font size="+1"><b>MQI_equMblock</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_equMblock</b></font></td><td width="20%"><font size="+1"><b>MUB_equMblock</b></font></td><td width="20%"><font size="+1"><b>MUS_equMblock</b></font></td><td width="20%"><font size="+1"><b>MUL_equMblock</b></font></td><td><font size="+1"><b>MUQ_equMblock;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extract a block from a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void  MF_equMblock( fMatrix&nbsp;MSub,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;subHt,   ui&nbsp;subLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;MSrce,  ui&nbsp;srceHt,  ui&nbsp;srceLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::equMblock( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MSrce, const&nbsp;ui&nbsp;firstRow,  const&nbsp;ui&nbsp;firstCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_equMblock( MSub:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subHt, subLen: UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSrce:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srceHt, srceLen, firstRow, firstCol:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_equMblock( fMatrix&nbsp;d_MSub,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;subHt,   ui&nbsp;subLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;d_MSrce,  ui&nbsp;srceHt,  ui&nbsp;srceLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol&nbsp;);
<BR>void MFcu_equMblock( fMatrix&nbsp;h_MSub,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;subHt,   ui&nbsp;subLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;h_MSrce,  ui&nbsp;srceHt,  ui&nbsp;srceLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_equMblock( d_MSub:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subHt, subLen: UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d_MSrce:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srceHt, srceLen, firstRow, firstCol:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_equMblock( h_MSub:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subHt, subLen: UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h_MSrce:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srceHt, srceLen, firstRow, firstCol:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MSub<sub>i, j</sub> = MSrce<sub>i+firstRow, j+firstCol</sub>,&nbsp;&nbsp;i=0,...,subHt-1; &nbsp;j=0,...,subLen-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#block_equM">MF_block_equM</a>,&nbsp;&nbsp; <a href="#equMblockT">MF_equMblockT</a>,&nbsp;&nbsp; <a href="#submatrix_equM">MF_submatrix_equM</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="equMblockT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_equMblockT</b></font>
</td><td width="33%"><font size="+1"><b>MD_equMblockT</b></font></td>
<td><font size="+1"><b>ME_equMblockT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_equMblockT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_equMblockT</b></font></td>
<td><font size="+1"><b>MCE_equMblockT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_equMblockT</b></font></td><td width="20%"><font size="+1"><b>MBI_equMblockT</b></font></td><td width="20%"><font size="+1"><b>MSI_equMblockT</b></font></td><td width="20%"><font size="+1"><b>MLI_equMblockT</b></font></td><td><font size="+1"><b>MQI_equMblockT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_equMblockT</b></font></td><td width="20%"><font size="+1"><b>MUB_equMblockT</b></font></td><td width="20%"><font size="+1"><b>MUS_equMblockT</b></font></td><td width="20%"><font size="+1"><b>MUL_equMblockT</b></font></td><td><font size="+1"><b>MUQ_equMblockT;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extract and transpose a block from a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void  MF_equMblockT( fMatrix&nbsp;MSub,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;subHt,   ui&nbsp;subLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;MSrce,  ui&nbsp;srceHt,  ui&nbsp;srceLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::equMblockT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MSrce, const&nbsp;ui&nbsp;firstRow,  const&nbsp;ui&nbsp;firstCol&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_equMblockT( MSub:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subHt, subLen: UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSrce:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srceHt, srceLen, firstRow, firstCol:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_equMblockT( fMatrix&nbsp;d_MSub,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;subHt,   ui&nbsp;subLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;d_MSrce,  ui&nbsp;srceHt,  ui&nbsp;srceLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol&nbsp;);
<BR>void MFcu_equMblockT( fMatrix&nbsp;h_MSub,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;subHt,   ui&nbsp;subLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMatrix&nbsp;h_MSrce,  ui&nbsp;srceHt,  ui&nbsp;srceLen,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ui&nbsp;firstRow,  ui&nbsp;firstCol&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_equMblockT( d_MSub:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subHt, subLen: UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d_MSrce:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srceHt, srceLen, firstRow, firstCol:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_equMblockT( h_MSub:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subHt, subLen: UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h_MSrce:fMatrix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srceHt, srceLen, firstRow, firstCol:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MSub<sub>j, i</sub> = MSrce<sub>i+firstRow, j+firstCol</sub>,&nbsp;&nbsp;i=0,...,subLen-1; &nbsp;j=0,...,subHt-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#block_equMT">MF_block_equMT</a>,&nbsp;&nbsp; <a href="#equMblock">MF_equMblock</a>,&nbsp;&nbsp; <a href="#submatrix_equM">MF_submatrix_equM</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="FFT"></a><a name="FFTtoC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MD_FFT</b></font></td>
<td><font size="+1"><b>ME_FFT</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>MFb_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MDb_FFT</b></font></td>
<td><font size="+1"><b>MEb_FFT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_FFTtoC</b></font>
</td><td width="33%"><font size="+1"><b>MD_FFTtoC</b></font></td>
<td><font size="+1"><b>ME_FFTtoC</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>MFb_FFTtoC</b></font>
</td><td width="33%"><font size="+1"><b>MDb_FFTtoC</b></font></td>
<td><font size="+1"><b>MEb_FFTtoC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_FFT</b></font></td>
<td><font size="+1"><b>MCE_FFT</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>MCFb_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MCDb_FFT</b></font></td>
<td><font size="+1"><b>MCEb_FFT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>two-dimensional Fast Fourier Transform</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_FFT( fMatrix&nbsp;MY, fMatrix&nbsp;MX, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MCF_FFT( cfMatrix&nbsp;MY, cfMatrix&nbsp;MX, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MF_FFTtoC( cfMatrix&nbsp;MY, fMatrix&nbsp;MX, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MFb_FFT( fMatrix&nbsp;MY, fMatrix&nbsp;MX, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir, fVector&nbsp;Buf&nbsp;);<BR>
void MCFb_FFT( cfMatrix&nbsp;MY, cfMatrix&nbsp;MX, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir, cfVector&nbsp;Buf&nbsp;);<BR>
void MFb_FFTtoC( cfMatrix&nbsp;MY, fMatrix&nbsp;MX, ui&nbsp;ht, ui&nbsp;len, cfVector&nbsp;Buf&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::FFT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, int&nbsp;dir&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::FFT( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MX, int&nbsp;dir&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::FFTtoC( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX&nbsp;);<br>
void matrix&lt;T&gt;::b_FFT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, int&nbsp;dir, vector&lt;T&gt;&amp;&nbsp;Buf&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::b_FFT( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&nbsp;MX, int&nbsp;dir, vector&lt;complex&lt;T&gt;&nbsp;&gt;&amp;Buf&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::b_FFTtoC( const&nbsp;matrix&lt;T&gt;&nbsp;MX, vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Buf&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_FFT( MY,&nbsp;MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MCF_FFT( MY,&nbsp;MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MF_FFTtoC( MY:cfMatrix; MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<br>
procedure MFb_FFT( MY,&nbsp;MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer; Buf:fVector&nbsp;);<BR>
procedure MCFb_FFT( MY,&nbsp;MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer; Buf:cfVector&nbsp;);<BR>
procedure MFb_FFTtoC( MY:cfMatrix; MX:fMatrix; ht,&nbsp;len:UIntSize; Buf:cfVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_FFT( fMatrix&nbsp;d_MY, fMatrix&nbsp;d_MX, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
int cudaMCF_FFT( cfMatrix&nbsp;d_MY, cfMatrix&nbsp;d_MX, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
int cudaMF_FFTtoC( cfMatrix&nbsp;d_MY, fMatrix&nbsp;d_MX, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MFcu_FFT( fMatrix&nbsp;h_MY, fMatrix&nbsp;h_MX, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MCFcu_FFT( cfMatrix&nbsp;h_MY, cfMatrix&nbsp;h_MX, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MFcu_FFTtoC( cfMatrix&nbsp;h_MY, fMatrix&nbsp;h_MX, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_FFT( d_MY,&nbsp;d_MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
function cudaMCF_FFT( d_MY,&nbsp;d_MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
function cudaMF_FFTtoC( d_MY:cfMatrix; d_MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<br>
procedure MFcu_FFT( h_MY,&nbsp;h_MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MCFcu_FFT( h_MY,&nbsp;h_MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MFcu_FFTtoC( h_MY:cfMatrix; h_MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<br></font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The Fourier transform of MX is calculated and stored in MY. The forward transform is obtained by setting dir = 1, the inverse (or backward) transform by setting dir = -1. By convention, the inverse transform involves scaling the result by the factor <I>1.0/(ht*len)</I>. Since it is sometimes desirable to skip this implicit scaling, <I>MF_FFT</I> offers the possibility to do so: specify dir = -2 in this case.
<BR>A Fast Fourier Transform algorithm is used that requires both ht and len to be powers of 2.
<BR>Complex version: Both MX and the output MY are complex matrices.
<BR>Real-to-complex version: The input matrix MX is real. The output matrix MY is complex. As this function can only perform a forward transform, no argument &quot;dir&quot; is needed.
<BR>Purely real version: For the forward transform, MX is a real matrix. The output MY is also defined as fMatrix, although it consists of complex numbers. The reason is that, just as in the one-dimensional case, the symmetry properties of two-dimensional FFT allow to store the result in a packed format, fitting into the same memory space as the input matrix. The order of storage in MY is derived from the ordering in the one-dimensional case, with the packing applied first to all rows, then to the columns. The resulting order is indicated in the following table. U means the uncompressed result.
<table border width="100%">
<tr valign="top"><td>U<sub>0,0</sub>.Re</td><td>U<sub>0,len/2</sub>.Re</td><td>U<sub>0,1</sub>.Re</td><td>U<sub>0,1</sub>.Im</td><td>&#183;&#183;&#183;</td><td>U<sub>0,len/2-1</sub>.Re</td><td>U<sub>0,len/2-1</sub>.Im</td></tr>
<tr valign="top"><td>U<sub>ht/2,0</sub>.Re</td><td>U<sub>ht/2,len/2</sub>.Re</td><td>U<sub>1,1</sub>.Re</td><td>U<sub>1,1</sub>.Im</td><td>&#183;&#183;&#183;</td><td>U<sub>1,len/2-1</sub>.Re</td><td>U<sub>1,len/2-1</sub>.Im</td></tr>
<tr valign="top"><td>U<sub>1,0</sub>.Re</td><td>U<sub>1,len/2</sub>.Re</td><td>U<sub>2,1</sub>.Re</td><td>U<sub>2,1</sub>.Im</td><td>&#183;&#183;&#183;</td><td>U<sub>2,len/2-1</sub>.Re</td><td>U<sub>2,len/2-1</sub>.Im</td></tr>
<tr valign="top"><td>U<sub>1,0</sub>.Im</td><td>U<sub>1,len/2</sub>.Im</td><td>U<sub>3,1</sub>.Re</td><td>U<sub>3,1</sub>.Im</td><td>&#183;&#183;&#183;</td><td>U<sub>3,len/2-1</sub>.Re</td><td>U<sub>3,len/2-1</sub>.Im</td></tr>
<tr valign="top"><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td></tr>
<tr valign="top"><td>U<sub>ht/2-1,0</sub>.Re</td><td>U<sub>ht/2-1,len/2</sub>.Re</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td></tr>
<tr valign="top"><td>U<sub>ht/2-1,0</sub>.Im</td><td>U<sub>ht/2-1,len/2</sub>.Im</td><td>U<sub>ht-1,1</sub>.Re</td><td>U<sub>ht-1,1</sub>.Im</td><td>&#183;&#183;&#183;</td><td>U<sub>ht-1,len/2-1</sub>.Re</td><td>U<sub>ht-1,len/2-1</sub>.Im</td></tr>
</table>&nbsp;
<BR>For inverse real-matrix FFT, the input matrix has to be of this packed-complex format, and you get a real matrix. If you prefer to get the result of forward FFT as a true complex matrix, use <I>MF_FFTtoC</I>.
<P><i>MFb_FFT, MFb_FFTtoC</i> and <i>MCFb_FFT</i> take a buffer vector <i>Buf</i> as an additional argument. They are slightly more efficient than the un-buffered versions. <i>Buf</i> must have (at least) the same size (ht*len) as MX and MY.
<P>For historical reasons, there exist additional special versions with the prefixes <I>MFp_, &nbsp;MFs_</I> and <I>MFl_</I>. They are deprecated and may be removed in future versions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either ht or len is not a power of 2, the program is aborted with the error message &quot;Size must be an integer power of 2&quot;.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_FFT">MF_Cols_FFT</a>,&nbsp;&nbsp; <a href="#Rows_FFT">MF_Rows_FFT</a>,&nbsp;&nbsp; <a href="#chap12">chapter&nbsp;12</a>,&nbsp;&nbsp; <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8 of HANDBOOK.HTM</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="filter"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_filter</b></font>
</td><td width="33%"><font size="+1"><b>MD_filter</b></font></td>
<td><font size="+1"><b>ME_filter</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_filter</b></font></td>
<td width="33%"><font size="+1"><b>MCD_filter</b></font></td>
<td><font size="+1"><b>MCE_filter</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Spatial frequency filtering</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_filter( fMatrix&nbsp;MY, fMatrix&nbsp;MX, fMatrix&nbsp;MFlt, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::filter( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MFlt&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_filter( MY,&nbsp;MX,&nbsp;MFlt:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_filter( fMatrix&nbsp;d_MY, fMatrix&nbsp;d_MX, fMatrix&nbsp;d_MFlt, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_filter( fMatrix&nbsp;h_MY, fMatrix&nbsp;h_MX, fMatrix&nbsp;h_MFlt, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_filter( d_MY,&nbsp;d_MX,&nbsp;d_MFlt:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_filter( h_MY,&nbsp;h_MX,&nbsp;h_MFlt:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A spatial frequency filter MFlt is applied to the matrix MX. Internally, this is done by performing a Fourier transform on MX, multiplying the transform with MFlt and transforming the product back into the space domain.
<P>Complex versions: MX, MY and the filter MFlt are complex matrices.
<BR>Real versions: MX and MY are real. MFlt has to be in the packed complex format that is obtained by Fourier transforming a real matrix with <I><a href="#FFT">MF_FFT</a></I> (see that function for the description of the packed complex format) or by using <I><a href="#convolve">MF_convolve</a></I>.
<P>If MX is non-periodic, the edges of the filtered function may be spoiled by wrap-around. See <I><a href="FUNCREF.HTM#convolve">VF_convolve</a></I> about how to avoid end-effects. As described there for vectors, embed the matrix MX in a larger matrix or remove a possible linear trends in both dimensions.
<BR>About special versions with the prefixes <i>VFs_</i> and <I>VFl_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either ht or len is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>MF_filter</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">MF_convolve</a>,&nbsp;&nbsp; <a href="#chap12">chapter&nbsp;12</a>,&nbsp;&nbsp; <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8 of HANDBOOK.HTM</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="findDensityMapBounds"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="90%"><font size="+1"><b>M_findDensityMapBounds</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculate a color scale and draw an X-Y coordinate system for matrix color-density plots</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void M_findDensityMapBounds( extended xmin, extended xmax, extended ymin, extended ymax, extended zmin, extended zmax, COLORREF&nbsp;mincolor, COLORREF&nbsp;maxcolor&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure M_findDensityMapBounds( xmin, xmax, ymin, ymax, zmin, zmax: Extended; mincolor, maxcolor: COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Similarly to the function <I><a href="FUNCREF.HTM#findAxes">V_findAxes</a></I> for X-Y vector plots, this function calculates a color scale from the parameters mincolor, maxcolor, zmin and zmax, and prepares an X-Y coordinate system for color-density plots of matrices. If necessary, the <I>x</I> and <I>y</I> ranges are slightly enlarged so as to ensure that the grid-lines correspond to exact (rather than only rounded) values. If zero falls into either or both ranges, it will fall onto a grid line. 
<P>The user will rarely call this function himself. It is internally called by all functions of the <I><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a></I> and <I><a href="#zAutoDensityMap">MF_zAutoDensityMap</a></I> families.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>,&nbsp;&nbsp; <a href="#zAutoDensityMap">MF_zAutoDensityMap</a>,&nbsp;&nbsp; <a href="#chap15">chapter&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="fprint"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_fprint</b></font>
</td><td width="33%"><font size="+1"><b>MD_fprint</b></font></td>
<td><font size="+1"><b>ME_fprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_fprint</b></font></td>
<td width="33%"><font size="+1"><b>MCD_fprint</b></font></td>
<td><font size="+1"><b>MCE_fprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_fprint</b></font></td><td width="20%"><font size="+1"><b>MBI_fprint</b></font></td><td width="20%"><font size="+1"><b>MSI_fprint</b></font></td><td width="20%"><font size="+1"><b>MLI_fprint</b></font></td><td><font size="+1"><b>MQI_fprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_fprint</b></font></td><td width="20%"><font size="+1"><b>MUB_fprint</b></font></td><td width="20%"><font size="+1"><b>MUS_fprint</b></font></td><td width="20%"><font size="+1"><b>MUL_fprint</b></font></td><td><font size="+1"><b>MUQ_fprint</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>print a matrix in ASCII format to a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_fprint( FILE&nbsp;*stream, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned linewidth&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::fprint( FILE *stream, unsigned linewidth&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_fprint( var&nbsp;Stream:TextFile; MA:fMatrix; ht,&nbsp;len:UIntSize; linewidth:UInt&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_fprint( FILE&nbsp;*stream, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMF_fprint_buf( FILE&nbsp;*stream, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_fprint( var&nbsp;Stream:TextFile; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;<BR>function cudaMF_fprint_buf( var&nbsp;Stream:TextFile; d_MA:fMatrix; ht,&nbsp;len:UIntSize; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA is written to stream. Each line corresponds to one row of the matrix. The lines are numbered. If the specified linewidth is too small to write all columns, rows are cut off.
<BR>Printing starts always with a new line. This may lead to an empty line at the beginning. Especially the first line of a file is reserved for a possible headline.
<BR>Cartesian complex numbers are printed in braces, with the real and imaginary parts separated by a komma: {Re, Im}.<P>In contrast to <I><a href="#write">MF_write</a></I>, it is not possible to override the automatic choice of the format used for printing. The number of digits per element is determined by the available space, which depends in turn on the parameters len and linewidth.
</td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If <i>len</i> exceeds the maximum number of entries possible for the <i>linewidth</i> chosen, an error message &quot;Cannot use requested format (too many entries per line)!&quot; is generated; in this case, the program truncates the rows at the maximum number of columns possible.
<P>CUDA versions only: <i>cudaM?_fprint_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as d_MA, i.e. ht*len. By avoiding the need of <i>cudaM?_fprint</i> to allocate its own buffer memory, <i>cudaM?_fprint_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#cprint">MF_cprint</a>,&nbsp;&nbsp; <a href="#chap14">chapter&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="free"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="90%"><font size="+1"><b>M_free</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>de-allocate a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void M_free( void **M&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::free();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure M_free( M:Pointer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMatLib.h&gt;
<BR>int cudaM_free( void **d_M&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaM_free( d_M:Pointer&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix M is freed (i.e. de-allocated). <I>M_free</I> should be used only for the de-allocation of matrices which have previously be allocated by one of the functions of the <I><a href="#matrix">MF_matrix</a></I> or <I><a href="#matrix0">MF_matrix0</a></I> family. To free several matrices simultaneously, use <I><a href="#nfree">M_nfree</a></I> (C/C++ only). To free all allocated vectors and matrices simultaneously, call <I><a href="FUNCREF.HTM#freeAll">V_freeAll</a></I>.
</td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Trying to free a matrix that has already been freed, or that has never been allocated memory, leads to a warning message &quot;Cannot free non-existent vector&quot;. Program execution is continued without freeing anything in this case.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#nfree">M_nfree</a></I>,&nbsp;&nbsp;<I><a href="FUNCREF.HTM#freeAll">V_freeAll</a></I>,&nbsp;&nbsp; <I><a href="#pinnedFree">cudaM_pinnedFree</a></I>,&nbsp;&nbsp; <I><a href="#matrix">MF_matrix</a></I>,&nbsp;&nbsp; <I><a href="#matrix0">MF_matrix0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="FtoD"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>M_FtoD</b></font></td><td width="25%"><font size="+1"><b>M_FtoE</b></font></td><td width="25%"><font size="+1"><b>M_CFtoCD</b></font></td><td><font size="+1"><b>M_CFtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>M_DtoF</b></font></td><td width="25%"><font size="+1"><b>M_DtoE</b></font></td><td width="25%"><font size="+1"><b>M_CDtoCF</b></font></td><td><font size="+1"><b>M_CDtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>M_EtoF</b></font></td><td width="25%"><font size="+1"><b>M_EtoD</b></font></td><td width="25%"><font size="+1"><b>M_CEtoCF</b></font></td><td><font size="+1"><b>M_CEtoCD</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type interconversions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MDstd.h&gt;</font><BR>
&nbsp;&nbsp;&nbsp;&nbsp;(always include the <font face="courier new">&lt;M..std.h&gt;</font> file of the destination data-type!)<br><font face="courier new">
void M_FtoD( dMatrix&nbsp;MY, fMatrix&nbsp;MX, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font><BR>
&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void matrix&lt;double&gt;::FtoD( const&nbsp;matrix&lt;float&gt;&amp;&nbsp;MX&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MDstd;</font><BR>
&nbsp;&nbsp;&nbsp;&nbsp;(always include the unit of the destination data-type!)<BR><font face="courier new">
procedure M_FtoD( MY:dMatrix; MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font><BR>
&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMDstd.h&gt;
<BR>int cudaM_FtoD( dMatrix&nbsp;d_MY, fMatrix&nbsp;d_MX, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void Mcu_FtoD( dMatrix&nbsp;h_MY, fMatrix&nbsp;h_MX, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MDstd;
<BR>function cudaM_FtoD( d_MY:dMatrix; d_MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure Mcu_FtoD( h_MY:dMatrix; h_MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of MX is converted from the data type specified for MX to the data type specified for MY and stored in MY.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors may occur in the course of the &quot;down-conversions&quot; (e.g., <I>M_EtoF</I>); by default, the extreme value possible for the destination data type is stored in MY with the correct sign.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap4">chapter&nbsp;4</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="getElement"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_getElement</b></font>
</td><td width="33%"><font size="+1"><b>MD_getElement</b></font></td>
<td><font size="+1"><b>ME_getElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_getElement</b></font></td>
<td width="33%"><font size="+1"><b>MCD_getElement</b></font></td>
<td><font size="+1"><b>MCE_getElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_getElement</b></font></td><td width="20%"><font size="+1"><b>MBI_getElement</b></font></td><td width="20%"><font size="+1"><b>MSI_getElement</b></font></td><td width="20%"><font size="+1"><b>MLI_getElement</b></font></td><td><font size="+1"><b>MQI_getElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_getElement</b></font></td><td width="20%"><font size="+1"><b>MUB_getElement</b></font></td><td width="20%"><font size="+1"><b>MUS_getElement</b></font></td><td width="20%"><font size="+1"><b>MUL_getElement</b></font></td><td><font size="+1"><b>MUQ_getElement</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>read-only access to a matrix element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void&nbsp;MF_getElement( float&nbsp;*RetVal, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n&nbsp;);<BR>
void&nbsp;MCF_getElement( fComplex&nbsp;*RetVal, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::getElement( T*RetVal, const&nbsp;unsigned&nbsp;m, const&nbsp;unsigned&nbsp;n&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_getElement( var RetVal:Single; MA:fMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize&nbsp;);<BR>
procedure MCF_getElement( var RetVal:fComplex; MA:cfMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>void&nbsp;cudaMF_getElement( float *h_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n&nbsp;);
<BR>void&nbsp;cusdMF_getElement( float *d_RetVal, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>procedure cudaMF_getElement( var h_RetVal:Single; d_MA:fMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize&nbsp;);<BR>
<BR>procedure cusdMF_getElement( d_RetVal:PSingle; d_MA:fMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The element MA<sub>m,n</sub> is copied into the location specified as RetVal.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setElement">MF_setElement</a>,&nbsp;&nbsp; <a href="#Pelement">MF_Pelement</a>,&nbsp;&nbsp; <a href="#chap2">chapter&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="getLinfitNeglect"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_getLinfitNeglect</b></font>
</td><td width="33%"><font size="+1"><b>VD_getLinfitNeglect</b></font></td>
<td><font size="+1"><b>VE_getLinfitNeglect</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>retrieve the current significance threshold for data fitting to linear models</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;VF_getLinfitNeglect( void&nbsp;);</font></td></tr>
<tr><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T vector&lt;T&gt;::getLinfitNeglect();<BR>
T matrix&lt;T&gt;::getLinfitNeglect();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function VF_getLinfitNeglect:Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Internally, the linear-fitting functions like <I><a href="#linfit">VF_linfit</a></I> employ a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, <I>Thresh</I>, are set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by <I>VF_getLinfitNeglect</I>.
<BR>In the C++ <I>MatObj</I> version, this function takes only the data type from the matrix as whose member function it is called, but has nothing specific to do with it otherwise.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>current significance threshold for linear fitting</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="#multiLinfit">VF_multiLinfit</a>,&nbsp;&nbsp; <a href="#chap13_2">chapter&nbsp;13.2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="getNonlinfitOptions"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_getNonlinfitOptions</b></font>
</td><td width="33%"><font size="+1"><b>VD_getNonlinfitOptions</b></font></td>
<td><font size="+1"><b>VE_getNonlinfitOptions</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>retrieve current set of options for nonlinear fitting</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_getNonlinfitOptions( VF_NONLINFITOPTIONS *Options&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_getNonlinfitOptions( var Options: VF_NONLINFITOPTIONS&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The nonlinear fitting routines like <I><a href="#nonlinfit">VF_nonlinfit</a></I> offer the user a lot of different options, packed into a structure <I><a href="#chap13_3NONLINFITOPTIONS">VF_NONLINFITOPTIONS</a></I> (<I>VD_NONLINFITOPTIONS</I> and <I>VE_NONLINFITOPTIONS</I> for the higher accuracy data-types). These options may be set by the function <I><a href="#setNonlinfitOptions">V_setNonlinfitOptions</a></I>. To retrieve current settings, use
<I>V_getNonlinfitOptions</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13_3">chapter&nbsp;13.3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Hann"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Hann</b></font>
</td><td width="33%"><font size="+1"><b>MD_Hann</b></font></td>
<td><font size="+1"><b>ME_Hann</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>two-dimensional Hann window for spatial frequency analysis</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Hann( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void matrix&lt;T&gt;::Hann();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Hann( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Hann( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Hann( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Hann( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Hann( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = 0.25 *&nbsp;(1 - cos( 2 <font face="symbol">p</font> i / (ht-1)&nbsp;)) *&nbsp;(1 - cos( 2 <font face="symbol">p</font> j / (len-1)&nbsp;))</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Parzen">MF_Parzen</a>,&nbsp;&nbsp; <a href="#Welch">MF_Welch</a>,&nbsp;&nbsp; <a href="#spectrum">MF_spectrum</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="hermconj"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_hermconj</b></font>
</td><td width="33%"><font size="+1"><b>MCD_hermconj</b></font></td>
<td><font size="+1"><b>MCE_hermconj</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hermitian conjugate of a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_hermconj( cfMatrix&nbsp;MTr, cfMatrix&nbsp;MA, ui&nbsp;htTr, ui&nbsp;lenTr&nbsp;);</font></td></tr>
<tr><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::hermconj( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_hermconj( MTr,&nbsp;MA:cfMatrix; htTr, lenTr:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_hermconj( cfMatrix&nbsp;d_MTr, cfMatrix&nbsp;d_MA, ui&nbsp;htTr, ui&nbsp;lenTr&nbsp;);
<BR>void MCFcu_hermconj( cfMatrix&nbsp;h_MTr, cfMatrix&nbsp;h_MA, ui&nbsp;htTr, ui&nbsp;lenTr&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_hermconj( d_MTr,&nbsp;d_MA:cfMatrix; htTr,&nbsp;lenTr:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_hermconj( h_MTr,&nbsp;h_MA:cfMatrix; htTr,&nbsp;lenTr:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The Hermitian conjugate of a complex matrix is defined as the complex conjugate of its transpose:<BR>
MTr<sub>i,j</sub> = MA<sub>j,i</sub><sup>*</sup>
<BR>The dimensions fed into this function, htTr and lenTr, refer to the transposed matrix rather than to the input matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#transpose">MCF_transpose</a>,&nbsp;&nbsp; <a href="#conj">MCF_conj</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="HmulM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_HmulM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_HmulM</b></font></td>
<td><font size="+1"><b>MCE_HmulM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply the hermitian conjugate of one matrix by another matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_HmulM( cfMatrix&nbsp;MC, cfMatrix&nbsp;MA, cfMatrix&nbsp;MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);</font></td></tr>
<tr><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::HmulM( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA, const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_HmulM( MC,&nbsp;MA,&nbsp;MB:cfMatrix; htA,&nbsp;lenA,&nbsp;lenB:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_HmulM( cfMatrix&nbsp;d_MC, cfMatrix&nbsp;d_MA, cfMatrix&nbsp;d_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);
<BR>void MCFcu_HmulM( cfMatrix&nbsp;h_MC, cfMatrix&nbsp;h_MA, cfMatrix&nbsp;h_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_HmulM( d_MC,&nbsp;d_MA,&nbsp;d_MB:cfMatrix; htA,&nbsp;lenA,&nbsp;lenB:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_HmulM( h_MC,&nbsp;h_MA,&nbsp;h_MB:cfMatrix; htA,&nbsp;lenA,&nbsp;lenB:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA<sup>T*</sup> *&nbsp;MB
<BR>htA,&nbsp;lenA,&nbsp;and lenB must be specified; the other dimensions are implicitly given as: htB = htA, lenC = lenB, htC = lenA. htA and lenA refer to the original, un-transposed input matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#hermconj">MCF_hermconj</a>,&nbsp;&nbsp; <a href="#mulMH">MCF_mulMH</a>,&nbsp;&nbsp; <a href="#TmulM">MF_TmulM</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="inv"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_inv</b></font>
</td><td width="33%"><font size="+1"><b>MD_inv</b></font></td>
<td><font size="+1"><b>ME_inv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_inv</b></font></td>
<td width="33%"><font size="+1"><b>MCD_inv</b></font></td>
<td><font size="+1"><b>MCE_inv</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>matrix inversion</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_inv( fMatrix&nbsp;Inv, fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::inv( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_inv( MInv, MA:fMatrix; len:UIntSize&nbsp;):IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The inverse of the matrix MA is stored in MInv. If MA is non-invertible, the function fails with an error message and returns TRUE (1). Internally, inversion is accomplished <I>via</I> LU decomposition. In order to prevent the function from failing, you can define a minimum pivot for the decomposition, using <I><a href="#LUDsetEdit">MF_LUDsetEdit</a></I>. In that case, any matrix is made invertible, and <I>MF_inv</I> returns always FALSE (0). Only a call to <I><a href="#LUDresult">MF_LUDresult</a></I> will tell you if editing has actually been necessary to avoid a singularity. If such a result is still useful, shall depend on your specific application.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LequU"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LequU</b></font>
</td><td width="33%"><font size="+1"><b>MD_LequU</b></font></td>
<td><font size="+1"><b>ME_LequU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LequU</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LequU</b></font></td>
<td><font size="+1"><b>MCE_LequU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_LequU</b></font></td><td width="20%"><font size="+1"><b>MBI_LequU</b></font></td><td width="20%"><font size="+1"><b>MSI_LequU</b></font></td><td width="20%"><font size="+1"><b>MLI_LequU</b></font></td><td><font size="+1"><b>MQI_LequU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_LequU</b></font></td><td width="20%"><font size="+1"><b>MUB_LequU</b></font></td><td width="20%"><font size="+1"><b>MUS_LequU</b></font></td><td width="20%"><font size="+1"><b>MUL_LequU</b></font></td><td><font size="+1"><b>MUQ_LequU;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy upper-diagonal elements into lower-diagonal by index-reflection, so as to get a symmetric matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_LequU( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::LequU(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_LequU( MA:fMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_LequU( fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>void MFcu_LequU( fMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_LequU( d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_LequU( h_MA:fMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = MA<sub>j,i</sub>,&nbsp;&nbsp;i &gt; j</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#UequL">MF_UequL</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="lincomb"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_lincomb</b></font>
</td><td width="33%"><font size="+1"><b>MD_lincomb</b></font></td>
<td><font size="+1"><b>ME_lincomb</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_lincomb</b></font></td>
<td width="33%"><font size="+1"><b>MCD_lincomb</b></font></td>
<td><font size="+1"><b>MCE_lincomb</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>linear combination of two matrices</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_lincomb( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;CA, float&nbsp;CB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::lincomb( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_lincomb( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize; CA,&nbsp;CB:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_lincomb( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;CA, float&nbsp;CB&nbsp;);
<BR>int cusdMF_lincomb( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;*d_CA, float&nbsp;*d_CB&nbsp;);
<BR>void MFcu_lincomb( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;CA, float&nbsp;CB&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_lincomb( d_MC,&nbsp;d_MA,&nbsp;d_MB:fMatrix; ht,&nbsp;len:UIntSize; CA,&nbsp;CB:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_lincomb( d_MC,&nbsp;d_MA,&nbsp;d_MB:fMatrix; ht,&nbsp;len:UIntSize; d_CA,&nbsp;d_CB:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_lincomb( h_MC,&nbsp;h_MA,&nbsp;h_MB:fMatrix; ht,&nbsp;len:UIntSize; CA,&nbsp;CB:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = CA *&nbsp;MA + CB *&nbsp;MB</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_lincomb">MF_Rows_lincomb</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="linfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_linfit</b></font>
</td><td width="33%"><font size="+1"><b>VD_linfit</b></font></td>
<td><font size="+1"><b>VE_linfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_linfitwW</b></font></td>
<td width="33%"><font size="+1"><b>VD_linfitwW</b></font></td>
<td><font size="+1"><b>VE_linfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data-fitting to models y=f(x) linear in the parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int VF_linfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;sizex,<BR>
void funcs(fVector&nbsp;BasFuncs, float&nbsp;x, unsigned&nbsp;nfuncs));<BR>&nbsp;<BR>
int VF_linfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars, fVector&nbsp;X, fVector&nbsp;Y, fVector&nbsp;InvVar, ui&nbsp;sizex,<BR>
void funcs(fVector&nbsp;BasFuncs, float&nbsp;x, unsigned&nbsp;nfuncs));</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
int vector&lt;T&gt;::linfit( const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y,<BR>
void funcs(fVector&nbsp;BasFuncs, float&nbsp;x, unsigned&nbsp;nfuncs));<BR>&nbsp;<BR>
int vector&lt;T&gt;::linfitwW( matrix&lt;T&gt; Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;InvVar,<BR>
void funcs(fVector&nbsp;BasFuncs, float&nbsp;x, unsigned&nbsp;nfuncs));<BR>&nbsp;<BR>
int vector&lt;T&gt;::linfitwW( matrix&lt;T&gt;*&nbsp;Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;InvVar,<BR>
void funcs(fVector&nbsp;BasFuncs, float&nbsp;x, unsigned&nbsp;nfuncs));</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function VF_linfit( A:fVector; AStatus:iVector; npars:UInt; X,&nbsp;Y:fVector; sizex:UIntSize; funcs:Pointer&nbsp;): IntBool;<BR>&nbsp;<BR>
function VF_linfitwW( A:fVector; Covar:fMatrix; AStatus:iVector; npars:UInt; X, Y, InvVar:fVector; sizex:UIntSize; funcs:Pointer&nbsp;): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data X, Y (and InvVar) are used to evaluate the parameters <I>a<sub>i</sub></I> of a general linear function,<BR>
<font face="courier new"> y = a<sub>0</sub>f<sub>0</sub>(x) + a<sub>1</sub>f<sub>1</sub>(x) + a<sub>2</sub>f<sub>2</sub>(x)...</font><BR>
The parameters <I>a<sub>i</sub></I> are returned in the vector A. 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>X,&nbsp;Y,&nbsp;InvVar</td><td>vectors of size <I>sizex</I>, holding the input data</td></tr>
<tr valign="top"><td>funcs</td><td>user-defined model function</td></tr>
</table>&nbsp;<BR>
Your model function may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide the vector <I>AStatus</I>, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). Any fixed parameters must be initialized in A prior to calling <I>VF_linfit</I>. <I>npars</I> denotes the total number of parameters in A (not only the free parameters!). 
<P>The model function <I>funcs</I>  must calculate the individual f<sub>i</sub>(x)  for any argument <I>x</I> and store the f<sub>i</sub>(x) in a vector <I>BasFuncs</I> of size <I>npars</I>. In C/C++, it has to be defined as<BR>
<font face="courier new">void MyFunc( fVector&nbsp;BasFuncs, float&nbsp;x, unsigned&nbsp;nfuncs)
<BR>{
<BR>&nbsp;&nbsp;BasFuncs[0] = f0( x&nbsp;);
<BR>&nbsp;&nbsp;BasFuncs[1] = f1( x);
<BR>&nbsp;&nbsp;. . .
<BR>}</font><BR>
and shall be passed to <I>VF_linfit</I> by calling<BR>
<font face="courier new">VF_linfit( A, AStatus, npars, X, Y, sizex, MyFunc&nbsp;);</font><BR>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( BasFuncs:fVector; x:Single; nfuncs:UInt&nbsp;);
<BR>begin
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 0&nbsp;)^ := f0( x&nbsp;);
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 1&nbsp;)^ := f1( x&nbsp;);
<BR>&nbsp;&nbsp;. . .
<BR>end;</font><BR>
and shall be passed to <I>VF_linfit</I> by calling<BR>
<font face="courier new">VF_linfit( A, AStatus, npars, X, Y, sizex, @MyFunc&nbsp;);</font><BR>
Note the address-of operator in front of &quot;MyFunc.&quot;. In Turbo Pascal, the model function <B>must</B> be compiled with the Force-Far-Calls option {$F+}.
<P>The functions f0( x&nbsp;) etc. <B>must not</B> contain the parameters <I>a<sub>i</sub></I>.
<BR>In the weighted variant, <I>VF_linfitwW</I>, the vector <I>InvVar</I> has to contain the inverse of the variances of the individual X-Y data points, and the matrix <I>Covar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I>&nbsp;).<P>Internally, <I>VF_linfit</I> employs a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, <I>Thresh</I>, are
set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.
<P>In the rare case of failure, this function returns 1 (TRUE) and sets all A[i] = 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Mlinfit">MF_linfit</a>,&nbsp;&nbsp; <a href="#nonlinfit">VF_nonlinfit</a>,&nbsp;&nbsp; <a href="#chap13">chapter&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Mlinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_linfit</b></font>
</td><td width="33%"><font size="+1"><b>MD_linfit</b></font></td>
<td><font size="+1"><b>ME_linfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_linfitwW</b></font></td>
<td width="33%"><font size="+1"><b>MD_linfitwW</b></font></td>
<td><font size="+1"><b>ME_linfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data-fitting to models z=f(x, y) linear in the parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_linfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars, fVector&nbsp;X, fVector&nbsp;Y, fMatrix&nbsp;Z, ui&nbsp;htZ, ui&nbsp;lenZ,<BR>
void funcs(fVector&nbsp;BasFuncs, float&nbsp;x, float&nbsp;y, unsigned&nbsp;nfuncs));<BR>&nbsp;<BR>
int MF_linfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars, fVector&nbsp;X, fVector&nbsp;Y, fMatrix&nbsp;Z, fMatrix&nbsp;InvVar, ui&nbsp;htZ, ui&nbsp;lenZ,<BR>
void funcs(fVector&nbsp;BasFuncs, float&nbsp;x, float&nbsp;y, unsigned&nbsp;nfuncs));</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
int vector&lt;T&gt;::linfit( const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZ,<BR>
void funcs(fVector&nbsp;BasFuncs, float&nbsp;x, float&nbsp;y, unsigned&nbsp;nfuncs));<BR>&nbsp;<BR>
int vector&lt;T&gt;::linfitwW( matrix&lt;T&gt; Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZ, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MInvVar,<BR>
void funcs(fVector&nbsp;BasFuncs, float&nbsp;x, float&nbsp;y, unsigned&nbsp;nfuncs));<BR>&nbsp;<BR>
int vector&lt;T&gt;::linfitwW( matrix&lt;T&gt;*&nbsp;Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZ, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MInvVar,<BR>
void funcs(fVector&nbsp;BasFuncs, float&nbsp;x, float&nbsp;y, unsigned&nbsp;nfuncs));</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_linfit( A:fVector; AStatus:iVector; npars:UInt; X,&nbsp;Y:fVector; MZ:fMatrix; htZ, lenZ:UIntSize; funcs:Pointer&nbsp;): IntBool;<BR>&nbsp;<BR>
function MF_linfitwW( A:fVector; Covar:fMatrix; AStatus:iVector; npars:UInt; X,&nbsp;Y:fVector; MZ, MInvVar:fMatrix; htZ, lenZ:UIntSize; funcs:Pointer&nbsp;): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data X, Y, MZ (and MInvVar) are used to evaluate the parameters <I>a<sub>i</sub></I> of a general linear function,<BR>
<font face="courier new"> z = a<sub>0</sub>f<sub>0</sub>(x, y) + a<sub>1</sub>f<sub>1</sub>(x, y) + a<sub>2</sub>f<sub>2</sub>(x, y)...</font><BR>
The parameters <I>a<sub>i</sub></I> are returned in the vector A. 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>X,&nbsp;Y</td><td>vectors of size <I>lenZ</I> and <I>htZ</I>, respectively, spanning the x-y coordinate system of the matrix MZ</td></tr>
<tr valign="top"><td>MZ,&nbsp;MInvVar</td><td>matrices of dimensions [htZ, lenZ], holding the input data and, in the weighted variant, the inverse of their variances</td></tr>
<tr valign="top"><td>funcs</td><td>user-defined model function</td></tr>
</table>&nbsp;<BR>
Your model function may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide the vector <I>AStatus</I>, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). Any fixed parameters must be initialized in A prior to calling <I>MF_linfit</I>. <I>npars</I> denotes the total number of parameters in A (not only the free parameters!). 
<P>You must provide a model function &quot;funcs&quot; which, for any pair of arguments <I>x, y</I>, must calculate the individual f<sub>i</sub>(x, y) and store them in a vector <I>BasFuncs</I> of size <I>npars</I>. In C/C++, it has to be defined as<BR>
<font face="courier new">void MyFunc( fVector&nbsp;BasFuncs, float&nbsp;x, float&nbsp;y, unsigned&nbsp;nfuncs);
<BR>{
<BR>&nbsp;&nbsp;BasFuncs[0] = f0( x, y&nbsp;);
<BR>&nbsp;&nbsp;BasFuncs[1] = f1( x, y);
<BR>&nbsp;&nbsp;. . .
<BR>}</font><BR>
and shall be passed to <I>MF_linfit</I> by calling<BR>
<font face="courier new">MF_linfit( A, AStatus, npars, X, Y, MZ, htZ, lenZ, MyFunc&nbsp;);</font><BR>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( BasFuncs:fVector; x, y:Single; nfuncs:UInt&nbsp;);
<BR>begin
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 0&nbsp;)^ := f0( x, y&nbsp;);
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 1&nbsp;)^ := f1( x, y&nbsp;);
<BR>&nbsp;&nbsp;. . .
<BR>end;</font><BR>
and shall be passed to <I>MF_linfit</I> by calling<BR>
<font face="courier new">MF_linfit( A, AStatus, npars, X, Y, MZ, htZ, lenZ, @MyFunc&nbsp;);</font><BR>
Note the address-of operator in front of &quot;MyFunc.&quot;. In Turbo Pascal, the model function <B>must</B> be compiled with the Force-Far-Calls option {$F+}.
<P>The functions f0( x, y&nbsp;) etc. <B>must not</B> contain the parameters <I>a<sub>i</sub></I>.
<BR>In the weighted variant, <I>MF_linfitwW</I>, the matirx <I>MInvVar</I> has to contain the inverse of the variances of the individual X-Y-Z data points, and the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I>&nbsp;).
<P>Internally, <I>MF_linfit</I> employs a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, <I>Thresh</I>, are
set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.
<P>In the rare case of failure, this function returns 1 (TRUE) and sets all A[i] = 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="#Mnonlinfit">MF_nonlinfit</a>,&nbsp;&nbsp; <a href="#chap13">chapter&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUdecompose"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUdecompose</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUdecompose</b></font></td>
<td><font size="+1"><b>ME_LUdecompose</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUdecompose</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUdecompose</b></font></td>
<td><font size="+1"><b>MCE_LUdecompose</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>LU decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_LUdecompose( fMatrix&nbsp;LU, uVector&nbsp;Ind, fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::LUdecompose( vector&lt;unsigned&gt; Ind, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);<BR>
void matrix&lt;T&gt;::LUdecompose( vector&lt;unsigned&gt;*&nbsp;Ind, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_LUdecompose( MLU:fMatrix; Ind:uVector; MA:fMatrix; len:UIntSize&nbsp;):Integer;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA is decomposed into a product MA = L *&nbsp;U, where L is lower-triangular with the diagonal elements equal to 1, and U is upper-triangular. As the combined number of non-trivial elements of L and U just fit into a matrix of the same dimensions as MA, the result is stored in a single matrix MLU rather than in to distinct matrices L and U. Actually, it is not the &quot;true&quot; matrices L and U which are combined into MLU, but rather a row-wise permutation, whose indices are output in the vector <I>Ind</I>. The return value indicates if the number of permuations was even (+1) or uneven (-1).
<P>MA may or may not be overwritten by MLU. To check if <I>MF_LUdecompose</I> was successful, call <I><a href="#LUDresult">MF_LUDresult</a></I>, whose return value will be FALSE (0), if the MA could be decomposed, and TRUE (1) for singular MA.
<P>There are applications where it makes sense to make near-singular matrices decomposable by &quot;pivot editing&quot;: If, in the partial pivoting process employed in the decomposition and inversion, no diagonal element larger than the threshold is available, the scaling of the matrix is done with the threshold value rather than with the tiny diagonal element. That way, divisions by (near-)zero are avoided. This pivot editing can be chosen through a call to <I><a href="#LUDsetEdit">MF_LUDsetEdit</a></I>. By default, pivot editing is switched off.
<P>Please note that the present implementation of this function does not employ the fastest possible algorithm. In order to avoid excessive accumulation of round-off error, all dot products are internally summed up in double or extended precision, thus precluding the use of the faster SIMD instructions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>In the case of a singular matrix, MLU will be undefined, and an internal flag is set, but no error message is generated. To check if an error occurred, you must call <I><a href="#LUDresult">MF_LUDresult</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>+1 or -1, indicating even or uneven number of row permutations</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUdet"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUdet</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUdet</b></font></td>
<td><font size="+1"><b>ME_LUdet</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUdet</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUdet</b></font></td>
<td><font size="+1"><b>MCE_LUdet</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>determinant of an LU decomposed matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_LUdet( fMatrix&nbsp;LU, ui&nbsp;len, int&nbsp;permut&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::LUdet( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MLU, int&nbsp;permut&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_LUdet( MLU:fMatrix; len:UIntSize; permut:Integer&nbsp;): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_LUdet</I> calculates the determinant of matrix already decomposed into LU form, and return it as a scalar. The argument <I>permut</I> must be +1 or -1, as given by the return value of <I><a href="#LUdecompose">MF_LUdecompose</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>determinant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#det">MF_det</a>,&nbsp;&nbsp; <a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUDgetEdit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUDgetEdit</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUDgetEdit</b></font></td>
<td><font size="+1"><b>ME_LUDgetEdit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUDgetEdit</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUDgetEdit</b></font></td>
<td><font size="+1"><b>MCE_LUDgetEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>retrieve pivot-editing threshold for LU decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_LUDgetEdit( void&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T matrix&lt;T&gt;::LUDgetEdit(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_LUDgetEdit: Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>retrieve the current pivot-editing threshold for <I><a href="#LUdecompose">MF_LUdecompose</a></I>, &nbsp;&nbsp;<I><a href="#inv">MF_inv</a></I>, and <I><a href="#solve">MF_solve</a></I>. It can be modified using <I><a href="#LUDsetEdit">MF_LUDsetEdit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUDresult"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUDresult</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUDresult</b></font></td>
<td><font size="+1"><b>ME_LUDresult</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUDresult</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUDresult</b></font></td>
<td><font size="+1"><b>MCE_LUDresult</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>check if the last operation utilizing LU decomposition worked error-free</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_LUDresult( void&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
int matrix&lt;T&gt;::LUDresult(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_LUDresult: IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>After a call to <I><a href="#LUdecompose">MF_LUdecompose</a></I> or any of the functions internally relying on LU decomposition (like <I><a href="inv">MF_inv</a></I>,&nbsp;&nbsp; <I><a href="#solve">MF_solve</a></I>), the result should be checked by <I>MF_LUDresult</I>. If LU decomposition was successful, <I>MF_LUDresult</I> returns FALSE (0); if MA was (nearly) singular, TRUE (1) is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>see above</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUDsetEdit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUDsetEdit</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUDsetEdit</b></font></td>
<td><font size="+1"><b>ME_LUDsetEdit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUDsetEdit</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUDsetEdit</b></font></td>
<td><font size="+1"><b>MCE_LUDsetEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>set pivot-editing threshold for LU decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_LUDsetEdit( float&nbsp;Thresh&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::LUDsetEdit( const&nbsp;T&amp;&nbsp;Thresh&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_LUDsetEdit( Thresh:Single&nbsp;); </font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>set the pivot-editing threshold for <I><a href="#LUdecompose">MF_LUdecompose</a></I>, &nbsp;&nbsp;<I><a href="#inv">MF_inv</a></I>, and <I><a href="#solve">MF_solve</a></I>. To read the current threshold, use <I><a href="#LUDgetEdit">MF_LUDgetEdit</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUimprove"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUimprove</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUimprove</b></font></td>
<td><font size="+1"><b>ME_LUimprove</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUimprove</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUimprove</b></font></td>
<td><font size="+1"><b>MCE_LUimprove</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>iterative improvement of the solution of a linear system solved by LU decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_LUimprove( fVector&nbsp;X, fVector&nbsp;B, fMatrix&nbsp;MA, fMatrix&nbsp;LU, uVector&nbsp;Ind, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::LUimprove( const&nbsp;vector&lt;T&gt; B, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MLU, const&nbsp;vector&lt;unsigned&gt;&amp;&nbsp;Ind&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_LUimprove( X, B:fVector; MA, MLU:fMatrix; Ind:uVector; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Especially for large matrices, accumulated round-off error in LU decomposition may become quite noticable. This round-off error will translate into inaccurate results of <I><a href="#LUsolve">MF_LUsolve</a></I>. If the input matrix was not overwritten by the out put matrix in the initial call to <I><a href="#LUdecompose">MF_LUdecompose</a></I>, you may call <I>MF_LUimprove</I> after <I>MF_LUsolve</I> to improve the accuracy by iteration. <I>MF_LUimprove</I> needs the output vector X of <I>MF_LUsolve</I>, the right-hand-side vector <I>B</I> of the linear system, and both the original matrix MA and its raw LU-decomposed form MLU along with its permutation indices, <I>Ind</I>, as arguments.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUinv"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUinv</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUinv</b></font></td>
<td><font size="+1"><b>ME_LUinv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUinv</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUinv</b></font></td>
<td><font size="+1"><b>MCE_LUinv</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>invert a matrix already decomposed into LU form</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_LUinv( fMatrix&nbsp;Inv, fMatrix&nbsp;LU, uVector&nbsp;Ind, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::LUinv( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MLU, const&nbsp;vector&lt;unsigned&gt;&amp;&nbsp;Ind&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_LUinv( MInv, MLU:fMatrix; Ind:uVector; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_LUinv</I> inverts a matrix already decomposed into LU form. Along with the matrix MLU, its permutation indices are needed in the vector <I>Ind</I> as output by <I><a href="#LUdecompose">MF_LUdecompose</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUsolve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUsolve</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUsolve</b></font></td>
<td><font size="+1"><b>ME_LUsolve</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUsolve</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUsolve</b></font></td>
<td><font size="+1"><b>MCE_LUsolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>solve a linear system MA *&nbsp;X = B, where MA has already been decomposed into LU form</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_LUsolve( fVector&nbsp;X, fMatrix&nbsp;LU, fVector&nbsp;B, uVector&nbsp;Ind, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::LUsolve( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MLU, const&nbsp;vector&lt;T&gt;&amp;&nbsp;B, const&nbsp;vector&lt;unsigned&gt;&amp;&nbsp;Ind&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_LUsolve( X:fVector; MLU:fMatrix; B:fVector; Ind:uVector;
len:UIntSize&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The linear system MA *&nbsp;X = B is solved for the vector X. Instead of MA itself, this function expects the LU decomposed form of MA as the input matrix MLU, along with its row-permutation indices in the vector <I>Ind</I> as output by <I><a href="#LUdecompose">MF_LUdecompose</a></I>. 
<BR>If the original matrix MA is still available, it is recommended to &quot;fine-polish&quot; the result by calling <I><a href="#LUimprove">MF_LUimprove</a></I>. In comparison to the LU decomposition and back-substitution already performed, this iterative improvement takes very little time, but it can lead to an appreaciable improvement of the solution and often even save solutions which otherwise would be ruined by round-off error.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="matrix"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_matrix</b></font>
</td><td width="33%"><font size="+1"><b>MD_matrix</b></font></td>
<td><font size="+1"><b>ME_matrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_matrix</b></font></td>
<td width="33%"><font size="+1"><b>MCD_matrix</b></font></td>
<td><font size="+1"><b>MCE_matrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_matrix</b></font></td><td width="20%"><font size="+1"><b>MBI_matrix</b></font></td><td width="20%"><font size="+1"><b>MSI_matrix</b></font></td><td width="20%"><font size="+1"><b>MLI_matrix</b></font></td><td><font size="+1"><b>MQI_matrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_matrix</b></font></td><td width="20%"><font size="+1"><b>MUB_matrix</b></font></td><td width="20%"><font size="+1"><b>MUS_matrix</b></font></td><td width="20%"><font size="+1"><b>MUL_matrix</b></font></td><td><font size="+1"><b>MUQ_matrix;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Memory allocation for a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
fMatrix&nbsp;MF_matrix( ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_matrix( ht,&nbsp;len:UIntSize&nbsp;):&nbsp;fMatrix;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>fMatrix&nbsp;cudaMF_matrix( ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_matrix( ht,&nbsp;len:UIntSize&nbsp;):&nbsp;fMatrix;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Based on memory model and environment, the most appropriate allocation procedure is chosen by these functions. Failure to allocate memory always leads to an error message and a subsequent program abort (similar to the error handling of the &quot;new&quot; operator). To release the memory thus allocated, <I><a href="#free">M_free</a></I>,&nbsp;&nbsp;<I><a href="#nfree">M_nfree</a></I>, or <I><a href="FUNCREF.HTM#freeAll">V_freeAll</a></I> should be used (<I>M_nfree</I> only in C/C++).
<BR>For matrices generated by<i> cudaM?_matrix</i>, use <I><a href="#free">cudaM_free</a></I>,&nbsp;&nbsp;<I><a href="#nfree">cudaM_nfree</a></I>, or <I><a href="FUNCREF.HTM#freeAll">cudaV_freeAll</a></I>.
<BR>Note: the declaration of a matrix (e.g., as fMatrix) reserves only a name, but no memory!
<BR>See <a href="HANDBOOK.HTM#chap4_1">chapter&nbsp;4.1</a> if you are interested in details of the implementation.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.
<BR>32-bit:
<BR>If more than 4 GB of memory are requested, an error message &quot;Vector&nbsp;&gt; 4 GB not possible&quot; is displayed and the program aborted. If already a single matrix dimensions exceeds this limit, an error message &quot;Invalid matrix dimension(s)&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td><U>C/C++:</U> Pointer to the array of row pointers
<BR><U>Pascal/Delphi:</U> Pointer to the allocated memory</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#matrix0">MF_matrix0</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#vector">VF_vector</a>,&nbsp;&nbsp; <a href="#pinnedMatrix">cudaMF_pinnedMatrix</a></I>,&nbsp;&nbsp; <a href="#chap2">chapter&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="matrix0"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_matrix0</b></font>
</td><td width="33%"><font size="+1"><b>MD_matrix0</b></font></td>
<td><font size="+1"><b>ME_matrix0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_matrix0</b></font></td>
<td width="33%"><font size="+1"><b>MCD_matrix0</b></font></td>
<td><font size="+1"><b>MCE_matrix0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_matrix0</b></font></td><td width="20%"><font size="+1"><b>MBI_matrix0</b></font></td><td width="20%"><font size="+1"><b>MSI_matrix0</b></font></td><td width="20%"><font size="+1"><b>MLI_matrix0</b></font></td><td><font size="+1"><b>MQI_matrix0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_matrix0</b></font></td><td width="20%"><font size="+1"><b>MUB_matrix0</b></font></td><td width="20%"><font size="+1"><b>MUS_matrix0</b></font></td><td width="20%"><font size="+1"><b>MUL_matrix0</b></font></td><td><font size="+1"><b>MUQ_matrix0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>allocate memory for a matrix and initialize all elements with 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
fMatrix&nbsp;F_matrix0( ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_matrix0( ht,&nbsp;len:UIntSize&nbsp;): fMatrix;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>fMatrix&nbsp;cudaMF_matrix0( ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_matrix0( ht,&nbsp;len:UIntSize&nbsp;):&nbsp;fMatrix;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The functions of this family are almost identical to those of the <I><a href="#matrix">MF_matrix</a></I> family; in addition to allocating memory, they initialize all elements with 0. (Calls to <I>MF_matrix</I> and <I>MF_matrix0</I> may be mixed; they and the vector allocation functions, <I><a href="FUNCREF.HTM#vector">VF_vector</a></I> etc. use the same tables to keep track of the handles and pointers). For further information, see <I><a href="#matrix">MF_matrix</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.
32-bit:
<BR>If more than 4 GB of memory are requested, an error message &quot;Vector&nbsp;&gt; 4 GB not possible&quot; is displayed and the program aborted. If already a single matrix dimensions exceeds this limit, an error message &quot;Invalid matrix dimension(s)&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td><U>C/C++:</U> Pointer to the array of row pointers
<BR><U>Pascal/Delphi:</U> Pointer to the allocated memory</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#matrix">MF_matrix</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#vector0">VF_vector0</a>,&nbsp;&nbsp; <a href="#pinnedMatrix0">cudaMF_pinnedMatrix0</a></I>,&nbsp;&nbsp; <a href="#chap2">chapter&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="MatrixTo2DArray"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_MatrixTo2DArray</b></font>
</td><td width="33%"><font size="+1"><b>MD_MatrixTo2DArray</b></font></td>
<td><font size="+1"><b>ME_MatrixTo2DArray</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_MatrixTo2DArray</b></font></td>
<td width="33%"><font size="+1"><b>MCD_MatrixTo2DArray</b></font></td>
<td><font size="+1"><b>MCE_MatrixTo2DArray</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_MatrixTo2DArray</b></font></td><td width="20%"><font size="+1"><b>MBI_MatrixTo2DArray</b></font></td><td width="20%"><font size="+1"><b>MSI_MatrixTo2DArray</b></font></td><td width="20%"><font size="+1"><b>MLI_MatrixTo2DArray</b></font></td><td><font size="+1"><b>MQI_MatrixTo2DArray</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_MatrixTo2DArray</b></font></td><td width="20%"><font size="+1"><b>MUB_MatrixTo2DArray</b></font></td><td width="20%"><font size="+1"><b>MUS_MatrixTo2DArray</b></font></td><td width="20%"><font size="+1"><b>MUL_MatrixTo2DArray</b></font></td><td><font size="+1"><b>&nbsp;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>convert <I>OptiVec</I> matrix into 2D-array of Delphi 4 or higher</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td>N.A.</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses VecLib, MFstd;<BR>
type  fArray  = array of Single;<BR>
type  f2DArray  = array of fArray;<BR>
procedure    MF_MatrixTo2DArray( DelphiArr:f2DArray; MF:fMatrix; ht,len:UIntSize);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function is necessary only for Delphi 4 or higher. (Previous versions of Borland Pascal/Delphi did not support dynamically allocated matrices.) It converts <I>OptiVec</I> matrices into two-dimensional Delphi arrays. Note that, unlike static Pascal/Delphi matrices, the dynamic matrices of Delphi 4+ cannot directly be passed to <I>OptiVec</I> functions, but have to be converted first by calling <I><a href="#2DArrayToMatrix">MF_2DArrayToMatrix</a></I>. If you ever need an <I>OptiVec</I> matrix back into Delphi format, this is done by the present function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#2DArrayToMatrix">MF_2DArrayToMatrix</a>,&nbsp;&nbsp; <a href="#chap1_4">chapter&nbsp;1.4</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_mulC</b></font>
</td><td width="33%"><font size="+1"><b>MD_mulC</b></font></td>
<td><font size="+1"><b>ME_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulC</b></font></td>
<td><font size="+1"><b>MCE_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulReC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulReC</b></font></td>
<td><font size="+1"><b>MCE_mulReC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply all matrix element by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_mulC( fMatrix&nbsp;MB, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::mulC( const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_mulC( MB,&nbsp;MA:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_mulC( fMatrix&nbsp;d_MB, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMF_mulC( fMatrix&nbsp;d_MB, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>int cudaMCF_mulC( cfMatrix&nbsp;d_MB, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, fComplex&nbsp;C&nbsp;);
<BR>int cusdMCF_mulC( cfMatrix&nbsp;d_MB, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, fComplex&nbsp;*d_C&nbsp;);
<BR>int cudaMCF_mulReC( cfMatrix&nbsp;d_MB, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, float&nbsp;CRe&nbsp;);
<BR>int cusdMCF_mulReC( cfMatrix&nbsp;d_MB, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, float&nbsp;*d_CRe&nbsp;);
<BR>void MFcu_mulC( fMatrix&nbsp;h_MB, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>void MCFcu_mulC( cfMatrix&nbsp;h_MB, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, fComplex&nbsp;C&nbsp;);
<BR>void MCFcu_mulReC( cfMatrix&nbsp;h_MB, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, float&nbsp;CRe&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_mulC( d_MB,&nbsp;d_MA:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_mulC( d_MB,&nbsp;d_MA:fMatrix; ht,&nbsp;len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_mulC( h_MB,&nbsp;h_MA:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>ij</sub> = MA<sub>ij</sub> + C</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulV">MF_mulV</a>,&nbsp;&nbsp; <a href="#mulM">MF_mulM</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="VmulM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulM</b></font>
</td><td width="33%"><font size="+1"><b>VD_mulM</b></font></td>
<td><font size="+1"><b>VE_mulM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply a row vector by a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_mulM( fVector&nbsp;Y, fVector&nbsp;X, fMatrix&nbsp;MA, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::mulM( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_mulM( Y, X:fVector; MA:fMatrix; htA, lenA:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaVF_mulM( fVector&nbsp;d_Y, fVector&nbsp;d_X, fMatrix&nbsp;d_MA, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);
<BR>void VFcu_mulM( fVector&nbsp;h_Y, fVector&nbsp;h_X, fMatrix&nbsp;h_MA, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaVF_mulM( d_Y,&nbsp;d_X:fVector; d_MA:fMatrix; htA,&nbsp;lenA:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_mulM( h_Y,&nbsp;h_X:fVector; h_MA:fMatrix; htA,&nbsp;lenA:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y = X *&nbsp;MA;
<BR>the dimensions of X and Y are implicitly given by the matrix dimensions: sizX = htA, sizY = lenA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulV">MF_mulV</a>,&nbsp;&nbsp; <a href="#mulM">MF_mulM</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_mulM</b></font>
</td><td width="33%"><font size="+1"><b>MD_mulM</b></font></td>
<td><font size="+1"><b>ME_mulM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulM</b></font></td>
<td><font size="+1"><b>MCE_mulM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>matrix multiplication</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_mulM( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::mulM( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_mulM( MC,&nbsp;MA,&nbsp;MB:fMatrix; htA,&nbsp;lenA,&nbsp;lenB:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_mulM( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);
<BR>void MFcu_mulM( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_mulM( d_MC,&nbsp;d_MA,&nbsp;d_MB:fMatrix; htA,&nbsp;lenA,&nbsp;lenB:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_mulM( h_MC,&nbsp;h_MA,&nbsp;h_MB:fMatrix; htA,&nbsp;lenA,&nbsp;lenB:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA *&nbsp;MB
<BR>htA,&nbsp;lenA,&nbsp;and lenB must be specified; the other dimensions are implicitly given as: htB = lenA, lenC = lenB, htC = htA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulMT">MF_mulMT</a>,&nbsp;&nbsp; <a href="#TmulM">MF_TmulM</a>,&nbsp;&nbsp; <a href="#VmulM">VF_mulM</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="dia_mulM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFdia_mulM</b></font>
</td><td width="33%"><font size="+1"><b>MDdia_mulM</b></font></td>
<td><font size="+1"><b>MEdia_mulM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCFdia_mulM</b></font></td>
<td width="33%"><font size="+1"><b>MCDdia_mulM</b></font></td>
<td><font size="+1"><b>MCEdia_mulM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiplication of a diagonal matrix and a general matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MFdia_mulM( fMatrix&nbsp;MC, fVector&nbsp;MADia, fMatrix&nbsp;MB, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::dia_mulM( const&nbsp;vector&lt;T&gt;&amp;&nbsp;MADia, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MFdia_mulM( MC:fMatrix; MADia: fVector; MB:fMatrix; lenA,&nbsp;lenB:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMFdia_mulM( fMatrix&nbsp;d_MC, fVector&nbsp;d_MADia, fMatrix&nbsp;d_MB, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);
<BR>void MFdiacu_mulM( fMatrix&nbsp;h_MC, fVector&nbsp;h_MADia, fMatrix&nbsp;h_MB, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMFdia_mulM( d_MC:fMatrix; d_MADia:fVector; d_MB:fMatrix; lenA,&nbsp;lenB:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFdiacu_mulM( h_MC:fMatrix; h_MADia:fVector; h_MB:fMatrix; lenA,&nbsp;lenB:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MADia *&nbsp;MB
<BR>The vector MAdia represents the diagonal matrix MA. (A matrix is called diagonal, it it has non-zero elements only on the diagonal). lenA, and lenB must be specified; htB is equal to lenA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#dia_mulMT">MFdia_mulMT</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulMdia"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_mulMdia</b></font>
</td><td width="33%"><font size="+1"><b>MD_mulMdia</b></font></td>
<td><font size="+1"><b>ME_mulMdia</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulMdia</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulMdia</b></font></td>
<td><font size="+1"><b>MCE_mulMdia</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply a general matrix by a diagonal matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_mulMdia( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fVector&nbsp;MBDia, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::mulMdia( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;vector&lt;T&gt;&amp;&nbsp;MBDia,&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_mulMdia( MC,&nbsp;MA:fMatrix; MBDia:fVector; htA,&nbsp;lenA:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_mulMdia( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fVector&nbsp;d_MBDia, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);
<BR>void MFcu_mulMdia( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fVector&nbsp;h_MBDia, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_mulMdia( d_MC,&nbsp;d_MA:fMatrix; d_MBDia:fVector; htA,&nbsp;lenA:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_mulMdia( h_MC,&nbsp;h_MA:fMatrix; h_MBDia:fVector; htA,&nbsp;lenA:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA *&nbsp;MBDia.
<BR>htA and lenA must be specified; sizB = lenA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#dia_mulM">MFdia_mulM</a>,&nbsp;&nbsp; <a href="#TmulMdia">MF_TmulMdia</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulMH"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulMH</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulMH</b></font></td>
<td><font size="+1"><b>MCE_mulMH</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply one complex matrix by the hermitian conjugate of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_mulMH( cfMatrix&nbsp;MC, cfMatrix&nbsp;MA, cfMatrix&nbsp;MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::mulMH( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA, const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_mulMH( MC,&nbsp;MA,&nbsp;MB:cfMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_mulMH( cfMatrix&nbsp;d_MC, cfMatrix&nbsp;d_MA, cfMatrix&nbsp;d_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);
<BR>void MCFcu_mulMH( cfMatrix&nbsp;h_MC, cfMatrix&nbsp;h_MA, cfMatrix&nbsp;h_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_mulMH( d_MC,&nbsp;d_MA,&nbsp;d_MB:cfMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_mulMH( h_MC,&nbsp;h_MA,&nbsp;h_MB:cfMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA *&nbsp;MB<sup>T *</sup>.
<BR>htA,&nbsp;lenA,&nbsp;and htB must be specified; the other dimensions are implicitly given as: lenB = lenA, lenC = htB, htC = htA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#hermconj">MCF_hermconj</a>,&nbsp;&nbsp; <td><a href="#mulMT">MF_mulMT</a>,&nbsp;&nbsp; <a href="#HmulM">MCF_HmulM</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_mulMT</b></font>
</td><td width="33%"><font size="+1"><b>MD_mulMT</b></font></td>
<td><font size="+1"><b>ME_mulMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulMT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulMT</b></font></td>
<td><font size="+1"><b>MCE_mulMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply one matrix by the transpose of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_mulMT( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::mulMT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_mulMT( MC,&nbsp;MA,&nbsp;MB:fMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_mulMT( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);
<BR>void MFcu_mulMT( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_mulMT( d_MC,&nbsp;d_MA,&nbsp;d_MB:fMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_mulMT( h_MC,&nbsp;h_MA,&nbsp;h_MB:fMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA *&nbsp;MB<sup>T</sup>.
<BR>htA,&nbsp;lenA,&nbsp;and htB must be specified; the other dimensions are implicitly given as: lenB = lenA, lenC = htB, htC = htA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulM">MF_mulM</a>,&nbsp;&nbsp; <a href="#TmulM">MF_TmulM</a>,&nbsp;&nbsp; <a href="#VmulMT">VF_mulMT</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="dia_mulMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFdia_mulMT</b></font>
</td><td width="33%"><font size="+1"><b>MDdia_mulMT</b></font></td>
<td><font size="+1"><b>MEdia_mulMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCFdia_mulMT</b></font></td>
<td width="33%"><font size="+1"><b>MCDdia_mulMT</b></font></td>
<td><font size="+1"><b>MCEdia_mulMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply a diagonal matrix by the transpose of a general matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MFdia_mulMT( fMatrix&nbsp;MC, fVector&nbsp;MADia, fMatrix&nbsp;MB, ui&nbsp;htB, ui&nbsp;lenB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::dia_mulMT( const&nbsp;vector&lt;T&gt;&amp;&nbsp;MADia, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MFdia_mulMT( MC:fMatrix; MADia:fVector; MB:fMatrix; htB,&nbsp;lenB:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMFdia_mulMT( fMatrix&nbsp;d_MC, fVector&nbsp;d_MADia, fMatrix&nbsp;d_MB, ui&nbsp;htB, ui&nbsp;lenB&nbsp;);
<BR>void MFdiacu_mulMT( fMatrix&nbsp;h_MC, fVector&nbsp;h_MADia, fMatrix&nbsp;h_MB, ui&nbsp;htB, ui&nbsp;lenB&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMFdia_mulMT( d_MC:fMatrix; d_MADia:fVector; d_MB:fMatrix; htB,&nbsp;lenB:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFdiacu_mulMT( h_MC:fMatrix; h_MADia:fVector; h_MB:fMatrix; htB,&nbsp;lenB:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MADia *&nbsp;MB<sup>T</sup>
<BR>htB and lenB must be specified; sizA equals lenB.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#dia_mulM">MFdia_mulM</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="VmulMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulMT</b></font>
</td><td width="33%"><font size="+1"><b>VD_mulMT</b></font></td>
<td><font size="+1"><b>VE_mulMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply a row vector by the transpose of a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_mulMT( fVector&nbsp;Y, fVector&nbsp;X, fMatrix&nbsp;MA, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::mulMT( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_mulMT( Y,&nbsp;X:fVector; MA:fMatrix; htA,&nbsp;lenA:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaVF_mulMT( fVector&nbsp;d_Y, fVector&nbsp;d_X, fMatrix&nbsp;d_MA, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);
<BR>void VFcu_mulMT( fVector&nbsp;h_Y, fVector&nbsp;h_X, fMatrix&nbsp;h_MA, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaVF_mulMT( d_Y,&nbsp;d_X:fVector; d_MA:fMatrix; htA,&nbsp;lenA:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure VFcu_mulMT( h_Y,&nbsp;h_X:fVector; h_MA:fMatrix; htA,&nbsp;lenA:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y = X *&nbsp;MA<sup>T</sup>
<BR>The dimensions htA and lenA refer to the original (rather than the intermediate transposed) matrix MA; the dimensions of X and Y are implicitly given by the matrix dimensions: sizX = lenA, sizY = htA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#VmulM">VF_mulM</a>,&nbsp;&nbsp; <a href="#mulV">MF_mulV</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="multiLinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiLinfit</b></font>
</td><td width="33%"><font size="+1"><b>VD_multiLinfit</b></font></td>
<td><font size="+1"><b>VE_multiLinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiLinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>VD_multiLinfitwW</b></font></td>
<td><font size="+1"><b>VE_multiLinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit multiple X-Y data sets to a common model function, linear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int VF_multiLinfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars, VF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
void (*funcs)(fVector&nbsp;BasFuncs, float&nbsp;x,unsigned&nbsp;nfuncs, unsigned iexperiment)&nbsp;);<BR>&nbsp;<BR>
int VF_multiLinfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars, VF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
void (*funcs)(fVector&nbsp;BasFuncs, float&nbsp;x, unsigned&nbsp;nfuncs, unsigned iexperiment)&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function VF_multiLinfit( A:fVector; AStatus:iVector; nParameters:UInt; ListOfExperiments: PVF_EXPERIMENT; nexperiments:UInt; funcs: Pointer&nbsp;): IntBool;<BR>&nbsp;<BR>
function VF_multiLinfitwW( A:fVector; Covar:fMatrix; AStatus:iVector; nParameters:UInt; ListOfExperiments:PVF_EXPERIMENT; nexperiments:UInt; funcs:Pointer&nbsp;): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data, contained in <I>ListOfExperiments</I>, are used to evaluate the parameters <I>a<sub>i</sub></I> of a general linear function,<BR>
<font face="courier new"> y = a<sub>0</sub>f<sub>0</sub>(x) + a<sub>1</sub>f<sub>1</sub>(x) + a<sub>2</sub>f<sub>2</sub>(x)...</font><BR>
The parameters <I>a<sub>i</sub></I> are returned in the vector A. 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>ListOfExperiments</td><td>input data, see <I><a href="#chap13_4EXPERIMENT">chap. 13.4</a></I></td></tr>
<tr valign="top"><td>nexperiments</td><td>number of data sets in <I>ListOfExperiments</I></td></tr>
<tr valign="top"><td>funcs</td><td>user-defined model function</td></tr>
</table>&nbsp;<BR>Your model function may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, AStatus, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). Any fixed parameters must be initialized in A prior to calling <I>VF_multiLinfit</I>. The argument <I>npars</I> denotes the total number of parameters in A (not only the free parameters!). 
<P>The input data must be combined into sets of the type <I><a href="#chap13_4EXPERIMENT">VF_EXPERIMENT</a></I>. Assuming you have two sets of X-Y data, contained in the vectors X1, Y1 (and, for <I>VF_multiLinfitwW</I>, InvVar1) of size1 elements, and X2, Y2 (and InvVar2) of size2 elements, you have to construct a list of experiments as in the following example:
</td></tr><tr valign="top"><td>Constructing list of experiments in C/C++</td><td>
<font face="courier new">VF_EXPERIMENT ExpList[2];
<BR>ExpList[0].X = X1;&nbsp;&nbsp;ExpList[0].Y = Y1;&nbsp;&nbsp;ExpList[0].size = size1;
<BR>ExpList[1].X = X2;&nbsp;&nbsp;ExpList[1].Y = Y2;&nbsp;&nbsp;ExpList[1].size = size2;
<BR>/*&nbsp;for the weighted variant, set additionally: */
<BR>ExpList[0].InvVar = InvVar1;&nbsp;&nbsp;ExpList[0].WeightOfExperiment = wt1;
<BR>ExpList[1].InvVar = InvVar2;&nbsp;&nbsp;ExpList[1].WeightOfExperiment = wt2;
<BR>&nbsp;</font>
</td></tr><tr valign="top"><td>Constructing list of experiments in Pascal/Delphi</td><td>
<font face="courier new"><B>var</B> ExpList: array[0..1] of VF_EXPERIMENT;
<BR>begin
<BR>&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;ExpList[0].X := X1;&nbsp;&nbsp;ExpList[0].Y := Y1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].size := size1;
<BR>&nbsp;&nbsp;ExpList[1].X := X2;&nbsp;&nbsp;ExpList[1].Y := Y2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].size := size2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;for the weighted variant, set additionally: *)
<BR>&nbsp;&nbsp;ExpList[0].InvVar := InvVar1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].WeightOfExperiment := wt1;
<BR>&nbsp;&nbsp;ExpList[1].InvVar := InvVar2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].WeightOfExperiment := wt2;
<BR>&nbsp;&nbsp;... 
<BR>end;</font>
<P>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
You must provide a model function &quot;funcs&quot; which, for any argument <I>x</I>, must calculate the individual basis functions f<sub>i</sub>(x) and store them in a vector <I>BasFuncs</I>. The model function has to be defined as<BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void MyFunc( fVector&nbsp;BasFuncs, float&nbsp;x, unsigned&nbsp;nfuncs, unsigned iexperiment&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;BasFuncs[0] = f0( x&nbsp;);
<BR>&nbsp;&nbsp;BasFuncs[1] = f1( x);
<BR>&nbsp;&nbsp;...
<BR>}</font><BR>
and shall be passed to <I>VF_multiLinfit</I> by calling<BR>
<font face="courier new">VF_multiLinfit( A, AStatus, npars, ExpList, 2, MyFunc&nbsp;);</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
<font face="courier new">procedure MyFunc( BasFuncs:fVector; x:Single; nfuncs, iexperiment:UInt&nbsp;);
<BR>begin
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 0&nbsp;)^ := f0( x&nbsp;);
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 1&nbsp;)^ := f1( x&nbsp;);
<BR>&nbsp;&nbsp;...
<BR>end;</font><BR>
This model function shall be passed to <I>VF_multiLinfit</I> by calling<BR>
<font face="courier new">VF_multiLinfit( A, AStatus, npars, @ExpList, 2, @MyFunc&nbsp;);</font><BR>
Note the address-of operators in front of &quot;ExpList&quot; (static Pascal array passed to <I>OptiVec</I> function) and &quot;MyFunc.&quot; (pointer to the function MyFunc). In Turbo Pascal, the model function <B>must</B> be compiled with the Force-Far-Calls option {$F+}.
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>VF_multiLinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's Y values might be shifted by a constant C. In this case, <I>A</I> has to contain as many shifts C as there are experiments. In MyFunc, you would have to code this as (in C/C++; you will easily translate this into Pascal/Delphi):
<BR><font face="courier new">&nbsp;&nbsp;if( iexperiment == 0&nbsp;) { BasFuncs[2] = 1; BasFuncs[3] = 0; }
<BR>&nbsp;&nbsp;else {BasFuncs[2] = 0; BasFuncs[3] = 1; }</font>
<P>The functions f0( x&nbsp;) etc. <B>must not</B> contain the parameters <I>a<sub>i</sub></I>. In the weighted variant, the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I>&nbsp;).<P>Internally, <I>VF_multiLinfit</I> employs a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, <I>Thresh</I>, are set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.
<P>In the rare case of failure, this function returns 1 (TRUE) and sets all A[i] = 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Mlinfit">MF_linfit</a>,&nbsp;&nbsp; <a href="#nonlinfit">VF_nonlinfit</a>,&nbsp;&nbsp; <a href="#chap13">chapter&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="MmultiLinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiLinfit</b></font>
</td><td width="33%"><font size="+1"><b>MD_multiLinfit</b></font></td>
<td><font size="+1"><b>ME_multiLinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiLinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>MD_multiLinfitwW</b></font></td>
<td><font size="+1"><b>ME_multiLinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit multiple X-Y-Z data sets to a common model function, linear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_multiLinfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars, MF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
void (*funcs)(fVector&nbsp;BasFuncs, float&nbsp;x, float&nbsp;y, unsigned&nbsp;nfuncs, unsigned iexperiment)&nbsp;);<BR>&nbsp;<BR>
int MF_multiLinfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars, MF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
void (*funcs)(fVector&nbsp;BasFuncs, float&nbsp;x, float&nbsp;y, unsigned&nbsp;nfuncs, unsigned iexperiment)&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_multiLinfit( A:fVector; AStatus:iVector; nParameters:UInt; ListOfExperiments: PMF_EXPERIMENT; nexperiments:UInt; funcs: Pointer&nbsp;): IntBool;<BR>
function MF_multiLinfitwW( A:fVector; Covar:fMatrix; AStatus:iVector; nParameters:UInt; ListOfExperiments: PMF_EXPERIMENT; nexperiments:UInt; funcs: Pointer&nbsp;): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data, contained in <I>ListOfExperiments</I>, are used to evaluate the parameters <I>a<sub>i</sub></I> of a general linear function,<BR>
<font face="courier new"> z = a<sub>0</sub>f<sub>0</sub>(x,y) + a<sub>1</sub>f<sub>1</sub>(x,y) + a<sub>2</sub>f<sub>2</sub>(x,y)...</font><BR>
The parameters <I>a<sub>i</sub></I> are returned in the vector A. 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>ListOfExperiments</td><td>input data, see <I><a href="#chap13_4EXPERIMENT">chap. 13.4</a></I></td></tr>
<tr valign="top"><td>nexperiments</td><td>number of data sets in <I>ListOfExperiments</I></td></tr>
<tr valign="top"><td>funcs</td><td>user-defined model function</td></tr>
</table>&nbsp;<BR>
Your model function may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, AStatus, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). Any fixed parameters must be initialized in A prior to calling <I>MF_multiLinfit</I>. The argument <I>npars</I> denotes the total number of parameters in A (not only the free parameters!). 
<P>The input data must be combined into sets of the type <I><a href="#chap13_4EXPERIMENT">MF_EXPERIMENT</a></I>. Let us assume you have two sets of X-Y-Z data, each with the vectors X and Y for the independent variables, the matrix MZ for the z=f(x,y) values and, for <I>MF_multiLinfitwW</I>, the weights of all points in MInvVar. The matrix dimensions are htZ (equal to sizeY) and lenZ (equal to sizeX). Now you have to construct a list of experiments as in the following example:
</td></tr><tr valign="top"><td>Constructing list of experiments in C/C++</td><td>
<font face="courier new">MF_EXPERIMENT ExpList[2];
<BR>ExpList[0].X = X1;&nbsp;&nbsp;ExpList[0].Y = Y1;&nbsp;&nbsp;
<BR>ExpList[0].MZ = MZ1; 
<BR>ExpList[0].htZ = htZ1;&nbsp;&nbsp;ExpList[0].lenZ = lenZ1;
<BR>ExpList[1].X = X1;&nbsp;&nbsp;ExpList[1].Y = Y2;&nbsp;&nbsp;
<BR>ExpList[1].MZ = MZ2; 
<BR>ExpList[1].htZ = htZ2;&nbsp;&nbsp;ExpList[1].lenZ = lenZ2;
<BR>/*&nbsp;for the weighted variant, set additionally: */
<BR>ExpList[0].MInvVar = MInvVar1;&nbsp;&nbsp;
<BR>ExpList[0].WeightOfExperiment = wt1;
<BR>ExpList[1].MInvVar = MInvVar2;&nbsp;&nbsp;
<BR>ExpList[1].WeightOfExperiment = wt2;
<BR>&nbsp;</font>
</td></tr><tr valign="top"><td>Constructing list of experiments in Pascal/Delphi</td><td>
<font face="courier new"><B>var</B> ExpList: array[0..1] of MF_EXPERIMENT;
<BR>begin
<BR>&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;ExpList[0].X := X1;&nbsp;&nbsp;ExpList[0].Y := Y1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].MZ := MZ1;
<BR>&nbsp;&nbsp;ExpList[0].htZ := htZ1;&nbsp;&nbsp;ExpList[0].lenZ := lenZ1; 
<BR>&nbsp;&nbsp;ExpList[1].X := X2;&nbsp;&nbsp;ExpList[1].Y := Y2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].MZ := MZ2;
<BR>&nbsp;&nbsp;ExpList[1].htZ := htZ2;&nbsp;&nbsp;ExpList[1].lenZ := lenZ2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;for the weighted variant, set additionally: *)
<BR>&nbsp;&nbsp;ExpList[0].MInvVar := MInvVar1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].WeightOfExperiment := wt1;
<BR>&nbsp;&nbsp;ExpList[1].MInvVar := MInvVar2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].WeightOfExperiment := wt2;
<BR>&nbsp;&nbsp;... 
<BR>end;</font>
<P>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
You must provide a model function &quot;funcs&quot; which, for any argument <I>x</I>, must calculate the individual basis functions f<sub>i</sub>(x,y) and store them in a vector <I>BasFuncs</I>. The model function has to be defined as<BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void MyFunc( fVector&nbsp;BasFuncs, float&nbsp;x, float&nbsp;y, unsigned&nbsp;nfuncs, unsigned iexperiment&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;BasFuncs[0] = f0( x, y&nbsp;);
<BR>&nbsp;&nbsp;BasFuncs[1] = f1( x, y&nbsp;);
<BR>&nbsp;&nbsp;...
<BR>}</font><BR>
and shall be passed to <I>MF_multiLinfit</I> by calling<BR>
<font face="courier new">MF_multiLinfit( A, AStatus, npars, ExpList, 2, MyFunc&nbsp;);</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
<font face="courier new">procedure MyFunc( BasFuncs:fVector; x, y:Single; nfuncs, iexperiment:UInt&nbsp;);
<BR>begin
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 0&nbsp;)^ := f0( x, y&nbsp;);
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 1&nbsp;)^ := f1( x, y&nbsp;);
<BR>&nbsp;&nbsp;...
<BR>end;</font><BR>
This model function shall be passed to <I>MF_multiLinfit</I> by calling<BR>
<font face="courier new">MF_multiLinfit( A, AStatus, npars, @ExpList, 2, @MyFunc&nbsp;);</font><BR>
Note the address-of operators in front of &quot;ExpList&quot; (static Pascal array passed to <I>OptiVec</I> function) and &quot;MyFunc.&quot; (pointer to the function MyFunc). In Turbo Pascal, the model function <B>must</B> be compiled with the Force-Far-Calls option {$F+}.
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>MF_multiLinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's MZ values might be shifted by a constant C. In this case, <I>A</I> has to contain as many shifts C<sub>i</sub> as there are experiments. In MyFunc, you would have to code this as (in C/C++; you will easily translate this into Pascal/Delphi yourself):
<BR><font face="courier new">&nbsp;&nbsp;if( iexperiment == 0&nbsp;) { BasFuncs[2] = 1; BasFuncs[3] = 0; }
<BR>&nbsp;&nbsp;else {BasFuncs[2] = 0; BasFuncs[3] = 1; }</font>
<P>The functions f0( x,y&nbsp;) etc. <B>must not</B> contain the parameters <I>a<sub>i</sub></I>. In the weighted variant, the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I>&nbsp;). 
<P>Internally, <I>MF_multiLinfit</I> employs a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, <I>Thresh</I>, are set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.
<P>In the rare case of failure, this function returns 1 (TRUE) and sets all A[i] = 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Mlinfit">MF_linfit</a>,&nbsp;&nbsp; <a href="#Mnonlinfit">MF_nonlinfit</a>,&nbsp;&nbsp; <a href="#MmultiNonlinfit">MF_multiNonlinfit</a>,&nbsp;&nbsp; <a href="#chap13">chapter&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="multiNonlinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiNonlinfit</b></font>
</td><td width="33%"><font size="+1"><b>VD_multiNonlinfit</b></font></td>
<td><font size="+1"><b>VE_multiNonlinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiNonlinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>VD_multiNonlinfitwW</b></font></td>
<td><font size="+1"><b>VE_multiNonlinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit multiple X-Y data sets to a common model function, possibly non-linear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;VF_multiNonlinfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*modelfunc)(fVector&nbsp;YModel, fVector&nbsp;XModel, ui&nbsp;size, unsigned iexperiment),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*derivatives)(fVector&nbsp;dYdAi,fVector&nbsp;X, ui&nbsp;size, unsigned ipar, unsigned iexperiment),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITWORKSPACE *WorkSpace&nbsp;);<BR>&nbsp;<BR>
float&nbsp;VF_multiNonlinfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*modelfunc)(fVector&nbsp;YModel, fVector&nbsp;X, ui&nbsp;size, unsigned iexperiment),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*derivatives)(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned ipar, unsigned iexperiment),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITWORKSPACE *WorkSpace&nbsp;);</font></td></tr>
<tr valign="TOP"><td width="15%">Syntax C/C++ simplified</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;VF_multiNonlinfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*modelfunc)(fVector&nbsp;YModel, fVector&nbsp;XModel, ui&nbsp;size, unsigned iexperiment),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*derivatives)(fVector&nbsp;dYdAi,fVector&nbsp;X, ui&nbsp;size, unsigned ipar, unsigned iexperiment)&nbsp;);<BR>&nbsp;<BR>
float&nbsp;VF_multiNonlinfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*modelfunc)(fVector&nbsp;YModel, fVector&nbsp;X, ui&nbsp;size, unsigned iexperiment),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*derivatives)(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned ipar, unsigned iexperiment)&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses VFmnlfit;<BR>
function VF_multiNonlinfit( A: fVector; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ListOfExperiments: PVF_EXPERIMENT; nexperiments: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;FitOpts: PVF_NONLINFITOPTIONS; WorkSpace: PMF_NONLINFITWORKSPACE&nbsp;): Single;<BR>&nbsp;<BR>
function VF_multiNonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ListOfExperiments: PVF_EXPERIMENT; nexperiments: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;FitOpts: PVF_NONLINFITOPTIONS; WorkSpace: PMF_NONLINFITWORKSPACE&nbsp;): Single;</font><BR>Syntax of user-supplied ModelFunc and Derivatives:<BR><font face="courier new">
procedure ModelFunc( YModel, X:fVector; size:UIntSize; iexperiment:UInt&nbsp;);<BR>
procedure Derivatives( dYdAi, X:fVector; size:UIntSize; ipar, iexperiment:UInt&nbsp;);</font>
</td></tr>
<tr valign="TOP"><td>Pascal/Delphi simplified</td><td><font face="courier new">uses VFmnlfit;<BR>
function VF_multiNonlinfit( A: fVector; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ListOfExperiments: PVF_EXPERIMENT; nexperiments: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer&nbsp;): Single;<BR>&nbsp;<BR>
function VF_multiNonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ListOfExperiments: PVF_EXPERIMENT; nexperiments: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer&nbsp;): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data, contained in <I>ListOfExperiments</I>, are used to evaluate the parameter array <I>A</I> with <I>npars</I> elements <I>a<sub>i</sub></I> of an arbitrary model function y = f(x). 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>ListOfExperiments</td><td>input data, see <I><a href="#chap13_4EXPERIMENT">chap. 13.4</a></I></td></tr>
<tr valign="top"><td>nexperiments</td><td>number of data sets in <I>ListOfExperiments</I></td></tr>
<tr valign="top"><td>modelfunc</td><td>user-defined model function</td></tr>
<tr valign="top"><td>derivatives</td><td>user-defined function, calculating the partial derivatives with respect to all parameters</td></tr>
<tr valign="top"><td>FitOpts</td><td>pointer to a structure containing options, see <I><a href="#chap13_3NONLINFITOPTIONS">chap. 13.3</a></I></td></tr>
<tr valign="top"><td>WorkSpace</td><td>pointer to a structure holding internal variables, see <I><a href="#chap13_3NONLINFITWORKSPACE">chap. 13.3</a></I></td></tr>
<tr valign="top"><td>Return Value</td><td>"goodness-of-fit" value. Depending on the function variant and the chosen figure-of-merit, this is:
<BR>VF_multiNonlinfitwW with FitOptions.FigureOfMerit=0 (least-square fitting):  <font face="symbol">c</font><sup>2</sup> (chi-square) = <font face="symbol">S</font>) (Ymod[i] - Y[i] )<sup>2</sup> *&nbsp;InvVar[i] );
<BR>VF_multiNonlinfitwW with FitOptions.FigureOfMerit=1 (robust fitting):  |<font face="symbol">c</font>| (chi-abs) = <font face="symbol">S</font>( abs(Ymod[i] - Y[i] ) *&nbsp;InvVar[i] );
<BR>VF_multiNonlinfit with FitOptions.FigureOfMerit=0 (least-square fitting, all std errors assumed=1.0):  <font face="symbol">c</font><sup>2</sup> = <font face="symbol">S</font>( (Ymod[i] - Y[i] )<sup>2</sup> ];
<BR>VF_multiNonlinfit with FitOptions.FigureOfMerit=1 (robust fitting):  |<font face="symbol">c</font>| (chi-abs) = <font face="symbol">S</font>( abs(Ymod[i] - Y[i] ) );
<BR>where <i>Ymod</i> means the theoretical <i>Y</i> values of all experiments as calculated from the model function with the best parameter set found. For robust fitting, <i>InvVar</i> actually does not have the meaning of inverse variances; one could choose weights as inverse absolute uncertainties instead.</td></tr>
</table>&nbsp;<BR>
In order to use default options and built-in workspace, FitOpts and WorkSpace may be set to NULL / nil. In the simplified syntax variant, both of them are missing.<BR>
The model function (and, consequently, the vector <I>A</I> as well) may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, <I>AStatus</I>, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). All parameters must be initialized in <I>A</I> prior to calling <I>VF_multiNonlinfit</I>. The better your initial guess of the parameters, the faster <I>VF_multiNonlinfit</I> shall converge. The argument <I>npars</I> denotes the total number of parameters in <I>A</I> (not only the free parameters!). 
<P>The input data must be combined into sets of the type <I><a href="#chap13_4EXPERIMENT">VF_EXPERIMENT</a></I>. Assuming you have two sets of X-Y data, contained in the vectors X1, Y1 (and, for <I>VF_multiLinfitwW</I>, InvVar1) of size1 elements, and X2, Y2 (and InvVar2) of size2 elements, you have to construct a list of experiments as in the following example:
</td></tr><tr valign="top"><td>Constructing list of experiments in C/C++</td><td>
<font face="courier new">VF_EXPERIMENT ExpList[2];
<BR>ExpList[0].X = X1;&nbsp;&nbsp;ExpList[0].Y = Y1;&nbsp;&nbsp;ExpList[0].size = size1;
<BR>ExpList[1].X = X2;&nbsp;&nbsp;ExpList[1].Y = Y2;&nbsp;&nbsp;ExpList[1].size = size2;
<BR>/*&nbsp;for the weighted variant, set additionally: */
<BR>ExpList[0].InvVar = InvVar1;&nbsp;&nbsp;ExpList[0].WeightOfExperiment = wt1;
<BR>ExpList[1].InvVar = InvVar2;&nbsp;&nbsp;ExpList[1].WeightOfExperiment = wt2;
<BR>&nbsp;</font>
</td></tr><tr valign="top"><td>Constructing list of experiments in Pascal/Delphi</td><td>
<font face="courier new"><B>var</B> ExpList: array[0..1] of VF_EXPERIMENT;
<BR>begin
<BR>&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;ExpList[0].X := X1;&nbsp;&nbsp;ExpList[0].Y := Y1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].size := size1;
<BR>&nbsp;&nbsp;ExpList[1].X := X2;&nbsp;&nbsp;ExpList[1].Y := Y2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].size := size2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for the weighted variant, set additionally: */
<BR>&nbsp;&nbsp;ExpList[0].InvVar := InvVar1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].WeightOfExperiment := wt1;
<BR>&nbsp;&nbsp;ExpList[1].InvVar := InvVar2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].WeightOfExperiment := wt2;
<BR>&nbsp;&nbsp;... 
<BR>end;</font>
<BR>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
You must provide a model function &quot;modelfunc&quot; which, for a given vector of x-values, must calculate the corresponding &quot;theoretical&quot; y-values. In C/C++, it has to be defined as<BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void _cdecl MyFunc( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size, unsigned iexperiment&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;for (ui i=0; i&lt;size; i++&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Y[i] = f( X[i]&nbsp;); 
<BR>}<BR>
f( X[i]&nbsp;) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>VF_multiNonlinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's Y values might be scaled by an individual constant C. In this case, <I>A</I> has to contain as many scales C as there are experiments. In MyFunc, you would have to code this as something like:
<BR><font face="courier new">&nbsp;&nbsp;if( iexperiment == 0&nbsp;) Y[i] *= A[5];&nbsp;&nbsp;else Y[i] *= A[6];</font>
<P>In addition to the model function, <I>VF_multiNonlinfit</I> needs the partial derivatives of Y with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#multiNonlinfit_">VF_multiNonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for C/C++</td><td>
<font face="courier new">VF_NONLINFITWORKSPACE WorkSpace;  /*&nbsp;this should be a global variable, the same as passed to <i>VF_multiNonlinfit</i> */
<BR>&nbsp;<BR>void _cdecl MyDerivs( fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned ipar, unsigned iexperiment&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;ui i;
<BR>&nbsp;&nbsp;switch( ipar&nbsp;)
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 0: for(i=0; i&lt;size; i++&nbsp;) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi[i] = part_derv_of_Y_w_resp_to_A<sub>0</sub>( X[i]&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 1: for(i=0; i&lt;size; i++&nbsp;) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi[i] = part_derv_of_Y_w_resp_to_A<sub>1</sub>( X[i]&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;default: /*&nbsp;for all derivatives we don't know: */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#multiNonlinfit_">VF_multiNonlinfit_autoDeriv</a>( 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi, X, size:UIntSize; ipar, iexperiment, &amp;WorkSpace&nbsp;);
<BR>&nbsp;&nbsp;}
<BR>}</font><BR>
Again, the argument <I>iexperiment</I> allows you to treat &quot;private&quot; parameters of the individual experiments differently from the shared parameters.<BR>
A call to <I>VF_multiNonlinfit</I> will look like:<BR>
<font face="courier new">VF_multiNonlinfit( A, AStatus, npars, ExpList, 2, MyFunc, MyDerivs&nbsp;);</font><BR>
or<BR>
<font face="courier new">VF_multiNonlinfit( A, AStatus, npars, ExpList, 2, MyFunc, MyDerivs, &amp;FitOpts, &amp;WorkSpace&nbsp;);</font><BR>
In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>VF_multiNonlinfit</I> with <I>derivatives</I> = NULL:<BR>
<font face="courier new">VF_multiNonlinfit( A, AStatus, npars, ExpList, 2, MyFunc, NULL&nbsp;);</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( Y, X:fVector; size:UIntSize; iexperiment:UInt&nbsp;);
<BR>var i:UIntSize;
<BR>begin
<BR>&nbsp;&nbsp;for i:=0 to size-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( Y, i&nbsp;)^ := f( VF_element( X, i&nbsp;)&nbsp;);
<BR>end;<BR>
f( X[i]&nbsp;) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3">chapter&nbsp;13.3</a>).
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>VF_multiNonlinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's Y values might be scaled by an individual constant C. In this case, <I>A</I> has to contain as many scales C as there are experiments. In MyFunc, you would have to code this as something like:
<BR><font face="courier new">&nbsp;&nbsp;if iexperiment = 0 then
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement(Y,i)^ := VF_element(Y,i) *&nbsp;VF_element(A,5)
<BR>&nbsp;&nbsp;else VF_Pelement(Y,i)^ := VF_element(Y,i) *&nbsp;VF_element(A,6);</font>
<P>In addition to the model function, <I>VF_multiNonlinfit</I> needs the partial derivatives of Y with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#multiNonlinfit_">VF_multiNonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for Pascal/Delphi</td><td>
<font face="courier new">var WorkSpace: VF_NONLINFITWORKSPACE; (*&nbsp;this should be a global variable, the same as passed to <i>VF_multiNonlinfit</i> *)
<BR>&nbsp;<BR>procedure MyDerivs( dYdAi, X:fVector; size:UIntSize; ipar, iexperiment:UInt&nbsp;);
<BR>var i:UIntSize;
<BR>begin
<BR>&nbsp;&nbsp;case ipar of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to size-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( dYdAi, i&nbsp;)^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_of_Y_w_resp_to_A<sub>0</sub>(VF_element( X, i&nbsp;)); end;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;1: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to size-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( dYdAi, i&nbsp;)^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_of_Y_w_resp_to_A<sub>0</sub>(VF_element( X, i&nbsp;)); end;
<BR>&nbsp;&nbsp;else (*&nbsp;for all derivatives we don't know: *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#multiNonlinfit_">VF_multiNonlinfit_autoDeriv</a>( 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi, X, size:UIntSize; ipar, iexperiment, @WorkSpace&nbsp;);
<BR>&nbsp;&nbsp;end;
<BR>end;</font><BR>
Again, the argument <I>iexperiment</I> allows you to treat &quot;private&quot; parameters of the individual experiments differently from the shared parameters.<BR>
A call to <I>VF_multiNonlinfit</I> will look like:<BR>
<font face="courier new">VF_multiNonlinfit( A, AStatus, npars, @ExpList, 2, @MyFunc, @MyDerivs, @FitOpts, @WorkSpace&nbsp;);</font><BR>
or with simplified syntax:<BR>
<font face="courier new">VF_multiNonlinfit( A, AStatus, npars, @ExpList, 2, @MyFunc, @MyDerivs&nbsp;);</font><BR>
Note the address-of operator in front of &quot;ExpList&quot;, &quot;MyFunc.&quot;, and &quot;MyDerivs&quot;.  In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>VF_multiNonlinfit</I> with <I>derivatives</I> = <B>nil</B>:<BR>
<font face="courier new">VF_multiNonlinfit( A, AStatus, npars, @ExpList, 2, @MyFunc, nil&nbsp;);</font><BR>
<BR>In the weighted variant, <I>VF_multiNonlinfitwW</I>, the vector <I>ExpList[i].InvVar</I> of each experiment has to contain the inverse of the variances of the individual X-Y data points, and the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I>&nbsp;). Theoretically, covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> = covariance( <I>a<sub>j</sub></I>, <I>a<sub>i</sub></I>; due to round-off error, however, small deviations are possible.<BR>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi:</td><td>
For the many different options controlling nonlinear data-fitting functions, please consult <a href="#chap13_3">chapter&nbsp;13.3</a>. Helper functions for breaking off excessively long fitting runs and for the monitoring of these often very time-consuming procedures are summarized in <a href="#chap13_5">chapter&nbsp;13.5</a> and, in the special case of <I>VF_multiNonlinfit</I>, <a href="#multiNonlinfit_">described here</a>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Multi-threading restrictions</td><td>The multi-threading restrictions, present in <i>OptiVec</i> versions up to and including 6.1, have been lifted with v6.2.
<P>These functions should not be called while the FPU is set to reduced accuracy, or else they might hang in an infinite loop. See <I><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If the number of free parameters (i.e., those with AStatus[i] = 1) exceeds the total number of data points, an error message "Invalid parameter(s)" is generated and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>in case of success: goodness-of-fit parameter <font face="symbol">c</font><sup>2</sup> (chi-square);<BR>in case of failure: -1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a>,&nbsp;&nbsp; <a href="#MmultiNonlinfit">MF_multiNonlinfit</a>,&nbsp;&nbsp; <a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="#chap13">chapter&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="multiNonlinfit_"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiNonlinfit_...</b></font>
</td><td width="33%"><font size="+1"><b>VD_multiNonlinfit_...</b></font></td>
<td><font size="+1"><b>VE_multiNonlinfit_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiNonlinfitwW_...</b></font></td>
<td width="33%"><font size="+1"><b>VD_multiNonlinfitwW_...</b></font></td>
<td><font size="+1"><b>VE_multiNonlinfitwW_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._autoDeriv</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2Detail</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getBestValues</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestRun</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestPar</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestDir</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._stop</B></font></td><td></TD></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>helper functions for <I><a href="#multiNonlinfit">VF_multiNonlinfit</a></I> and <I><a href="#multiNonlinfit">VF_multiNonlinfitwW</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_multiNonlinfit_autoDeriv( fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned ipar, unsigned iexperiment, VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
float&nbsp;VF_multiNonlinfit_getChi2( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void VF_multiNonlinfit_getChi2Detail( fVector&nbsp;Chi2Detail, VF_NONLINFITWORKSPACE *ws&nbsp;);
void VF_multiNonlinfit_getBestValues( fVector&nbsp;ABest, VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
int VF_multiNonlinfit_getTestDir( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned VF_multiNonlinfit_getTestPar( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned VF_multiNonlinfit_getTestRun( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void VF_multiNonlinfit_stop( VF_NONLINFITWORKSPACE *ws&nbsp;);</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>VF_multiNonlinfitwW_...</I> functions)</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses VFmnlfit;<BR>
procedure VF_multiNonlinfit_autoDeriv( dYdAi, X:fVector; size:UIntSize; ipar, iex:UInt; PVF_NONLINFITWORKSPACE ws&nbsp;);<BR>
function VF_multiNonlinfit_getChi2( PVF_NONLINFITWORKSPACE ws&nbsp;): Single;<BR>
procedure VF_multiNonlinfit_getChi2Detail( Chi2Detail:fVector; PVF_NONLINFITWORKSPACE ws&nbsp;);<BR>
procedure VF_multiNonlinfit_getBestValues( BestValues: fVector; PVF_NONLINFITWORKSPACE ws&nbsp;);<BR>
function VF_multiNonlinfit_getTestDir( PVF_NONLINFITWORKSPACE ws ): Integer;<BR>
function VF_multiNonlinfit_getTestPar( PVF_NONLINFITWORKSPACE ws ): UInt;<BR>
function VF_multiNonlinfit_getTestRun( PVF_NONLINFITWORKSPACE ws ): UInt;<BR>
procedure VF_multiNonlinfit_stop( PVF_NONLINFITWORKSPACE ws );</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>VF_multiNonlinfitwW_...</I> functions)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>VF_multiNonlinfit_autoDeriv</I> performs a numerical differentiation of a user-provided y=f(x) model function with respect to the parameter <I>a<sub>ipar</sub></I> of the model. All necessary information (model function, current state of parameter set, etc.) is passed to this function through the pointer to the VF_NONLINFITWORKSPACE used in the current <a href="#multiNonlinfit">VF_multiNonlinfit</a> operation.<P>
The following functions allow to monitor the progress of a nonlinear fitting operation. They can either be called from within the provided model function or, for multi-thread applications, from a second thread running in parallel to the thread containing the fitting function.<BR>
<I>VF_multiNonlinfit_getChi2</I> returns the best figure-of-merit (<font face="symbol">c</font><sup>2</sup> or, for robust fits, |<font face="symbol">c</font>|) obtained so far. If you call this function before <I>VF_multiNonlinfit</I> has had the chance to calculate <font face="symbol">c</font><sup>2</sup>, <I>VF_multiNonlinfit_getChi2</I> returns -1.0.<P>
<I>VF_multiNonlinfit_getChi2Detail</I> fills the user-supplied vector <I>Chi2Detail</I> with the individual figures-of-merit (<font face="symbol">c</font><sup>2</sup><sub>iex</sub> or, for robust fits, |<font face="symbol">c</font><sub>iex</sub>|) for all experiments. The sum over these individual <font face="symbol">c</font><sup>2</sup><sub>iex</sub> or |<font face="symbol">c</font><sub>iex</sub>| values is the best <font face="symbol">c</font><sup>2</sup> (or |<font face="symbol">c</font>|) obtained so far, as returned by <I>VF_multiNonlinfit_getChi2</I>.<P>
<I>VF_multiNonlinfit_getBestValues</I> stores the best parameters <I>a<sub>i</sub></I> obtained so far into the user-supplied vector <I>ABest</I>.<P>
<I>VF_multiNonlinfit_getTestDir</I> returns the test direction (+1 for upwards, -1 for downwards) during &quot;breakout&quot; attempts from possible <U>local</U> optima which would otherwise prevent the routine from finally reaching the <U>global</U> optimum (level-of-method greater than 3 specified by <I><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a></I>).<P>
<I>VF_multiNonlinfit_getTestPar</I> returns the index of the parameter currently under &quot;breakout&quot; investigation.<P>
<I>VF_multiNonlinfit_getTestRun</I> returns the index of the current &quot;breakout&quot; test run. For each fitted parameter, one test run is performed. The order in which the parameters are checked is determined internally in such a way as to test the most sensitive parameters first.<P>
<I>VF_multiNonlinfit_stop</I> makes <I>VF_multiNonlinfit</I> finish its current Levenberg-Marquardt or Downhill-Simplex cycle, update the output parameters and return. Thereby, long fitting sessions (especially tedious &quot;break-out&quot; attempts) may be broke off without the loss of any data.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13">chapter&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="MmultiNonlinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiNonlinfit</b></font>
</td><td width="33%"><font size="+1"><b>MD_multiNonlinfit</b></font></td>
<td><font size="+1"><b>ME_multiNonlinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiNonlinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>MD_multiNonlinfitwW</b></font></td>
<td><font size="+1"><b>ME_multiNonlinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit multiple X-Y-Z data sets to a common model function, possibly non-linear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%">
<tr valign="TOP"><td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_multiNonlinfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*modelfunc)(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned iexperiment),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*derivatives)(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar, unsigned iexperiment),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MF_NONLINFITWORKSPACE *WorkSpace&nbsp;);<BR>&nbsp;<BR>
float&nbsp;MF_multiNonlinfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*modelfunc)(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned iexperiment&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*derivatives)(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar, unsigned iexperiment),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MF_NONLINFITWORKSPACE *WorkSpace&nbsp;);</font></td></tr>
<tr valign="TOP"><td width="15%">Syntax C/C++ simplified</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_multiNonlinfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*modelfunc)(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned iexperiment),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*derivatives)(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar, unsigned iexperiment)&nbsp;);<BR>&nbsp;<BR>
float&nbsp;MF_multiNonlinfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MF_EXPERIMENT *ListOfExperiments, unsigned&nbsp;nexperiments,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*modelfunc)(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned iexperiment&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void (*derivatives)(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar, unsigned iexperiment)&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFmnlfit;<BR>
function MF_multiNonlinfit( A: fVector; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ListOfExperiments: PMF_EXPERIMENT; nexperiments: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;FitOpts: PVF_NONLINFITOPTIONS; WorkSpace: PMF_NONLINFITWORKSPACE&nbsp;): Single;<BR>&nbsp;<BR>
function MF_multiNonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ListOfExperiments: PMF_EXPERIMENT; nexperiments: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;FitOpts: PVF_NONLINFITOPTIONS; WorkSpace: PMF_NONLINFITWORKSPACE&nbsp;): Single;</font><BR>Syntax of user-supplied ModelFunc and Derivatives:<BR><font face="courier new">
procedure ModelFunc( ZModel:fMatrix; htZ, lenZ:UIntSize; X,&nbsp;Y:fVector; iexperiment:UInt&nbsp;);<BR>
procedure Derivatives( dZdAi:fMatrix; htZ, lenZ:UIntSize; X,&nbsp;Y:fVector; ipar, iexperiment:UInt&nbsp;);</font>
</td></tr>
<tr valign="TOP"><td>Pascal/Delphi simplified</td><td><font face="courier new">uses MFmnlfit;<BR>
function MF_multiNonlinfit( A: fVector; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ListOfExperiments: PMF_EXPERIMENT; nexperiments: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer&nbsp;): Single;<BR>&nbsp;<BR>
function MF_multiNonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ListOfExperiments: PMF_EXPERIMENT; nexperiments: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer&nbsp;): Single;</font></td></tr>
</table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data, contained in <I>ListOfExperiments</I>, are used to evaluate the parameter array <I>A</I> with <I>npars</I> elements <I>a<sub>i</sub></I> of an arbitrary model function z = f(x, y). 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>ListOfExperiments</td><td>input data, see <I><a href="#chap13_4EXPERIMENT">chap. 13.4</a></I></td></tr>
<tr valign="top"><td>nexperiments</td><td>number of data sets in <I>ListOfExperiments</I></td></tr>
<tr valign="top"><td>modelfunc</td><td>user-defined model function</td></tr>
<tr valign="top"><td>derivatives</td><td>user-defined function, calculating the partial derivatives with respect to all parameters</td></tr>
<tr valign="top"><td>FitOpts</td><td>pointer to a structure containing options, see <I><a href="#chap13_3NONLINFITOPTIONS">chap. 13.3</a></I></td></tr>
<tr valign="top"><td>WorkSpace</td><td>pointer to a structure holding internal variables, see <I><a href="#chap13_3NONLINFITWORKSPACE">chap. 13.3</a></I></td></tr>
<tr valign="top"><td>Return Value</td><td>"goodness-of-fit" value. Depending on the function variant and the chosen figure-of-merit, this is:
<BR>MF_multiNonlinfitwW with FitOptions.FigureOfMerit=0 (least-square fitting):  <font face="symbol">c</font><sup>2</sup> (chi-square) = <font face="symbol">S</font>) (MZmod[i,j] - MZ[i,j] )<sup>2</sup> *&nbsp;MInvVar[i,j] );
<BR>MF_multiNonlinfitwW with FitOptions.FigureOfMerit=1 (robust fitting):  |<font face="symbol">c</font>| (chi-abs) = <font face="symbol">S</font>( abs(MZmod[i,j] - MZ[i,j] ) *&nbsp;MInvVar[i,j] );
<BR>MF_multiNonlinfit with FitOptions.FigureOfMerit=0 (least-square fitting, all std errors assumed=1.0):  <font face="symbol">c</font><sup>2</sup> = <font face="symbol">S</font>( (MZmod[i,j] - MZ[i,j] )<sup>2</sup> ];
<BR>MF_multiNonlinfit with FitOptions.FigureOfMerit=1 (robust fitting):  |<font face="symbol">c</font>| (chi-abs) = <font face="symbol">S</font>( abs(MZmod[i,j] - MZ[i,j] ) );
<BR>where <i>MZmod</i> means the theoretical <i>MZ</i> values as calculated for all experiments from the model function with the best parameter set found. For robust fitting, <i>MInvVar</i> actually does not have the meaning of inverse variances; one could choose weights as inverse absolute uncertainties instead.</td></tr>
</table>&nbsp;<BR>
The model function (and, consequently, the vector <I>A</I> as well) may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, <I>AStatus</I>, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). All parameters must be initialized in <I>A</I> prior to calling <I>MF_multiNonlinfit</I>. The better your initial guess of the parameters, the faster <I>MF_multiNonlinfit</I> shall converge. The argument <I>npars</I> denotes the total number of parameters in <I>A</I> (not only the free parameters!). 
<P>The input data must be combined into sets of the type <I><a href="#chap13_4EXPERIMENT">MF_EXPERIMENT</a></I>. Let us assume you have two sets of X-Y-Z data, each with the vectors X and Y for the independent variables, the matrix MZ for the z=f(x,y) values and, for <I>MF_multiLinfitwW</I>, the weights of all points in MInvVar. The matrix dimensions are htZ (equal to sizeY) and lenZ (equal to sizeX). Now you have to construct a list of experiments as in the following example:
</td></tr><tr valign="top"><td>Constructing list of experiments in C/C++</td><td>
<font face="courier new">MF_EXPERIMENT ExpList[2];
<BR>ExpList[0].X = X1;&nbsp;&nbsp;ExpList[0].Y = Y1;&nbsp;&nbsp;
<BR>ExpList[0].MZ = MZ1; 
<BR>ExpList[0].htZ = htZ1;&nbsp;&nbsp;ExpList[0].lenZ = lenZ1;
<BR>ExpList[1].X = X1;&nbsp;&nbsp;ExpList[1].Y = Y2;&nbsp;&nbsp;
<BR>ExpList[1].MZ = MZ2; 
<BR>ExpList[1].htZ = htZ2;&nbsp;&nbsp;ExpList[1].lenZ = lenZ2;
<BR>/*&nbsp;for the weighted variant, set additionally: */
<BR>ExpList[0].MInvVar = MInvVar1;&nbsp;&nbsp;
<BR>ExpList[0].WeightOfExperiment = wt1;
<BR>ExpList[1].MInvVar = MInvVar2;&nbsp;&nbsp;
<BR>ExpList[1].WeightOfExperiment = wt2;
<BR>&nbsp;</font>
</td></tr><tr valign="top"><td>Constructing list of experiments in Pascal/Delphi</td><td>
<font face="courier new"><B>var</B> ExpList: array[0..1] of MF_EXPERIMENT;
<BR>begin
<BR>&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;ExpList[0].X := X1;&nbsp;&nbsp;ExpList[0].Y := Y1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].MZ := MZ1;
<BR>&nbsp;&nbsp;ExpList[0].htZ := htZ1;&nbsp;&nbsp;ExpList[0].lenZ := lenZ1; 
<BR>&nbsp;&nbsp;ExpList[1].X := X2;&nbsp;&nbsp;ExpList[1].Y := Y2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].MZ := MZ2;
<BR>&nbsp;&nbsp;ExpList[1].htZ := htZ2;&nbsp;&nbsp;ExpList[1].lenZ := lenZ2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for the weighted variant, set additionally: */
<BR>&nbsp;&nbsp;ExpList[0].MInvVar := MInvVar1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].WeightOfExperiment := wt1;
<BR>&nbsp;&nbsp;ExpList[1].MInvVar := MInvVar2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].WeightOfExperiment := wt2;
<BR>&nbsp;&nbsp;... 
<BR>end;</font>
<P>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
You must provide a model function &quot;modelfunc&quot; which, for a given pair of X, Y vectors, must calculate the corresponding &quot;theoretical&quot; z-values. In C/C++, it has to be defined as<BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void _cdecl MyFunc( fMatrix&nbsp;Z, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned iexperiment&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;for (ui i=0; i&lt;htZ; i++&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for (ui j=0; j&lt;lenZ; j++&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MZ[i][j] = f( X[j], Y[i]&nbsp;); 
<BR>}<BR>
f( X[j], Y[i]&nbsp;) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>MF_multiNonlinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's MZ values might be scaled by an individual constant C. In this case, <I>A</I> has to contain as many scales C as there are experiments. In MyFunc, you would have to code this as something like:
<BR><font face="courier new">&nbsp;&nbsp;if( iexperiment == 0&nbsp;) MZ[i][j] *= A[5];&nbsp;&nbsp;else MZ[i][j] *= A[6];</font>
<P>In addition to the model function, <I>MF_multiNonlinfit</I> needs the partial derivatives of MZ with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#multiNonlinfit_">MF_multiNonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for C/C++</td><td>
<font face="courier new">MF_NONLINFITWORKSPACE WorkSpace;  /*&nbsp;this should be a global variable, the same as passed to <i>MF_multiNonlinfit</i> */
<BR>&nbsp;<BR>void _cdecl MyDerivs( fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar, unsigned iexperiment&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;ui i;
<BR>&nbsp;&nbsp;switch( ipar&nbsp;)
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 0: 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for(i=0; i&lt;htZ; i++&nbsp;) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( j=0; j&lt;lenZ; j++&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dZdAi[i][j] = part_derv_MZ_w_resp_to_A<sub>0</sub>( X[j], Y[i]&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 1: 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for(i=0; i&lt;htZ; i++&nbsp;) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( j=0; j&lt;lenZ; j++&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dZdAi[i][j] = part_derv_MZ_w_resp_to_A<sub>1</sub>( X[j], Y[i]&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;default: /*&nbsp;for all derivatives we don't know: */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Mnonlinfit_">MF_multiNonlinfit_autoDeriv</a>( dZdAi, htZ, lenZ, X, Y, ipar, iexperiment, &amp;WorkSpace&nbsp;);
<BR>&nbsp;&nbsp;}
<BR>}</font><BR>
Again, the argument <I>iexperiment</I> allows you to treat &quot;private&quot; parameters of the individual experiments differently from the shared parameters.<BR>
A call to <I>MF_multiNonlinfit</I> will look like:<BR>
<font face="courier new">MF_multiNonlinfit( A, AStatus, npars, ExpList, 2, MyFunc, MyDerivs, &amp;FitOpts, &amp;WorkSpace&nbsp;);</font><BR>
or, with simplified syntax:<BR>
<font face="courier new">MF_multiNonlinfit( A, AStatus, npars, ExpList, 2, MyFunc, MyDerivs&nbsp;);</font><BR>
In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>MF_multiNonlinfit</I> with <I>derivatives</I> = NULL:<BR>
<font face="courier new">MF_multiNonlinfit( A, AStatus, npars, ExpList, 2, MyFunc, NULL&nbsp;);</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( MZ:fMatrix; htZ, lenZ:UIntSize; X,&nbsp;Y:fVector; iexperiment:UInt&nbsp;);
<BR>var i, j:UIntSize;
<BR>begin
<BR>&nbsp;&nbsp;for i:=0 to htZ-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( MZ, htZ, lenZ, i, j&nbsp;)^ := 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f( VF_element( X, j&nbsp;), VF_element( Y, i&nbsp;)&nbsp;);
<BR>end;<BR>
f( X<sub>j</sub>, Y<sub>i</sub>&nbsp;) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>MF_multiNonlinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's MZ values might be scaled by an individual constant C. In this case, <I>A</I> has to contain as many scales C as there are experiments. In MyFunc, you would have to code this as something like:
<BR><font face="courier new">&nbsp;&nbsp;if iexperiment = 0 then
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement(MZ, htZ, lenZ, i, j)^ :=
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_element(MZ, htZ, lenZ, i, j) *&nbsp;VF_element(A,5)
<BR>&nbsp;&nbsp;else MF_Pelement(MZ, htZ, lenZ, i, j)^ :=
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_element(MZ, htZ, lenZ, i, j) *&nbsp;VF_element(A,6);</font>
<P>In addition to the model function, <I>MF_multiNonlinfit</I> needs the partial derivatives of MZ with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#multiNonlinfit_">MF_multiNonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for Pascal/Delphi</td><td>
<font face="courier new">var WorkSpace: MF_NONLINFITWORKSPACE; (*&nbsp;this should be a global variable, the same as passed to <i>MF_multiNonlinfit</i> *)
<BR>&nbsp;<BR>procedure MyDerivs( dZdAi:fMatrix; htZ, lenZ:UIntSize; X,&nbsp;Y:fVector; ipar, iexperiment:UInt&nbsp;);
<BR>var i, j:UIntSize;
<BR>begin
<BR>&nbsp;&nbsp;case ipar of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to htZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( dZdAi, htZ, lenZ, i, j&nbsp;)^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_MZ_w_resp_to_A<sub>0</sub>(VF_element( X, j&nbsp;), VF_element( Y, i&nbsp;)); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;1: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to htZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( dZdAi, htZ, lenZ, i, j&nbsp;)^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_MZ_w_resp_to_A<sub>1</sub>(VF_element( X, j&nbsp;), VF_element( Y, i&nbsp;)); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;
<BR>&nbsp;&nbsp;else (*&nbsp;for all derivatives we don't know: *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Mnonlinfit_">MF_multiNonlinfit_autoDeriv</a>( dZdAi, htZ, lenZ, X, Y, ipar, @WorkSpace&nbsp;);
<BR>&nbsp;&nbsp;end;
<BR>end;</font><BR>
Again, the argument <I>iexperiment</I> allows you to treat &quot;private&quot; parameters of the individual experiments differently from the shared parameters.<BR>
A call to <I>MF_multiNonlinfit</I> will look like:<BR>
<font face="courier new">MF_multiNonlinfit( A, AStatus, npars, @ExpList, 2, @MyFunc, @MyDerivs, @FitOpts, @WorkSpace&nbsp;);</font><BR>
or, in simplified syntax,<BR>
<font face="courier new">MF_multiNonlinfit( A, AStatus, npars, @ExpList, 2, @MyFunc, @MyDerivs&nbsp;);</font><BR>
Note the address-of operator in front of &quot;ExpList&quot;, &quot;MyFunc.&quot;, and &quot;MyDerivs&quot;.  In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>MF_multiNonlinfit</I> with <I>derivatives</I> = <B>nil</B>:<BR>
<font face="courier new">MF_multiNonlinfit( A, AStatus, npars, @ExpList, 2, @MyFunc, nil&nbsp;);</font><BR>
<BR>In the weighted variant, <I>MF_multiNonlinfitwW</I>, the matrix <I>ExpList[i].MInvVar</I> of each experiment has to contain the inverse of the variances of the individual X-Y-Z data points, and the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I>&nbsp;). Theoretically, covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> = covariance( <I>a<sub>j</sub></I>, <I>a<sub>i</sub></I>; due to round-off error, however, small deviations are possible.<BR>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi:</td><td>
For the many different options controlling nonlinear data-fitting functions, please consult <a href="#chap13_3">chapter&nbsp;13.3</a>. Helper functions for breaking off excessively long fitting runs and for the monitoring of these often very time-consuming procedures are summarized in <a href="#chap13_5">chapter&nbsp;13.5</a> and, in the special case of <I>MF_multiNonlinfit</I>, <a href="#multiNonlinfit_">described here</a>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Multi-threading restrictions</td><td>The multi-threading restrictions, present in <i>OptiVec</i> versions up to and including 6.1, have been lifted with v6.2.
<P>These functions may not be called while the FPU is set to reduced accuracy, or else they might hang in an infinite loop. See <I><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If the number of free parameters (i.e., those with AStatus[i] = 1) exceeds the total number of data points, an error message "Invalid parameter(s)" is generated and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>in case of success: goodness-of-fit parameter <font face="symbol">c</font><sup>2</sup> (chi-square);<BR>in case of failure: -1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a>,&nbsp;&nbsp; <a href="#multiNonlinfit">VF_multiNonlinfit</a>,&nbsp;&nbsp; <a href="#Mlinfit">MF_linfit</a>,&nbsp;&nbsp; <a href="#chap13">chapter&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="MmultiNonlinfit_"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiNonlinfit_...</b></font>
</td><td width="33%"><font size="+1"><b>MD_multiNonlinfit_...</b></font></td>
<td><font size="+1"><b>ME_multiNonlinfit_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiNonlinfitwW_...</b></font></td>
<td width="33%"><font size="+1"><b>MD_multiNonlinfitwW_...</b></font></td>
<td><font size="+1"><b>ME_multiNonlinfitwW_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._autoDeriv</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2Detail</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getBestValues</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestRun</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestPar</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestDir</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._stop</B></font></td><td></TD></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>helper functions for <I><a href="#MmultiNonlinfit">MF_multiNonlinfit</a></I> and <I><a href="#MmultiNonlinfit">MF_multiNonlinfitwW</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_multiNonlinfit_autoDeriv( fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar, unsigned iex,  MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
float&nbsp;MF_multiNonlinfit_getChi2(  MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void MF_multiNonlinfit_getChi2Detail( fVector&nbsp;Chi2Detail,  MF_NONLINFITWORKSPACE *ws&nbsp;);
void MF_multiNonlinfit_getBestValues( fVector&nbsp;ABest, MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
int MF_multiNonlinfit_getTestDir( MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned MF_multiNonlinfit_getTestPar( MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned MF_multiNonlinfit_getTestRun( MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void MF_multiNonlinfit_stop( MF_NONLINFITWORKSPACE *ws&nbsp;);</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>MF_nonlinfitwW_...</I> functions)</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFmnlfit;<BR>
procedure MF_multiNonlinfit_autoDeriv( dZdAi:fMatrix; htZ, lenZ:UIntSize; X,&nbsp;Y:fVector; ipar, iex: UInt; PMF_NONLINFITWORKSPACE ws&nbsp;);<BR>
function MF_multiNonlinfit_getChi2( PMF_NONLINFITWORKSPACE ws ): Single;<BR>
procedure MF_multiNonlinfit_getChi2Detail( Chi2Detail:fVector; PMF_NONLINFITWORKSPACE ws&nbsp;);<BR>
procedure MF_multiNonlinfit_getBestValues( BestValues: fVector; PMF_NONLINFITWORKSPACE ws&nbsp;);<BR>
function MF_multiNonlinfit_getTestDir( PMF_NONLINFITWORKSPACE ws ): Integer;<BR>
function MF_multiNonlinfit_getTestPar( PMF_NONLINFITWORKSPACE ws ): UInt;<BR>
function MF_multiNonlinfit_getTestRun( PMF_NONLINFITWORKSPACE ws ): UInt;<BR>
procedure MF_multiNonlinfit_stop( PMF_NONLINFITWORKSPACE ws);</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>MF_multiNonlinfitwW_...</I> functions)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_multiNonlinfit_autoDeriv</I> performs a numerical differentiation of a user-provided z=f(x,y) model function with respect to the parameter <I>a<sub>ipar</sub></I> of the model. All necessary information (model function, current state of parameter set, etc.) is passed to this function through the pointer to the MF_NONLINFITWORKSPACE used in the current <a href="#MmultiNonlinfit">MF_multiNonlinfit</a> operation.<P>
The following functions allow to monitor the progress of a nonlinear fitting operation. They can either be called from within the provided model function or, for multi-thread applications, from a second thread running in parallel to the thread containing the fitting function.<BR>
<I>MF_multiNonlinfit_getChi2</I> returns the best figure-of-merit (<font face="symbol">c</font><sup>2</sup> or, for robust fits, |<font face="symbol">c</font>|) obtained so far. If you call this function before <I>MF_multiNonlinfit</I> has had the chance to calculate <font face="symbol">c</font><sup>2</sup>, <I>MF_multiNonlinfit_getChi2</I> returns -1.0.<P>
<I>MF_multiNonlinfit_getChi2Detail</I> fills the user-supplied vector <I>Chi2Detail</I> with the individual figures-of-merit (<font face="symbol">c</font><sup>2</sup><sub>iex</sub> or, for robust fits, |<font face="symbol">c</font><sub>iex</sub>|) for all experiments. The sum over these individual <font face="symbol">c</font><sup>2</sup><sub>iex</sub> or |<font face="symbol">c</font><sub>iex</sub>| values is the best <font face="symbol">c</font><sup>2</sup> (or |<font face="symbol">c</font>|) obtained so far, as returned by <I>MF_multiNonlinfit_getChi2</I>.<P>
<I>MF_multiNonlinfit_getBestValues</I> stores the best parameters <I>a<sub>i</sub></I> obtained so far into the user-supplied vector <I>ABest</I>.<P>
<I>MF_multiNonlinfit_getTestDir</I> returns the test direction (+1 for upwards, -1 for downwards) during &quot;breakout&quot; attempts from possible <U>local</U> optima which would otherwise prevent the routine from finally reaching the <U>global</U> optimum (level-of-method greater than 3 specified by <I><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a></I>).<P>
<I>MF_multiNonlinfit_getTestPar</I> returns the index of the parameter currently under &quot;breakout&quot; investigation.<P>
<I>MF_multiNonlinfit_getTestRun</I> returns the index of the current &quot;breakout&quot; test run. For each fitted parameter, one test run is performed. The order in which the parameters are checked is determined internally in such a way as to test the most sensitive parameters first.<P>
<I>MF_multiNonlinfit_stop</I> makes <I>MF_multiNonlinfit</I> finish its current Levenberg-Marquardt or Downhill-Simplex cycle, update the output parameters and return. Thereby, long fitting sessions (especially tedious &quot;break-out&quot; attempts) may be broke off without the loss of any data.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13">chapter&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_mulV</b></font>
</td><td width="33%"><font size="+1"><b>MD_mulV</b></font></td>
<td><font size="+1"><b>ME_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulV</b></font></td>
<td><font size="+1"><b>MCE_mulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply a matrix by a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_mulV( fVector&nbsp;Y, fMatrix&nbsp;MA, fVector&nbsp;X, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::mulV( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X &nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_mulV( Y:fVector; MA:fMatrix; X:fVector; htA, lenA:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_mulV( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, fVector&nbsp;d_X, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);
<BR>void MFcu_mulV( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, fVector&nbsp;h_X, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_mulV( d_Y:fVector; d_MA:fMatrix; d_X:fVector; htA,&nbsp;lenA:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_mulV( h_Y:fVector; h_MA:fMatrix; h_X:fVector; htA,&nbsp;lenA:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y = MA *&nbsp;X
<BR>the dimensions of X and Y are implicitly given by the matrix dimensions: sizX = lenA, sizY = htA.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#TmulV">MF_TmulV</a>,&nbsp;&nbsp; <a href="#VmulM">VF_mulM</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="natCubSplineInterpol"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_natCubSplineInterpol</b></font></td><td width="33%"><font size="+1"><b>MD_natCubSplineInterpol</b></font></td><td><font size="+1"><b>ME_natCubSplineInterpol</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Natural cubic-spline interpolation of X-Y-MZ-table values</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;
<BR>void MF_natCubSplineInterpol( fMatrix&nbsp;MZ, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;XTab, fVector&nbsp;YTab, fMatrix&nbsp;MZTab, ui&nbsp;httab, ui&nbsp;lentab&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void matrix&lt;T&gt;::natCubSplineInterpol( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;XTab, const&nbsp;vector&lt;T&gt;&amp;&nbsp;YTab, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZTab&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure MF_natCubSplineInterpol( MZ:fMatrix; X,&nbsp;Y:fVector; ht,&nbsp;len:UIntSize; XTab, YTab:fVector; MZTab:fMatrix; httab, lentab:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_natCubSplineInterpol( fMatrix&nbsp;d_MZ, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;d_XTab, fVector&nbsp;d_YTab, fMatrix&nbsp;d_MZTab, ui&nbsp;httab, ui&nbsp;lentab&nbsp;);
<BR>void MFcu_natCubSplineInterpol( fMatrix&nbsp;h_MZ, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;h_XTab, fVector&nbsp;h_YTab, fMatrix&nbsp;h_MZTab, ui&nbsp;httab, ui&nbsp;lentab&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_natCubSplineInterpol( d_MZ:fMatrix; d_X,&nbsp;d_Y:fVector; ht,&nbsp;len:UIntSize; d_XTab,&nbsp;d_YTab:fVector; d_MZTab:fMatrix; httab,&nbsp;lentab:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_natCubSplineInterpol( h_MZ:fMatrix; h_X,&nbsp;h_Y:fVector; ht,&nbsp;len:UIntSize; h_XTab,&nbsp;h_YTab:fVector; h_MZTab:fMatrix; httab,&nbsp;lentab:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each of the <i>ht</i> *&nbsp;<i>len</i> x / y coordinates defined by X and Y, the corresponding element of MZ is interpolated from the XTab-YTab-MZTab values. XTab and YTab must be ordered (either ascending or descending). All values of XTab as well as of YTab must be distinct; otherwise a division by zero may occur and lead to a program abort. sizetab must be greater than or equal to 3.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (you have to take care yourself that the XTab and YTab values are distinct and that the MZTab values are not near the limit of overflowing).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ratinterpol">MF_ratinterpol</a>,&nbsp;&nbsp; <a href="#polyinterpol">MF_polyinterpol</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#natCubSplineInterpol">VF_natCubSplineInterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="neg"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_neg</b></font>
</td><td width="33%"><font size="+1"><b>MD_neg</b></font></td>
<td><font size="+1"><b>ME_neg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_neg</b></font></td>
<td width="33%"><font size="+1"><b>MCD_neg</b></font></td>
<td><font size="+1"><b>MCE_neg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_neg</b></font></td><td width="20%"><font size="+1"><b>MBI_neg</b></font></td><td width="20%"><font size="+1"><b>MSI_neg</b></font></td><td width="20%"><font size="+1"><b>MLI_neg</b></font></td><td><font size="+1"><b>MQI_neg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>negation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_neg( fMatrix&nbsp;MB, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::neg( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_neg( MB,&nbsp;MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_neg( fMatrix&nbsp;d_MB, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_neg( fMatrix&nbsp;h_MB, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_neg( d_MB,&nbsp;d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_neg( h_MB,&nbsp;h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MBi<sub>,j</sub> = -MA<sub>i,j</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#conj">MCF_conj</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="nfree"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="90%"><font size="+1"><b>M_nfree</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>de-allocate a certain number of matrices (C/C++ only)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void M_nfree( unsigned&nbsp;numfree, ...&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td>This function does not exist</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMatLib.h&gt;
<BR>int cudaM_nfree( unsigned&nbsp;numfree, ...&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The parameter <I>numfree</I> &quot;tells&quot; the function how many matrices it has to free. These matrices follow in the parameter list after <I>numfree</I>. De-allocation of matrices not allocated by one of the functions of the <I><a href="#matrix">MF_matrix</a></I> or <I><a href="#matrix0">MF_matrix0</a></I> family is not possible.
<BR>Pascal/Delphi: since a variable number of parameters is not supported in Pascal language, this function is missing.
</td></tr><tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">M_nfree( 3, MX, MY, MZ&nbsp;);</font></td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#free">M_free</a></I>,&nbsp;&nbsp; <I><a href="FUNCREF.HTM#freeAll">V_freeAll</a>,&nbsp;&nbsp; <a href="#pinnedNfree">cudaM_pinnedNfree</a></I>,&nbsp;&nbsp; <a href="#chap2">chapter&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="nonlinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nonlinfit</b></font>
</td><td width="33%"><font size="+1"><b>VD_nonlinfit</b></font></td>
<td><font size="+1"><b>VE_nonlinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nonlinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>VD_nonlinfitwW</b></font></td>
<td><font size="+1"><b>VE_nonlinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit y=f(x) data to a model-function which may be nonlinear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%">
<tr valign="TOP"><td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;VF_nonlinfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;sizex,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fVector&nbsp;YModel, fVector&nbsp;XModel, ui&nbsp;size),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned iPar),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITWORKSPACE *WorkSpace&nbsp;);<BR>&nbsp;<BR>
float&nbsp;VF_nonlinfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fVector&nbsp;X, fVector&nbsp;Y, fVector&nbsp;InvVar, ui&nbsp;sizex,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fVector&nbsp;YModel, fVector&nbsp;X, ui&nbsp;size),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned i),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITWORKSPACE *WorkSpace&nbsp;);</font></td></tr>
<tr valign="TOP"><td width="15%">Syntax C/C++ simplified</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;VF_nonlinfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;sizex,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fVector&nbsp;YModel, fVector&nbsp;XModel, ui&nbsp;size),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned iPar)&nbsp;);<BR>&nbsp;<BR>
float&nbsp;VF_nonlinfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fVector&nbsp;X, fVector&nbsp;Y, fVector&nbsp;InvVar, ui&nbsp;sizex,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fVector&nbsp;YModel, fVector&nbsp;X, ui&nbsp;size),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned i)&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::nonlinfit( const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fVector&nbsp;YModel, fVector&nbsp;XModel, ui&nbsp;size),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned iPar),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITWORKSPACE *WorkSpace&nbsp;);<BR>&nbsp;<BR>
void vector&lt;T&gt;::nonlinfitwW( matrix&lt;T&gt; Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;InvVar,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fVector&nbsp;YModel, fVector&nbsp;XModel, ui&nbsp;size),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned iPar),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITWORKSPACE *WorkSpace&nbsp;);<BR>&nbsp;<BR>
void vector&lt;T&gt;::nonlinfitwW( matrix&lt;T&gt;*&nbsp;Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;InvVar,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fVector&nbsp;YModel, fVector&nbsp;XModel, ui&nbsp;size),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned iPar),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITWORKSPACE *WorkSpace&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj simplified</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::nonlinfit( const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fVector&nbsp;YModel, fVector&nbsp;XModel, ui&nbsp;size),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned iPar)&nbsp;);<BR>&nbsp;<BR>
void vector&lt;T&gt;::nonlinfitwW( matrix&lt;T&gt; Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;InvVar,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fVector&nbsp;YModel, fVector&nbsp;XModel, ui&nbsp;size),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned iPar)&nbsp;);<BR>&nbsp;<BR>
void vector&lt;T&gt;::nonlinfitwW( matrix&lt;T&gt;*&nbsp;Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;InvVar,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fVector&nbsp;YModel, fVector&nbsp;XModel, ui&nbsp;size),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned iPar)&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses VFnlfit;<BR>
function VF_nonlinfit( A: fVector; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;X,&nbsp;Y: fVector; sizex:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;FitOpts: PVF_NONLINFITOPTIONS;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;WorkSpace: PVF_NONLINFITWORKSPACE&nbsp;): Single;<BR>&nbsp;<BR>
function VF_nonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;X, Y, InvVar:fVector; sizex:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;FitOpts: PVF_NONLINFITOPTIONS;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;WorkSpace: PVF_NONLINFITWORKSPACE&nbsp;): Single;</font>
<BR>Syntax of user-supplied ModelFunc and Derivatives:<BR><font face="courier new">
procedure ModelFunc( YModel, XModel:fVector; size:UIntSize&nbsp;);<BR>
procedure Derivatives( dYdAi, X:fVector; size:UIntSize; ipar:UInt&nbsp;);</font>
</td></tr>
<tr valign="TOP"><td>Pascal/Delphi simplified</td><td><font face="courier new">uses VFnlfit;<BR>
function VF_nonlinfit( A: fVector; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;X,&nbsp;Y: fVector; sizex:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer&nbsp;): Single;<BR>&nbsp;<BR>
function VF_nonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;X, Y, InvVar:fVector; sizex:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer&nbsp;): Single;</font></td></tr>
</table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data X, Y (and InvVar) are used to evaluate the parameter array <I>A</I> with <I>npars</I> elements <I>a<sub>i</sub></I> of an arbitrary model function y = f(x). 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>X,&nbsp;Y,&nbsp;InvVar</td><td>vectors of size <I>sizex</I>, holding the input data</td></tr>
<tr valign="top"><td>modelfunc</td><td>user-defined model function</td></tr>
<tr valign="top"><td>derivatives</td><td>user-defined function, calculating the partial derivatives with respect to all parameters</td></tr>
<tr valign="top"><td>FitOpts</td><td>pointer to a structure containing options, see <I><a href="#chap13_3NONLINFITOPTIONS">chap. 13.3</a></I></td></tr>
<tr valign="top"><td>WorkSpace</td><td>pointer to a structure holding internal variables, see <I><a href="#chap13_3NONLINFITWORKSPACE">chap. 13.3</a></I></td></tr>
<tr valign="top"><td>Return Value</td><td>"goodness-of-fit" value. Depending on the function variant and the chosen figure-of-merit, this is:
<BR>VF_nonlinfitwW with FitOptions.FigureOfMerit=0 (least-square fitting):  <font face="symbol">c</font><sup>2</sup> (chi-square) = <font face="symbol">S</font>) (Ymod[i] - Y[i] )<sup>2</sup> *&nbsp;InvVar[i] );
<BR>VF_nonlinfitwW with FitOptions.FigureOfMerit=1 (robust fitting):  |<font face="symbol">c</font>| (chi-abs) = <font face="symbol">S</font>( abs(Ymod[i] - Y[i] ) *&nbsp;InvVar[i] );
<BR>VF_nonlinfit with FitOptions.FigureOfMerit=0 (least-square fitting, all std errors assumed=1.0):  <font face="symbol">c</font><sup>2</sup> = <font face="symbol">S</font>( (Ymod[i] - Y[i] )<sup>2</sup> ];
<BR>VF_nonlinfit with FitOptions.FigureOfMerit=1 (robust fitting):  |<font face="symbol">c</font>| (chi-abs) = <font face="symbol">S</font>( abs(Ymod[i] - Y[i] ) );
<BR>where <i>Ymod</i> means the theoretical <i>Y</i> values as calculated from the model function with the best parameter set found. For robust fitting, <i>InvVar</i> actually does not have the meaning of inverse variances; one could choose weights as inverse absolute uncertainties instead.</td></tr>
</table>&nbsp;<BR>
The model function (and, consequently, the vector <I>A</I> as well) may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, AStatus, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). All parameters must be initialized in <I>A</I> prior to calling <I>VF_nonlinfit</I>. The better your initial guess of the parameters, the faster <I>VF_nonlinfit</I> shall converge. The argument <I>npars</I> denotes the total number of parameters in <I>A</I> (not only the free parameters!). 
<P>You must provide a model function &quot;modelfunc&quot; which, for a given vector of x-values, must calculate the corresponding &quot;theoretical&quot; y-values. In C/C++, it has to be defined as<BR>
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void _cdecl MyFunc( fVector&nbsp;Y, fVector&nbsp;X, ui&nbsp;size&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;for (ui i=0; i&lt;size; i++&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Y[i] = f( X[i]&nbsp;); 
<BR>}<BR>
f( X[i]&nbsp;) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<BR>In addition to the model function, <I>VF_nonlinfit</I> needs the partial derivatives of Y with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#nonlinfit_">VF_nonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for C/C++</td><td>
<font face="courier new">VF_NONLINFITWORKSPACE WorkSpace;  /*&nbsp;this should be a global variable, the same as passed to <i>VF_nonlinfit</i> */
<BR>&nbsp;<BR>void _cdecl MyDerivs( fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned ipar&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;ui i;
<BR>&nbsp;&nbsp;switch( ipar&nbsp;)
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 0: for(i=0; i&lt;size; i++&nbsp;) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi[i] = part_derv_of_Y_w_resp_to_A<sub>0</sub>( X[i]&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 1: for(i=0; i&lt;size; i++&nbsp;) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi[i] = part_derv_of_Y_w_resp_to_A<sub>1</sub>( X[i]&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;default: /*&nbsp;for all derivatives we don't know: */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#nonlinfit_">VF_nonlinfit_autoDeriv</a>( dYdAi, X, size:UIntSize; ipar, &amp;WorkSpace);
<BR>&nbsp;&nbsp;}
<BR>}</font><BR>
A call to <I>VF_nonlinfit</I> will look like:<BR>
<font face="courier new">VF_nonlinfit( A, AStatus, npars, X, Y, sizex, MyFunc, MyDerivs, &amp;FitOpts, &amp;WorkSpace&nbsp;);</font><BR>
or, in simplified syntax (only if no explicit call to <i>VF_nonlinfit_autoDeriv</i> has to be made):<BR>
<font face="courier new">VF_nonlinfit( A, AStatus, npars, X, Y, sizex, MyFunc, MyDerivs&nbsp;);</font><BR>
In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>VF_nonlinfit</I> with <I>derivatives</I> = NULL:<BR>
<font face="courier new">VF_nonlinfit( A, AStatus, npars, X, Y, sizex, MyFunc, NULL&nbsp;);</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( Y, X:fVector; size:UIntSize&nbsp;);
<BR>var i:UIntSize;
<BR>begin
<BR>&nbsp;&nbsp;for i:=0 to size-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( Y, i&nbsp;)^ := f( VF_element( X, i&nbsp;)&nbsp;);
<BR>end;<BR>
f( X[i]&nbsp;) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<BR>In addition to the model function, <I>VF_nonlinfit</I> needs the partial derivatives of Y with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#nonlinfit_">VF_nonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for Pascal/Delphi</td><td>
<font face="courier new">var WorkSpace: VF_NONLINFITWORKSPACE; (*&nbsp;this should be a global variable, the same as passed to <i>VF_nonlinfit</i> *)
<BR>&nbsp;<BR>procedure MyDerivs( dYdAi, X:fVector; size:UIntSize; ipar:UInt&nbsp;);
<BR>var i:UIntSize;
<BR>begin
<BR>&nbsp;&nbsp;case ipar of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to size-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( dYdAi, i&nbsp;)^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_of_Y_w_resp_to_A<sub>0</sub>(VF_element( X, i&nbsp;)); end;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;1: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to size-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( dYdAi, i&nbsp;)^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_of_Y_w_resp_to_A<sub>0</sub>(VF_element( X, i&nbsp;)); end;
<BR>&nbsp;&nbsp;else (*&nbsp;for all derivatives we don't know: *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#nonlinfit_">VF_nonlinfit_autoDeriv</a>( dYdAi, X, size:UIntSize; ipar, @WorkSpace&nbsp;);
<BR>&nbsp;&nbsp;end;
<BR>end;</font><BR>
A call to <I>VF_nonlinfit</I> will look like:<BR>
<font face="courier new">VF_nonlinfit( A, AStatus, npars, X, Y, sizex, @MyFunc, @MyDerivs, @FitOpts, @WorkSpace&nbsp;);</font><BR>
or, in simplified syntax (only if no explicit call to <i>VF_nonlinfit_autoDeriv</i> has to be made):<BR>
<font face="courier new">VF_nonlinfit( A, AStatus, npars, X, Y, sizex, @MyFunc, @MyDerivs&nbsp;);</font><P>
Note the address-of operator in front of &quot;MyFunc.&quot; and &quot;MyDerivs&quot;. In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>VF_nonlinfit</I> with <I>derivatives</I> = <B>nil</B>:<BR>
<font face="courier new">VF_nonlinfit( A, AStatus, npars, X, Y, sizex, @MyFunc, nil&nbsp;);</font><BR>
<BR>In the weighted variant, <I>VF_nonlinfitwW</I>, the vector <I>InvVar</I> has to contain the inverse of the variances of the individual X-Y data points, and the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I>&nbsp;). Theoretically, covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> = covariance( <I>a<sub>j</sub></I>, <I>a<sub>i</sub></I>; due to round-off error, however, small deviations are possible.<BR>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi:</td><td>
For the many different options controlling nonlinear data-fitting functions, please consult <a href="#chap13_3">chapter&nbsp;13.3</a>. Helper functions for breaking off excessively long fitting runs and for the monitoring of these often very time-consuming procedures are summarized in <a href="#chap13_5">chapter&nbsp;13.5</a> and, in the special case of <I>VF_nonlinfit</I>, <a href="#nonlinfit_">described here</a>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Multi-threading restrictions</td><td>The multi-threading restrictions, present in <i>OptiVec</i> versions up to and including 6.1, have been lifted with v6.2.
<P>These functions may not be called while the FPU is set to reduced accuracy, or else they might hang in an infinite loop. See <I><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If the number of free parameters (i.e., those with AStatus[i] = 1) exceeds the total number of data points, an error message "Invalid parameter(s)" is generated and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>in case of success: goodness-of-fit value, see above. In case of failure: -1.0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a>,&nbsp;&nbsp; <a href="#Mnonlinfit">MF_nonlinfit</a>,&nbsp;&nbsp; <a href="#multiNonlinfit">VF_multiNonlinfit</a>,&nbsp;&nbsp; <a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="#chap13">chapter&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="nonlinfit_"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nonlinfit_...</b></font>
</td><td width="33%"><font size="+1"><b>VD_nonlinfit_...</b></font></td>
<td><font size="+1"><b>VE_nonlinfit_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nonlinfitwW_...</b></font></td>
<td width="33%"><font size="+1"><b>VD_nonlinfitwW_...</b></font></td>
<td><font size="+1"><b>VE_nonlinfitwW_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._autoDeriv</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getBestValues</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestRun</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestPar</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestDir</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._stop</B></font></td><td></TD></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>helper functions for <I><a href="#nonlinfit">VF_nonlinfit</a></I> and <I><a href="#nonlinfit">VF_nonlinfitwW</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_nonlinfit_autoDeriv( fVector&nbsp;dYdAi, fVector&nbsp;X, ui&nbsp;size, unsigned ipar, VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
float&nbsp;VF_nonlinfit_getChi2( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void VF_nonlinfit_getBestValues( fVector&nbsp;ABest, VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
int VF_nonlinfit_getTestDir( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned VF_nonlinfit_getTestPar( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned VF_nonlinfit_getTestRun( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void VF_nonlinfit_stop( VF_NONLINFITWORKSPACE *ws&nbsp;);</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>VF_nonlinfitwW_...</I> functions)</td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::nonlinfit_getChi2( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void vector&lt;T&gt;::nonlinfit_getBestValues( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned vector&lt;T&gt;::nonlinfit_getTestPar( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned vector&lt;T&gt;::nonlinfit_getTestRun( VF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void vector&lt;T&gt;::nonlinfit_stop( VF_NONLINFITWORKSPACE *ws&nbsp;);</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>VF_nonlinfitwW_...</I> functions)</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses VFnlfit;<BR>
procedure VF_nonlinfit_autoDeriv( dYdAi, X: fVector; size:UIntSize; ipar:UInt; PVF_NONLINFITWORKSPACE ws&nbsp;);<BR>
function VF_nonlinfit_getChi2( PVF_NONLINFITWORKSPACE ws&nbsp;): Single;<BR>
procedure VF_nonlinfit_getBestValues( BestValues: fVector; PVF_NONLINFITWORKSPACE ws&nbsp;);<BR>
function VF_nonlinfit_getTestDir( PVF_NONLINFITWORKSPACE ws&nbsp;): Integer;<BR>
function VF_nonlinfit_getTestPar( PVF_NONLINFITWORKSPACE ws&nbsp;): UInt;<BR>
function VF_nonlinfit_getTestRun( PVF_NONLINFITWORKSPACE ws&nbsp;): UInt;<BR>
procedure VF_nonlinfit_stop( PVF_NONLINFITWORKSPACE ws&nbsp;);</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>VF_nonlinfitwW_...</I> functions)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>VF_nonlinfit_autoDeriv</I> performs a numerical differentiation of a user-provided y=f(x) model function with respect to the parameter <I>a<sub>ipar</sub></I> of the model. All necessary information (model function, current state of parameter set, etc.) is passed to this function through the pointer to the VF_NONLINFITWORKSPACE used in the current <a href="#nonlinfit">VF_nonlinfit</a> operation.<P>
The following functions allow to monitor the progress of a nonlinear fitting operation. They can either be called from within the provided model function or, for multi-thread applications, from a second thread running in parallel to the thread containing the fitting function.<BR>
<I>VF_nonlinfit_getChi2</I> returns the best figure-of-merit (<font face="symbol">c</font><sup>2</sup> or, for robust fits, |<font face="symbol">c</font>|) obtained so far. If you call this function before <I>VF_nonlinfit</I> has had the chance to calculate <font face="symbol">c</font><sup>2</sup>, <I>VF_nonlinfit_getChi2</I> returns -1.0.<P>
<I>VF_nonlinfit_getBestValues</I> stores the best parameters <I>a<sub>i</sub></I> obtained so far into the user-supplied vector <I>ABest</I>.<P>
<I>VF_nonlinfit_getTestDir</I> returns the test direction (+1 for upwards, -1 for downwards) during &quot;breakout&quot; attempts from possible <U>local</U> optima which would otherwise prevent the routine from finally reaching the <U>global</U> optimum (level-of-method greater than 3 specified by <I><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a></I>).<P>
<I>VF_nonlinfit_getTestPar</I> returns the index of the parameter currently under &quot;breakout&quot; investigation.<P>
<I>VF_nonlinfit_getTestRun</I> returns the index of the current &quot;breakout&quot; test run. For each fitted parameter, one test run is performed. The order in which the parameters are checked is determined internally in such a way as to test the most sensitive parameters first.<P>
<I>VF_nonlinfit_stop</I> makes <I>VF_nonlinfit</I> finish its current Levenberg-Marquardt or Downhill-Simplex cycle, update the output parameters and return. Thereby, long fitting sessions (especially tedious &quot;break-out&quot; attempts) may be broke off without the loss of any data.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13">chapter&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Mnonlinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_nonlinfit</b></font>
</td><td width="33%"><font size="+1"><b>MD_nonlinfit</b></font></td>
<td><font size="+1"><b>ME_nonlinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_nonlinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>MD_nonlinfitwW</b></font></td>
<td><font size="+1"><b>ME_nonlinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit z=f(x,y) data to a model-function which may be nonlinear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%">
<tr valign="TOP"><td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_nonlinfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fVector&nbsp;X, fVector&nbsp;Y, fMatrix&nbsp;Z, ui&nbsp;htZ, ui&nbsp;lenZ,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MF_NONLINFITWORKSPACE *WorkSpace&nbsp;);<BR>&nbsp;<BR>
float&nbsp;MF_nonlinfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fVector&nbsp;X, fVector&nbsp;Y, fMatrix&nbsp;Z, fMatrix&nbsp;InvVar, ui&nbsp;htZ, ui&nbsp;lenZ,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MF_NONLINFITWORKSPACE *WorkSpace&nbsp;);</font></td></tr>
<tr valign="TOP"><td width="15%">Syntax C/C++ simplified</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_nonlinfit( fVector&nbsp;A, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fVector&nbsp;X, fVector&nbsp;Y, fMatrix&nbsp;Z, ui&nbsp;htZ, ui&nbsp;lenZ,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar)&nbsp;);<BR>&nbsp;<BR>
float&nbsp;MF_nonlinfitwW( fVector&nbsp;A, fMatrix Covar, iVector&nbsp;AStatus, unsigned&nbsp;npars,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fVector&nbsp;X, fVector&nbsp;Y, fMatrix&nbsp;Z, fMatrix&nbsp;InvVar, ui&nbsp;htZ, ui&nbsp;lenZ,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar)&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::nonlinfit( const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZ,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MF_NONLINFITWORKSPACE *WorkSpace&nbsp;);<BR>&nbsp;<BR>
void vector&lt;T&gt;::nonlinfitwW( matrix&lt;T&gt; Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZ, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MInvVar,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MF_NONLINFITWORKSPACE *WorkSpace&nbsp;);<BR>&nbsp;<BR>
void vector&lt;T&gt;::nonlinfitwW( matrix&lt;T&gt;*&nbsp;Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZ, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MInvVar,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;VF_NONLINFITOPTIONS *FitOpts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MF_NONLINFITWORKSPACE *WorkSpace&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj simplified</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::nonlinfit( const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZ,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar)&nbsp;);<BR>&nbsp;<BR>
void vector&lt;T&gt;::nonlinfitwW( matrix&lt;T&gt; Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZ, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MInvVar,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar)&nbsp;);<BR>&nbsp;<BR>
void vector&lt;T&gt;::nonlinfitwW( matrix&lt;T&gt;*&nbsp;Covar, const&nbsp;vector&lt;int&gt;&amp;&nbsp;AStatus,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZ, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MInvVar,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void modelfunc(fMatrix&nbsp;ZModel, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y&nbsp;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void derivatives(fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar)&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFnlfit;<BR>
function MF_nonlinfit( A: fVector; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;X,&nbsp;Y: fVector; MZ: fMatrix; htZ, lenZ:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;FitOpts: PVF_NONLINFITOPTIONS;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;WorkSpace: PMF_NONLINFITWORKSPACE&nbsp;): Single;<BR>&nbsp;<BR>
function MF_nonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;X,&nbsp;Y: fVector; MZ, MInvVar: fMatrix; htZ, lenZ:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;FitOpts: PVF_NONLINFITOPTIONS;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;WorkSpace: PMF_NONLINFITWORKSPACE&nbsp;): Single;</font>
<BR>Syntax of user-supplied ModelFunc and Derivatives:<BR><font face="courier new">
procedure ModelFunc( ZModel:fMatrix; htZ, lenZ:UIntSize; X,&nbsp;Y:fVector&nbsp;);<BR>
procedure Derivatives( dZdAi:fMatrix; htZ, lenZ:UIntSize; X,&nbsp;Y:fVector; ipar:UInt&nbsp;);</font>
</td></tr>
<tr valign="TOP"><td>Pascal/Delphi simplified</td><td><font face="courier new">uses MFnlfit;<BR>
function MF_nonlinfit( A: fVector; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;X,&nbsp;Y: fVector; MZ: fMatrix; htZ, lenZ:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer&nbsp;): Single;<BR>&nbsp;<BR>
function MF_nonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;X,&nbsp;Y: fVector; MZ, MInvVar: fMatrix; htZ, lenZ:UIntSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ModelFunc, Derivatives: Pointer&nbsp;): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data X, Y, MZ (and MInvVar) are used to evaluate the parameter array <I>A</I> with <I>npars</I> elements <I>a<sub>i</sub></I> of an arbitrary model function z = f(x,y). 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>X,&nbsp;Y</td><td>vectors of size <I>lenZ</I> and <I>htZ</I>, respectively, spanning the x-y coordinate system of the matrix MZ</td></tr>
<tr valign="top"><td>MZ,&nbsp;MInvVar</td><td>matrices of dimensions [htZ, lenZ], holding the input data and, in the weighted variant, the inverse of their variances</td></tr>
<tr valign="top"><td>modelfunc</td><td>user-defined model function</td></tr>
<tr valign="top"><td>derivatives</td><td>user-defined function, calculating the partial derivatives with respect to all parameters</td></tr>
<tr valign="top"><td>FitOpts</td><td>pointer to a structure containing options, see <I><a href="#chap13_3NONLINFITOPTIONS">chap. 13.3</a></I></td></tr>
<tr valign="top"><td>WorkSpace</td><td>pointer to a structure holding internal variables, see <I><a href="#chap13_3NONLINFITWORKSPACE">chap. 13.3</a></I></td></tr>
<tr valign="top"><td>Return Value</td><td>"goodness-of-fit" value. Depending on the function variant and the chosen figure-of-merit, this is:
<BR>MF_nonlinfitwW with FitOptions.FigureOfMerit=0 (least-square fitting):  <font face="symbol">c</font><sup>2</sup> (chi-square) = <font face="symbol">S</font>) (MZmod[i,j] - MZ[i,j] )<sup>2</sup> *&nbsp;MInvVar[i,j] );
<BR>MF_nonlinfitwW with FitOptions.FigureOfMerit=1 (robust fitting):  |<font face="symbol">c</font>| (chi-abs) = <font face="symbol">S</font>( abs(MZmod[i,j] - MZ[i,j] ) *&nbsp;MInvVar[i,j] );
<BR>MF_nonlinfit with FitOptions.FigureOfMerit=0 (least-square fitting, all std errors assumed=1.0):  <font face="symbol">c</font><sup>2</sup> = <font face="symbol">S</font>( (MZmod[i,j] - MZ[i,j] )<sup>2</sup> ];
<BR>MF_nonlinfit with FitOptions.FigureOfMerit=1 (robust fitting):  |<font face="symbol">c</font>| (chi-abs) = <font face="symbol">S</font>( abs(MZmod[i,j] - MZ[i,j] ) );
<BR>where <i>MZmod</i> means the theoretical <i>MZ</i> values as calculated from the model function with the best parameter set found. For robust fitting, <i>MInvVar</i> actually does not have the meaning of inverse variances; one could choose weights as inverse absolute uncertainties instead.</td></tr>
</table>&nbsp;<BR>
The model function (and, consequently, the vector <I>A</I> as well) may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, <I>AStatus</I>, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). All parameters must be initialized in <I>A</I> prior to calling <I>MF_nonlinfit</I>. The better your initial guess of the parameters, the faster <I>MF_nonlinfit</I> shall converge. The argument <I>npars</I> denotes the total number of parameters in <I>A</I> (not only the free parameters!). 
<P>You must provide a model function &quot;modelfunc&quot; which, for given vectors of x and y values, must calculate the corresponding &quot;theoretical&quot; z values. In C/C++, it has to be defined as<BR>
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void _cdecl MyFunc( fMatrix&nbsp;Z, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;for (ui i=0; i&lt;htZ; i++&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for (ui j=0; j&lt;lenZ; j++&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MZ[i][j] = f( X[j], Y[i]&nbsp;); 
<BR>}<BR>
f( X[j], Y[i]&nbsp;) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<BR>In addition to the model function, <I>MF_nonlinfit</I> needs the partial derivatives of MZ with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#Mnonlinfit_">MF_nonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for C/C++</td><td>
<font face="courier new">MF_NONLINFITWORKSPACE WorkSpace;  /*&nbsp;this should be a global variable, the same as passed to <i>MF_nonlinfit</i> */
<BR>&nbsp;<BR>void _cdecl MyDerivs( fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar&nbsp;)
<BR>{
<BR>&nbsp;&nbsp;ui i;
<BR>&nbsp;&nbsp;switch( ipar&nbsp;)
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 0: 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for(i=0; i&lt;htZ; i++&nbsp;) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( j=0; j&lt;lenZ; j++&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dZdAi[i][j] = part_derv_MZ_w_resp_to_A<sub>0</sub>( X[j], Y[i]&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 1: 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for(i=0; i&lt;htZ; i++&nbsp;) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( j=0; j&lt;lenZ; j++&nbsp;)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dZdAi[i][j] = part_derv_MZ_w_resp_to_A<sub>1</sub>( X[j], Y[i]&nbsp;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;default: /*&nbsp;for all derivatives we don't know: */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Mnonlinfit_">MF_nonlinfit_autoDeriv</a>( dZdAi, htZ, lenZ, X, Y, ipar, &amp;WorkSpace&nbsp;);
<BR>&nbsp;&nbsp;}
<BR>}</font><BR>
A call to <I>MF_nonlinfit</I> will look like:<BR>
<font face="courier new">MF_nonlinfit( A, AStatus, npars, X, Y, MZ, htZ, lenZ, MyFunc, MyDerivs, &amp;FitOpts, &amp;WorkSpace&nbsp;);</font><BR>
or, in simplified syntax (only, if no explicit call to <i>MF_nonlinfit_autoDeriv</i> has to be made:<BR>
<font face="courier new">MF_nonlinfit( A, AStatus, npars, X, Y, MZ, htZ, lenZ, MyFunc, MyDerivs&nbsp;);</font><BR>
In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>MF_nonlinfit</I> with <I>derivatives</I> = NULL:<BR>
<font face="courier new">MF_nonlinfit( A, AStatus, npars, X, Y, MZ, htZ, lenZ, MyFunc, NULL&nbsp;);</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( MZ:fMatrix; htZ, lenZ:UIntSize; X,&nbsp;Y:fVector&nbsp;);
<BR>var i, j:UIntSize;
<BR>begin
<BR>&nbsp;&nbsp;for i:=0 to htZ-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( MZ, htZ, lenZ, i, j&nbsp;)^ := 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f( VF_element( X, j&nbsp;), VF_element( Y, i&nbsp;)&nbsp;);
<BR>end;<BR>
f( X<sub>j</sub>, Y<sub>i</sub>&nbsp;) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<BR>In addition to the model function, <I>MF_nonlinfit</I> needs the partial derivatives of MZ with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#Mnonlinfit_">MF_nonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for Pascal/Delphi</td><td>
<font face="courier new">var WorkSpace: MF_NONLINFITWORKSPACE; (*&nbsp;this should be a global variable, the same as passed to <i>MF_nonlinfit</i> *)
<BR>&nbsp;<BR>procedure MyDerivs( dZdAi:fMatrix; htZ, lenZ:UIntSize; X,&nbsp;Y:fVector; ipar:UInt&nbsp;);
<BR>var i, j:UIntSize;
<BR>begin
<BR>&nbsp;&nbsp;case ipar of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to htZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( dZdAi, htZ, lenZ, i, j&nbsp;)^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_MZ_w_resp_to_A<sub>0</sub>(VF_element( X, j&nbsp;), VF_element( Y, i&nbsp;)); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;1: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to htZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( dZdAi, htZ, lenZ, i, j&nbsp;)^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_MZ_w_resp_to_A<sub>1</sub>(VF_element( X, j&nbsp;), VF_element( Y, i&nbsp;)); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;
<BR>&nbsp;&nbsp;else (*&nbsp;for all derivatives we don't know: *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Mnonlinfit_">MF_nonlinfit_autoDeriv</a>( dZdAi, htZ, lenZ, X, Y, ipar, @WorkSpace&nbsp;);
<BR>&nbsp;&nbsp;end;
<BR>end;</font><BR>
A call to <I>MF_nonlinfit</I> will look like:<BR>
<font face="courier new">MF_nonlinfit( A, AStatus, npars, MZ, htZ, lenZ, X, Y, @MyFunc, @MyDerivs, @FitOpts, @WorkSpace&nbsp;);</font><BR>
or, in simplified syntax (only, if no explicit call to <i>MF_nonlinfit_autoDeriv</i> has to be made:<BR>
<font face="courier new">MF_nonlinfit( A, AStatus, npars, MZ, htZ, lenZ, X, Y, @MyFunc, @MyDerivs&nbsp;);</font><BR>
Note the address-of operator in front of &quot;MyFunc.&quot; and &quot;MyDerivs&quot;.  In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>MF_nonlinfit</I> with <I>derivatives</I> = <B>nil</B>:<BR>
<font face="courier new">MF_nonlinfit( A, AStatus, npars, MZ, htZ, lenZ, X, Y, @MyFunc, nil&nbsp;);</font><BR>
<BR>In the weighted variant, <I>MF_nonlinfitwW</I>, the matrix <I>MInvVar</I> has to contain the inverse of the variances of the individual X-Y-Z data points, and the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I>&nbsp;). Theoretically, covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> = covariance( <I>a<sub>j</sub></I>, <I>a<sub>i</sub></I>; due to round-off error, however, small deviations are possible.<BR>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi:</td><td>
For the many different options controlling nonlinear data-fitting functions, please consult <a href="#chap13_3">chapter&nbsp;13.3</a>. Helper functions for breaking off excessively long fitting runs and for the monitoring of these often very time-consuming procedures are summarized in <a href="#chap13_5">chapter&nbsp;13.5</a> and, in the special case of <I>MF_nonlinfit</I>, <a href="#Mnonlinfit_">described here</a>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Multi-threading restrictions</td><td>The multi-threading restrictions, present in <i>OptiVec</i> versions up to and including 6.1, have been lifted with v6.2.
<P>These functions may not be called while the FPU is set to reduced accuracy, or else they might hang in an infinite loop. See <I><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If the number of free parameters (i.e., those with AStatus[i] = 1) exceeds the total number of data points, an error message "Invalid parameter(s)" is generated and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>in case of success: goodness-of-fit parameter <font face="symbol">c</font><sup>2</sup> (chi-square);<BR>in case of failure: -1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a>,&nbsp;&nbsp; <a href="#nonlinfit">VF_nonlinfit</a>,&nbsp;&nbsp; <a href="#MmultiNonlinfit">MF_multiNonlinfit</a>,&nbsp;&nbsp; <a href="#linfit">MF_linfit</a>,&nbsp;&nbsp; <a href="#chap13">chapter&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Mnonlinfit_"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_nonlinfit_...</b></font>
</td><td width="33%"><font size="+1"><b>MD_nonlinfit_...</b></font></td>
<td><font size="+1"><b>ME_nonlinfit_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_nonlinfitwW_...</b></font></td>
<td width="33%"><font size="+1"><b>MD_nonlinfitwW_...</b></font></td>
<td><font size="+1"><b>ME_nonlinfitwW_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._autoDeriv</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getBestValues</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestRun</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestPar</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestDir</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._stop</B></font></td><td></TD></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>helper functions for <I><a href="#Mnonlinfit">MF_nonlinfit</a></I> and <I><a href="#Mnonlinfit">MF_nonlinfitwW</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_nonlinfit_autoDeriv( fMatrix dZdAi, ui&nbsp;htZ, ui&nbsp;lenZ, fVector&nbsp;X, fVector&nbsp;Y, unsigned ipar, MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
float&nbsp;MF_nonlinfit_getChi2( MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void MF_nonlinfit_getBestValues( fVector&nbsp;ABest, MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned MF_nonlinfit_getTestRun( MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned MF_nonlinfit_getTestPar( MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
int MF_nonlinfit_getTestDir( MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void MF_nonlinfit_stop( MF_NONLINFITWORKSPACE *ws&nbsp;);</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>MF_nonlinfitwW_...</I> functions)</td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::nonlinfit_getChi2( MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void vector&lt;T&gt;::Mnonlinfit_getBestValues( MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned&nbsp;matrix&lt;T&gt;::nonlinfit_getTestPar( MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
unsigned&nbsp;matrix&lt;T&gt;::nonlinfit_getTestRun( MF_NONLINFITWORKSPACE *ws&nbsp;);<BR>
void matrix&lt;T&gt;::nonlinfit_stop( MF_NONLINFITWORKSPACE *ws&nbsp;);</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>nonlinfitwW_...</I> functions)</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFnlfit;<BR>
procedure MF_nonlinfit_autoDeriv( dZdAi:fMatrix; htZ, lenZ:UIntSize; X,&nbsp;Y:fVector; ipar: UInt; ws:&nbsp;PMF_NONLINFITWORKSPACE&nbsp;);<BR>
function MF_nonlinfit_getChi2( ws:&nbsp;PMF_NONLINFITWORKSPACE&nbsp;): Single;<BR>
procedure MF_nonlinfit_getBestValues( BestValues: fVector; ws:&nbsp;PMF_NONLINFITWORKSPACE&nbsp;);<BR>
function MF_nonlinfit_getTestRun( ws:&nbsp;PMF_NONLINFITWORKSPACE&nbsp;): UInt;<BR>
function MF_nonlinfit_getTestPar( ws:&nbsp;PMF_NONLINFITWORKSPACE&nbsp;): UInt;<BR>
function MF_nonlinfit_getTestDir( ws:&nbsp;PMF_NONLINFITWORKSPACE&nbsp;): Integer;<BR>
procedure MF_nonlinfit_stop( ws:&nbsp;PMF_NONLINFITWORKSPACE&nbsp;);</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>MF_nonlinfitwW_...</I> functions)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_nonlinfit_autoDeriv</I> performs a numerical differentiation of a user-provided z=f(x,y) model function with respect to the parameter <I>a<sub>ipar</sub></I> of the model. This function can be called only from within a function passed as the argument &quot;derivatives&quot; to <a href="#Mnonlinfit">MF_nonlinfit</a>. The model function that is differentiated by <I>MF_nonlinfit_autoDeriv</I> is the one passed in the same call to <a href="#nonlinfit">MF_nonlinfit</a> (see that function for details!).<P>
The following functions allow to monitor the progress of a nonlinear fitting operation. They can either be called from within the provided model function or, for multi-thread applications, from a second thread running in parallel to the thread containing the fitting function.<BR>
<I>MF_nonlinfit_getChi2</I> returns the best figure-of-merit (<font face="symbol">c</font><sup>2</sup> or, for robust fits, |<font face="symbol">c</font>|) obtained so far. If you call this function before <I>MF_nonlinfit</I> has had the chance to calculate <font face="symbol">c</font><sup>2</sup>, <I>MF_nonlinfit_getChi2</I> returns -1.0.<P>
<I>MF_nonlinfit_getBestValues</I> stores the best parameters <I>a<sub>i</sub></I> obtained so far into the user-supplied vector <I>ABest</I>.<P>
<I>MF_nonlinfit_getTestDir</I> returns the test direction (+1 for upwards, -1 for downwards) during &quot;breakout&quot; attempts from possible <U>local</U> optima which would otherwise prevent the routine from finally reaching the <U>global</U> optimum (level-of-method greater than 3 specified by <I><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a></I>).<P>
<I>MF_nonlinfit_getTestPar</I> returns the index of the parameter currently under &quot;breakout&quot; investigation.<P>
<I>MF_nonlinfit_getTestRun</I> returns the index of the current &quot;breakout&quot; test run. For each fitted parameter, one test run is performed. The order in which the parameters are checked is determined internally in such a way as to test the most sensitive parameters first.<P>
<I>MF_nonlinfit_stop</I> makes <I>MF_nonlinfit</I> finish its current Levenberg-Marquardt or Downhill-Simplex cycle, update the output parameters and return. Thereby, long fitting sessions (especially tedious &quot;break-out&quot; attempts) may be broke off without the loss of any data.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13">chapter&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="outerprod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_outerprod</b></font>
</td><td width="33%"><font size="+1"><b>MD_outerprod</b></font></td>
<td><font size="+1"><b>ME_outerprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_outerprod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_outerprod</b></font></td>
<td><font size="+1"><b>MCE_outerprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_outerprod</b></font></td><td width="20%"><font size="+1"><b>MBI_outerprod</b></font></td><td width="20%"><font size="+1"><b>MSI_outerprod</b></font></td><td width="20%"><font size="+1"><b>MLI_outerprod</b></font></td><td><font size="+1"><b>MQI_outerprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_outerprod</b></font></td><td width="20%"><font size="+1"><b>MUB_outerprod</b></font></td><td width="20%"><font size="+1"><b>MUS_outerprod</b></font></td><td width="20%"><font size="+1"><b>MUL_outerprod</b></font></td><td><font size="+1"><b>MUQ_outerprod;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>formation of a matrix by the &quot;outer product&quot; of two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_outerprod( fMatrix&nbsp;MA, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::outerprod( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_outerprod( MA:fMatrix; X,&nbsp;Y:fVector; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_outerprod( fMatrix&nbsp;d_MA, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_outerprod( fMatrix&nbsp;h_MA, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_outerprod( d_MA:fMatrix; d_X,&nbsp;d_Y:fVector; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MF_outerprod( h_MA:fMatrix; h_X,&nbsp;h_Y:fVector; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = X<sub>i</sub> *&nbsp;Y<sub>j</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#VmulM">VF_mulM</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Parzen"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Parzen</b></font>
</td><td width="33%"><font size="+1"><b>MD_Parzen</b></font></td>
<td><font size="+1"><b>ME_Parzen</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>two-dimensional Parzen window for spatial frequency analysis</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Parzen( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Parzen(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Parzen( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Parzen( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Parzen( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Parzen( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Parzen( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = (1 - |(i - 0.5*(ht - 1)) / 0.5*(ht + 1)|) *&nbsp;(1 - |(j - 0.5*(len - 1)) / 0.5*(len + 1)|)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Hann">MF_Hann</a>,&nbsp;&nbsp; <a href="#Welch">MF_Welch</a>,&nbsp;&nbsp; <a href="#spectrum">MF_spectrum</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Pelement"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Pelement</b></font>
</td><td width="33%"><font size="+1"><b>MD_Pelement</b></font></td>
<td><font size="+1"><b>ME_Pelement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Pelement</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Pelement</b></font></td>
<td><font size="+1"><b>MCE_Pelement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Pelement</b></font></td><td width="20%"><font size="+1"><b>MBI_Pelement</b></font></td><td width="20%"><font size="+1"><b>MSI_Pelement</b></font></td><td width="20%"><font size="+1"><b>MLI_Pelement</b></font></td><td><font size="+1"><b>MQI_Pelement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Pelement</b></font></td><td width="20%"><font size="+1"><b>MUB_Pelement</b></font></td><td width="20%"><font size="+1"><b>MUS_Pelement</b></font></td><td width="20%"><font size="+1"><b>MUL_Pelement</b></font></td><td><font size="+1"><b>MUQ_Pelement</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>get pointer to a matrix element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;*&nbsp;MF_Pelement( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T *&nbsp;matrix&lt;T&gt;::Pelement( const&nbsp;unsigned&nbsp;m, const&nbsp;unsigned&nbsp;n&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Pelement( MA:fMatrix; ht,&nbsp;len,&nbsp;m,&nbsp;n:UIntSize&nbsp;):&nbsp;PSingle;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>float&nbsp;*&nbsp;cudaMF_Pelement( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Pelement( d_MA:fMatrix; ht,&nbsp;len,&nbsp;m,&nbsp;n:UIntSize&nbsp;):&nbsp;PSingle;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A pointer to the element MA<sub>m,n</sub> is returned.
<BR>It is possible to use this function for write access to a matrix element through the dereferenced-pointer syntax:</td></tr><tr valign="TOP">
<td>C/C++</td><td><font face="courier new">*MF_Pelement( MA, ht,&nbsp;len,&nbsp;m, n&nbsp;) = 3.5;</font></td></tr><tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">MF_Pelement( MA, ht,&nbsp;len,&nbsp;m, n&nbsp;)^ := 3.5;</font>
<BR>This sort of write access is not possible for the CUDA version of this function.
<P>As a safer way of writing single elements, use <I><a href="#setElement">MF_setElement</a></I>. 
<P>Read-only access to matrix elements is provided by the related functions, <I><a href="#element">MF_element</a></I> and <I><a href="#getElement">MF_getElement</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>pointer to the matrix element MA<sub>m,n</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#element">MF_element</a>,&nbsp;&nbsp; <a href="#getElement">MF_getElement</a>,&nbsp;&nbsp; <a href="#setElement">MF_setElement</a>,&nbsp;&nbsp; </I><a href="#chap2">chapter&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pinnedFree"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>cudaM_pinnedFree</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td><i>cudaOptiVec</i> only: De-allocate a single pinned host-memory matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMatLib.h&gt;
<BR>int cudaM_pinnedFree( void **h_MA&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function cudaM_pinnedFree( h_X:Pointer&nbsp;):&nbsp;IntBool;
</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The pinned host-memory matrix MA is freed (i.e. de-allocated). This function needs the host address (not the device address!) of the pinned matrix as an argument. To free several pinned matrices simultaneously, use <I><a href="#pinnedNfree">cudaM_pinnedNfree</a></I> (C/C++ only).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Trying to free a pinned matrix that has already been freed, or that has never been allocated memory, leads to a warning message &quot;Cannot free non-existent vector&quot;. Program execution is continued without freeing anything in this case.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0) in case of success, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a>, &nbsp;&nbsp;<I><a href="#pinnedNfree">cudaM_pinnedNfree</a>,&nbsp;&nbsp; <a href="#pinnedFreeAll">cudaV_pinnedFreeAll</a>,&nbsp;&nbsp; <a href="#pinnedMatrix">cudaMF_pinnedMatrix</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="pinnedMatrix"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaMF_pinnedMatrix</b></font>
</td><td width="34%"><font size="+1"><b>cudaMD_pinnedMatrix</b></font></td>
<td><font size="+1"><b>cudaME_pinnedMatrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaMCF_pinnedMatrix</b></font></td>
<td width="34%"><font size="+1"><b>cudaMCD_pinnedMatrix</b></font></td>
<td><font size="+1"><b>cudaMCE_pinnedMatrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaMI_pinnedMatrix</b></font></td><td width="34%"><font size="+1"><b>cudaMBI_pinnedMatrix</b></font></td><td><font size="+1"><b>cudaMSI_pinnedMatrix</b></font></td></tr>
<tr valign="TOP"><td width="33%"><font size="+1"><b>cudaMLI_pinnedMatrix</b></font></td><td width="34%"><font size="+1"><b>cudaMQI_pinnedMatrix</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaMU_pinnedMatrix</b></font></td><td width="34%"><font size="+1"><b>cudaMUB_pinnedMatrix</b></font></td><td><font size="+1"><b>cudaMUS_pinnedMatrix</b></font></td></tr>
<tr valign="TOP"><td width="33%"><font size="+1"><b>cudaMUL_pinnedMatrix</b></font></td><td width="34%"><font size="+1"><b>cudaMUQ_pinnedMatrix</b></font></td><td><font size="+1"><b>cudaMUI_pinnedMatrix</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Pinned host-memory allocation for a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>fMatrix&nbsp;cudaMF_pinnedMatrix( fMatrix *h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function cudaMF_pinnedMatrix( var&nbsp;h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;fMatrix;</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Pinned host memory is allocated. The device pointer is returned, and the host pointer is stored as h_MA. In order to release the memory thus allocated, use <I><a href="#pinnedFree">cudaM_pinnedFree</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#pinnedFreeAll">cudaV_pinnedFreeAll</a></I>, or <I><a href="#pinnedNfree">cudaM_pinnedNfree</a></I> (the latter only in C/C++).
<BR>See <a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a> for a description of the various memory types of <i>cudaOptiVec</i> routines.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Device pointer to the allocated matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a>, &nbsp;&nbsp;<I><a href="#pinnedMatrix0">cudaMF_pinnedMatrix0</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#pinnedVector">cudaVF_pinnedVector</a>,&nbsp;&nbsp; </I></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="pinnedMatrix0"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaMF_pinnedMatrix0</b></font>
</td><td width="34%"><font size="+1"><b>cudaMD_pinnedMatrix0</b></font></td>
<td><font size="+1"><b>cudaME_pinnedMatrix0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaMCF_pinnedMatrix0</b></font></td>
<td width="34%"><font size="+1"><b>cudaMCD_pinnedMatrix0</b></font></td>
<td><font size="+1"><b>cudaMCE_pinnedMatrix0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaMI_pinnedMatrix0</b></font></td><td width="34%"><font size="+1"><b>cudaMBI_pinnedMatrix0</b></font></td><td><font size="+1"><b>cudaMSI_pinnedMatrix0</b></font></td></tr>
<tr valign="TOP"><td width="33%"><font size="+1"><b>cudaMLI_pinnedMatrix0</b></font></td><td width="34%"><font size="+1"><b>cudaMQI_pinnedMatrix0</b></font></td><td>&nbsp;</td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>cudaMU_pinnedMatrix0</b></font></td><td width="34%"><font size="+1"><b>cudaMUB_pinnedMatrix0</b></font></td><td><font size="+1"><b>cudaMUS_pinnedMatrix0</b></font></td></tr>
<tr valign="TOP"><td width="33%"><font size="+1"><b>cudaMUL_pinnedMatrix0</b></font></td><td width="34%"><font size="+1"><b>cudaMUQ_pinnedMatrix0</b></font></td><td><font size="+1"><b>cudaMUI_pinnedMatrix0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Pinned host-memory allocation for a matrix, initialized with 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>fMatrix0&nbsp;cudaMF_pinnedMatrix0( fMatrix0 *h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function cudaMF_pinnedMatrix0( var&nbsp;h_MA:fMatrix0; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;fMatrix0;</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Pinned host memory is allocated and initialized with 0. The device pointer is returned, and the host pointer is stored as h_MA. In order to release the memory thus allocated, use <I><a href="#pinnedFree">cudaM_pinnedFree</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#pinnedFreeAll">cudaV_pinnedFreeAll</a></I>, or <I><a href="#pinnedNfree">cudaM_pinnedNfree</a></I> (the latter only in C/C++).
<BR>See <a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a> for a description of the various memory types of <i>cudaOptiVec</i> routines.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Device pointer to the allocated matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a>, &nbsp;&nbsp;<I><a href="#pinnedMatrix">cudaMF_pinnedMatrix</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#pinnedVector0">cudaVF_pinnedVector0</a>,&nbsp;&nbsp; </I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pinnedNfree"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>cudaM_pinnedNfree</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>De-allocate pinned host memory occupied by one or more matrices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMatLib.h&gt;
<BR>int cudaV_pinnedNfree( unsigned&nbsp;numfree, ...&nbsp;);</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The parameter numfree &quot;tells&quot; the function how many matrices it has to free. The host pointers of these matrices follow in the parameter list after numfree. Only matrices which have been allocated by one of the functions of the <I><a href="#pinnedMatrix">cudaVF_pinnedMatrix</a></I> or <I><a href="#pinnedMatrix0">cudaVF_pinnedMAtrix0</a></I> family can be de-allocated by <i>cudaM_pinnedNfree</i>.
<BR>If device pointers are mistakenly used rather than the host pointers, an error message is displayed.
<BR>Pascal/Delphi: since a variable number of parameters is not supported in Pascal language, this function is missing.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">cudaM_pinnedNfree( 3, h_MX, h_MY, h_MZ&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0) in case of success, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="CUDAOPTIVEC.HTM#chap3">CudaOptiVec.htm, chapter&nbsp;3</a>, &nbsp;&nbsp;<I><a href="#pinnedFree">cudaV_pinnedFree</a>,&nbsp;&nbsp; <a href="#pinnedFreeAll">cudaV_pinnedFreeAll</a>,&nbsp;&nbsp; <a href="#pinnedVector">cudaVF_pinnedVector</a>,&nbsp;&nbsp; <a href="#pinnedVector0">cudaVF_pinnedVector0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="polyfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_polyfit</b></font>
</td><td width="33%"><font size="+1"><b>VD_polyfit</b></font></td>
<td><font size="+1"><b>VE_polyfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_polyfitwW</b></font></td>
<td width="33%"><font size="+1"><b>VD_polyfitwW</b></font></td>
<td><font size="+1"><b>VE_polyfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fitting of one X-Y data set to a polynomial</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int VF_polyfit( fVector&nbsp;A, unsigned deg, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;sizex&nbsp;);<BR>
int VF_polyfitwW( fVector&nbsp;A, fMatrix Covar, unsigned deg, fVector&nbsp;X, fVector&nbsp;Y, fVector&nbsp;InvVar, ui&nbsp;sizex&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
int vector&lt;T&gt;::polyfit( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);<BR>
int vector&lt;T&gt;::polyfitwW( matrix&lt;T&gt; Covar, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;InvVar&nbsp;);<BR>
int vector&lt;T&gt;::polyfitwW( matrix&lt;T&gt;*&nbsp;Covar, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;InvVar&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function VF_polyfit( A:fVector; deg:UInt; X,&nbsp;Y:fVector; sizex:UIntSize&nbsp;): IntBool;<BR>
function VF_polyfitwW( A:fVector; Covar:fMatrix; deg:UInt, X, Y, InvVar:fVector; sizex:UIntSize&nbsp;): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data are used to determine the coefficients <I>a<sub>i</sub></I> of a polynomial<BR>
<font face="courier new">P<sub>i</sub> = a<sub>0</sub> + a<sub>1</sub>X<sub>i</sub> + a<sub>2</sub>X<sub>i</sub><sup>2</sup> ... a<sub>n</sub>X<sub>i</sub><sup>n</sup></font><BR>
so as to minimize the deviation between the &quot;theoretical&quot; P<sub>i</sub> values, calculated by the polynomial, and the actual Y<sub>i</sub> values. To be more precise, the figure-of-merit chi-square,<BR>
<font face="courier new"><font face="symbol">c</font><sup>2</sup> = sum( 1/<font face="symbol">s</font><sub>i</sub><sup>2</sup> *&nbsp;(P<sub>i</sub> - Y<sub>i</sub>)<sup>2</sup>&nbsp;);</font><BR>
is minimized. In the weighted variant, <I>VF_polyfitwW</I>, 1/<font face="symbol">s</font><sub>i</sub><sup>2</sup> has to be provided as the vector <I>InvVar</I>. In the non-weighted variant, all <font face="symbol">s</font><sub>i</sub> are assumed as 1.0.
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size deg+1; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [deg+1, deg+1]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>deg</td><td>the degree of the fitting polynomial</td></tr>
<tr valign="top"><td>X,&nbsp;Y,&nbsp;InvVar</td><td>vectors of size sizex, holding the input data</td></tr>
</table>
<P>If possible, the X axis should include the zero point. Fitting far off the zero-point may lead to poor matching of the polynomial and your data, given the typical form of a polynomial (which has only deg-1 "turns"). In such a case, you should calculate the polynomial not for the original X, but for a shifted X' axis. If, e.g., you have to find a polynomial matching data for x ranging from 9 to 10, you would best shift your X axis by -9, in order to have x'=0 at the beginning of the range. Shifting by -9.5 for x'=0 in the middle of the range would also be fine.
<P>In the rare case of failure, this function returns 1 (TRUE) and sets all A[i] = 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="FUNCREF.HTM#linregress">VF_linregress</a>,&nbsp;&nbsp; <a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#chi2">VF_chi2</a>,&nbsp;&nbsp; <a href="#chap13">chapter&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="polyinterpol"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_polyinterpol</b></font></td><td width="33%"><font size="+1"><b>MD_polyinterpol</b></font></td><td><font size="+1"><b>ME_polyinterpol</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Polynomial interpolation of X-Y-MZ-table values</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;
<BR>void MF_polyinterpol( fMatrix&nbsp;MZ, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;XTab, fVector&nbsp;YTab, fMatrix&nbsp;MZTab, ui&nbsp;httab, ui&nbsp;lentab, unsigned&nbsp;degX, unsigned&nbsp;degY&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void matrix&lt;T&gt;::polyinterpol( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;XTab, const&nbsp;vector&lt;T&gt;&amp;&nbsp;YTab, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZTab, unsigned&nbsp;degX, unsigned&nbsp;degY&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>procedure MF_polyinterpol( MZ:fMatrix; X,&nbsp;Y:fVector; ht,&nbsp;len:UIntSize; XTab,&nbsp;YTab:fVector; MZTab:fMatrix; httab,&nbsp;lentab:UIntSize; degX,&nbsp;degY:UInt&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_polyinterpol( fMatrix&nbsp;d_MZ, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;d_XTab, fVector&nbsp;d_YTab, fMatrix&nbsp;d_MZTab, ui&nbsp;httab, ui&nbsp;lentab, unsigned&nbsp;degX, unsigned&nbsp;degY&nbsp;);
<BR>void MFcu_polyinterpol( fMatrix&nbsp;h_MZ, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;h_XTab, fVector&nbsp;h_YTab, fMatrix&nbsp;h_MZTab, ui&nbsp;httab, ui&nbsp;lentab, unsigned&nbsp;degX, unsigned&nbsp;degY&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_polyinterpol( d_MZ:fMatrix; d_X,&nbsp;d_Y:fVector; ht,&nbsp;len:UIntSize; d_XTab,&nbsp;d_YTab:fVector; d_MZTab:fMatrix; httab,&nbsp;lentab:UIntSize; degX,&nbsp;degY:UInt&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_polyinterpol( h_MZ:fMatrix; h_X,&nbsp;h_Y:fVector; ht,&nbsp;len:UIntSize; h_XTab,&nbsp;h_YTab:fVector; h_MZTab:fMatrix; httab,&nbsp;lentab:UIntSize; degX,&nbsp;degY:UInt&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each of the <i>ht</i> *&nbsp;<i>len</i> x / y coordinates defined by X and Y, the corresponding element of MZ is interpolated from the XTab-YTab-MZTab values. XTab and YTab must be ordered (either ascending or descending). All values of XTab as well as of YTab must be distinct; otherwise a division by zero may occur and lead to a program abort. The parameter <i>degX</i> denotes the number of points (this is not the degree of the interpolating polynomial!) that will be taken into account for the interpolation in X direction. Similarly, <i>degY</i> denotes the number of points taken into account for the interpolation in Y direction. Any value between 0 and 2 will be interpreted as meaning linear interpolation. A maximum of 10-point interpolation is possible. <i>degX</i> may not be larger than <i>lentab-1</i>; <i>degY</i> may not be larger than <i>httab-1</i>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Trying to use too many elements for the interpolation (<i>degX</i> or <i>degY</i> &gt; 10) leads to an error message &quot;Not possible with more than 10 elements&quot; and to a program abort. If <i>degX</i> exceeds <i>lentab-1</i>, or if <i>degY</i> exceeds <i>httab-1</i>, an error message &quot;Invalid parameter(s)&quot; is displayed and the program aborted.
<BR>No other errors are detected (you have to take care yourself that the XTab and YTab values are distinct and that the MZTab values are not near the limit of overflowing).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ratinterpol">MF_ratinterpol</a>,&nbsp;&nbsp; <a href="#natCubSplineInterpol">MF_natCubSplineInterpol</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#polyinterpol">VF_polyinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="print"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_print</b></font>
</td><td width="33%"><font size="+1"><b>MD_print</b></font></td>
<td><font size="+1"><b>ME_print</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_print</b></font></td>
<td width="33%"><font size="+1"><b>MCD_print</b></font></td>
<td><font size="+1"><b>MCE_print</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_print</b></font></td><td width="20%"><font size="+1"><b>MBI_print</b></font></td><td width="20%"><font size="+1"><b>MSI_print</b></font></td><td width="20%"><font size="+1"><b>MLI_print</b></font></td><td><font size="+1"><b>MQI_print</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_print</b></font></td><td width="20%"><font size="+1"><b>MUB_print</b></font></td><td width="20%"><font size="+1"><b>MUS_print</b></font></td><td width="20%"><font size="+1"><b>MUL_print</b></font></td><td><font size="+1"><b>MUQ_print;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>print a matrix in ASCII format to <I>stdout</I>, assuming a linewidth of 80 characters (Console applications only)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_print( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::print();</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_print( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_print( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMF_print_buf( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_print( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMF_print_buf( d_MA:fMatrix; ht,&nbsp;len:UIntSize; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA is written to stream. Each line corresponds to one row of the matrix. The lines are numbered. The linewidth is assumed to be 80 characters. If this linewidth is too small to write all columns, rows are cut off.
<BR>Cartesian complex numbers are printed in braces, with the real and imaginary parts separated by a komma: {Re, Im}.
<P>In contrast to <I><a href="#write">MF_write</a></I>, it is not possible to override the automatic choice of the format used for printing. The number of digits per element is determined by the available space, which depends in turn on the parameter len.
<P>In contrast to <I><a href="#cprint">MF_cprint</a></I>, no paging is performed.
<BR>This family of functions can be used only in console applications.
<P>CUDA versions only: <i>cudaM?_print_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as d_MA, i.e. ht*len. By avoiding the need of <i>cudaM?_print</i> to allocate its own buffer memory, <i>cudaM?_print_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="FUNCREF.HTM#print">VF_print</a>,&nbsp;&nbsp; <a href="#cprint">MF_cprint</a>,&nbsp;&nbsp; <a href="#fprint">MF_fprint</a>,&nbsp;&nbsp; <a href="#chap14">chapter&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="random"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_random</b></font>
</td><td width="33%"><font size="+1"><b>MD_random</b></font></td>
<td><font size="+1"><b>ME_random</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_random</b></font></td>
<td width="33%"><font size="+1"><b>MCD_random</b></font></td>
<td><font size="+1"><b>MCE_random</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_random</b></font></td><td width="20%"><font size="+1"><b>MBI_random</b></font></td><td width="20%"><font size="+1"><b>MSI_random</b></font></td><td width="20%"><font size="+1"><b>MLI_random</b></font></td><td><font size="+1"><b>MQI_random</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_random</b></font></td><td width="20%"><font size="+1"><b>MUB_random</b></font></td><td width="20%"><font size="+1"><b>MUS_random</b></font></td><td width="20%"><font size="+1"><b>MUL_random</b></font></td><td><font size="+1"><b>MUQ_random;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fill a matrix with high-quality random numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
long MF_random( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, long seed, float&nbsp;MinVal, float&nbsp;MaxVal&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
long matrix&lt;T&gt;::random( const long&amp;&nbsp;seed, const&nbsp;T&amp;&nbsp;MinVal, const&nbsp;T&amp;&nbsp;MaxVal&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
&nbsp;&nbsp;function MF_random( MA:fMatrix; ht,&nbsp;len:UIntSize; seed:LongInt; MinVal,&nbsp;MaxVal:Single&nbsp;): LongInt;</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_random( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, long&nbsp;seed, float&nbsp;MinVal, float&nbsp;MaxVal&nbsp;);
<BR>int cusdMF_random( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, long&nbsp;seed, float&nbsp;*d_MinVal, float&nbsp;*d_MaxVal&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_random( d_MA:fMatrix; ht,&nbsp;len:UIntSize; seed:LongInt; MinVal,&nbsp;MaxVal:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_random( d_MA:fMatrix; ht,&nbsp;len:UIntSize; seed:LongInt; d_MinVal,&nbsp;d_MaxVal:PSingle&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA is filled with random numbers. Within the ranges defined by MinVal and MaxVal, and within the restrictions of floating-point representation, all numbers are equally probable (including the extreme values themselves), i.e., so-called &quot;uniform deviates&quot; are produced. The parameter <I>seed</I> may be any number. Successive calls to one and the same of these functions will yield identical sequences, if <I>seed</I> is chosen equal; if <I>seed</I> is chosen differently for successive calls, the results will be uncorrelated.
<P>Internally, these functions employ a 32-bit integer random number generator by H.W.Lewis, with additional steps (so-called &quot;Bays-Durham shuffle&quot;) to break sequential correlations. This ensures very good randomness, far superior to simpler generators (like the <I>rand</I> function of C/C++ compilers or the <I>random</I> function of Pascal/Delphi).
<P>A long value is returned which may be used as new seed for subsequent calls.
<P>The CUDA versions of this function do not return a new seed value, but the usual CUDA error flag.
<BR>There is no <i>MFcu_</i> version of this function, as the random numbers are generated on the CPU anyway.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>last 32-bit random number generated; this may be used as a new seed value for future calls.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="FUNCREF.HTM#random">VF_random</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="randomLC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_randomLC</b></font>
</td><td width="33%"><font size="+1"><b>MD_randomLC</b></font></td>
<td><font size="+1"><b>ME_randomLC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_randomLC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_randomLC</b></font></td>
<td><font size="+1"><b>MCE_randomLC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_randomLC</b></font></td><td width="20%"><font size="+1"><b>MBI_randomLC</b></font></td><td width="20%"><font size="+1"><b>MSI_randomLC</b></font></td><td width="20%"><font size="+1"><b>MLI_randomLC</b></font></td><td><font size="+1"><b>MQI_randomLC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_randomLC</b></font></td><td width="20%"><font size="+1"><b>MUB_randomLC</b></font></td><td width="20%"><font size="+1"><b>MUS_randomLC</b></font></td><td width="20%"><font size="+1"><b>MUL_randomLC</b></font></td><td><font size="+1"><b>MUQ_randomLC;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fill a matrix with high-quality randomLC numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_randomLC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, long seed, float&nbsp;MinVal, float&nbsp;MaxValV_RANDOMLCSTATE&nbsp;*state&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::randomLC( const long&amp;&nbsp;seed, const&nbsp;T&amp;&nbsp;MinVal, const&nbsp;T&amp;&nbsp;MaxVal, V_RANDOMLCSTATE&nbsp;*h_state&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
&nbsp;&nbsp;procedure MF_randomLC( MA:fMatrix; ht,&nbsp;len:UIntSize; seed:LongInt; MinVal,&nbsp;MaxVal:Single; state:PV_RANDOMLCSTATE&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_randomLC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, long&nbsp;seed, float&nbsp;MinVal, float&nbsp;MaxVal, V_RANDOMLCSTATE&nbsp;*h_state&nbsp;);
<BR>int cusdMF_randomLC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, long&nbsp;seed, float&nbsp;*d_MinVal, float&nbsp;*d_MaxVal, V_RANDOMLCSTATE&nbsp;*h_state&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_randomLC( d_MA:fMatrix; ht,&nbsp;len:UIntSize; seed:LongInt; MinVal,&nbsp;MaxVal:Single; h_state:PV_RANDOMLCSTATE&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_randomLC( d_MA:fMatrix; ht,&nbsp;len:UIntSize; seed:LongInt; d_MinVal,&nbsp;d_MaxVal:PSingle; h_state:PV_RANDOMLCSTATE&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA is filled with a sequence of random numbers. Within the ranges defined by <i>MinVal</i> and <i>MaxVal</i> (and within the restrictions of floating-point representation in the floating-point versions), all numbers are equally probable (including the extreme values themselves), i.e., so-called &quot;uniform deviates&quot; are produced. 
<P>If the parameter <i>seed</i> is any non-zero number, the generator is initialized with that seed value and a new series of random numbers is generated. On the other hand, if you wish to continue a previous series, call this function with <i>seed</i>=0 and with the same parameter <i>state</i> as the previous call. Calls to one and the same of these functions will yield identical sequences, if <i>seed</i> is chosen equal; if <i>seed</i> is chosen differently for successive calls, the results will be uncorrelated.
<P>Internally, these functions employ a linear-congruential (hence the "LC" in the function name) random number generator by H.W. Lewis. The smaller data types use a 32-bit generator, while the larger types use a 64-bit version. Additional steps (so-called &quot;Bays-Durham shuffle&quot;) are taken to break sequential correlations. This ensures very good randomness. However, as this algorithm is well-known and its state can be inferred from a given stretch of output numbers, these functions are not suitable for cryptographic applications.
<P>A simplified form of this function is available as  <a href="#random">MF_random</a>.
<BR>There is no <i>MFcu_</i> version of this function, as the random numbers are generated on the CPU anyway.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="FUNCREF.HTM#randomLC">VF_randomLC</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ratinterpol"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_ratinterpol</b></font></td><td width="33%"><font size="+1"><b>MD_ratinterpol</b></font></td><td><font size="+1"><b>ME_ratinterpol</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Diagonal-rational interpolation of X-Y-MZ-table values</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;
<BR>void MF_ratinterpol( fMatrix&nbsp;MZ, fVector&nbsp;X, fVector&nbsp;Y, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;XTab, fVector&nbsp;YTab, fMatrix&nbsp;MZTab, ui&nbsp;httab, ui&nbsp;lentab, unsigned&nbsp;degX, unsigned&nbsp;degY&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void matrix&lt;T&gt;::ratinterpol( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, const&nbsp;vector&lt;T&gt;&amp;&nbsp;XTab, const&nbsp;vector&lt;T&gt;&amp;&nbsp;YTab, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MZTab, unsigned&nbsp;degX, unsigned&nbsp;degY&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>procedure MF_ratinterpol( MZ:fMatrix; X,&nbsp;Y:fVector; ht,&nbsp;len:UIntSize; XTab,&nbsp;YTab:fVector; MZTab:fMatrix; httab,&nbsp;lentab:UIntSize; degX,&nbsp;degY:UInt&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_ratinterpol( fMatrix&nbsp;d_MZ, fVector&nbsp;d_X, fVector&nbsp;d_Y, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;d_XTab, fVector&nbsp;d_YTab, fMatrix&nbsp;d_MZTab, ui&nbsp;httab, ui&nbsp;lentab, unsigned&nbsp;degX, unsigned&nbsp;degY&nbsp;);
<BR>void MFcu_ratinterpol( fMatrix&nbsp;h_MZ, fVector&nbsp;h_X, fVector&nbsp;h_Y, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;h_XTab, fVector&nbsp;h_YTab, fMatrix&nbsp;h_MZTab, ui&nbsp;httab, ui&nbsp;lentab, unsigned&nbsp;degX, unsigned&nbsp;degY&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_ratinterpol( d_MZ:fMatrix; d_X,&nbsp;d_Y:fVector; ht,&nbsp;len:UIntSize; d_XTab,&nbsp;d_YTab:fVector; d_MZTab:fMatrix; httab,&nbsp;lentab:UIntSize; degX,&nbsp;degY:UInt&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_ratinterpol( h_MZ:fMatrix; h_X,&nbsp;h_Y:fVector; ht,&nbsp;len:UIntSize; h_XTab,&nbsp;h_YTab:fVector; h_MZTab:fMatrix; httab,&nbsp;lentab:UIntSize; degX,&nbsp;degY:UInt&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each of the <i>ht</i> *&nbsp;<i>len</i> x / y coordinates defined by X and Y, the corresponding element of MZ is interpolated from the XTab-YTab-MZTab values. XTab and YTab must be ordered (either ascending or descending). All values of XTab as well as of YTab must be distinct; otherwise a division by zero may occur and lead to a program abort. The parameter <i>degX</i> denotes the number of points that will be taken into account for the interpolation in X direction. Similarly, <i>degY</i> denotes the number of points taken into account for the interpolation in Y direction. The diagonal rational interpolation scheme by Stoer and Bulirsch is used. The interpolating function is formed by the quotient of two polynomials, the polynomial in the denominator being of the same order (for even deg) or of an order higher by one (for odd deg) than the polynomial of the numerator.
<BR>Diagonal rational interpolation is superior to polynomial interpolation, especially in the presence of poles. It is, however, much slower.
<BR>deg must be between 3 and 20. Additionally, <i>degX</i> may not be larger than <i>lentab-1</i>; <i>degY</i> may not be larger than <i>httab-1</i>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>A pole (infinity) in the interpolated function is recognized and leads to a SING error with the proposed result being &#177;HUGE_VAL. (Note: the x-value passed to <I>_matherr</I> is the first element of XTab, if the error occurs while interpolating in X directions, or the first element of YTab, if the error occurs while interpolationg in Y directions). Trying to use too many elements for the interpolation (<i>degX</i> or <i>degY</i> &gt; 20) leads to an error message &quot;Not possible with more than 20 elements&quot; and to a program abort. If <i>degX</i> or <i>degY</i> are &lt; 3, or if <i>degX</i> exceeds <i>lentab-1</i>, or if <i>degY</i> exceeds <i>httab-1</i>, an error message &quot;Invalid parameter(s)&quot; is displayed and the program aborted.
<BR>No other errors are detected (you have to take care yourself that the XTab and YTab values are distinct).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#polyinterpol">MF_polyinterpol</a>,&nbsp;&nbsp; <a href="#natCubSplineInterpol">MF_natCubSplineInterpol</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#ratinterpol">VF_ratinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="read"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_read</b></font>
</td><td width="33%"><font size="+1"><b>MD_read</b></font></td>
<td><font size="+1"><b>ME_read</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_read</b></font></td>
<td width="33%"><font size="+1"><b>MCD_read</b></font></td>
<td><font size="+1"><b>MCE_read</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_read</b></font></td><td width="20%"><font size="+1"><b>MBI_read</b></font></td><td width="20%"><font size="+1"><b>MSI_read</b></font></td><td width="20%"><font size="+1"><b>MLI_read</b></font></td><td><font size="+1"><b>MQI_read</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_read</b></font></td><td width="20%"><font size="+1"><b>MUB_read</b></font></td><td width="20%"><font size="+1"><b>MUS_read</b></font></td><td width="20%"><font size="+1"><b>MUL_read</b></font></td><td><font size="+1"><b>MUQ_read</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>read a matrix in ASCII format from a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_read( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, FILE *stream&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::read( FILE *stream&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
&nbsp;&nbsp;procedure MF_read( MA:fMatrix; ht,&nbsp;len:UIntSize; var&nbsp;Stream:TextFile&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_read( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, FILE *stream&nbsp;);
<BR>int cudaMF_read_buf( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, FILE *stream, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_read( d_MA:fMatrix; ht,&nbsp;len:UIntSize; var&nbsp;Stream:TextFile&nbsp;):&nbsp;IntBool;
<BR>function cudaMF_read_buf( d_MA:fMatrix; ht,&nbsp;len:UIntSize; var&nbsp;Stream:TextFile; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA of ht*len elements is read in ASCII format from <I>stream</I>. Normally, this function will be used to import matrices from a program which cannot store numbers in machine format. It can also be used to retrieve matrices previously stored by <I><a href="#write">MF_write</a></I>. For storing and retrieving intermediate results, however, the function pair <I><a href="#store">MF_store</a></I> / <I><a href="#recall">MF_recall</a></I> is to be preferred over <I><a href="#write">MF_write</a></I> / <I>MF_read</I> (see <I><a href="#write">MF_write</a></I>).
<P><u>Cartesian complex versions:</u>
<BR>Real und imaginary parts may, but need not, be enclosed in braces { } or brackets (&nbsp;). However, you must be consequent: Either all or no element may be written with braces or brackets.
<BR>A komma may (but need not) separate the two parts. The imaginary part must always be explicitly specified, even if it is zero.
<BR>Examples for legal formats are:
<BR>0.3 0.5&nbsp;&nbsp;&nbsp;&nbsp;(neither braces nor separating komma)
<BR>0.3, 0.5&nbsp;&nbsp;&nbsp;&nbsp;(no braces; separating komma)
<BR>{0.3 0.5}&nbsp;&nbsp;&nbsp;&nbsp;(braces; no separating komma)
<BR>(0.3, 0.5)&nbsp;&nbsp;&nbsp;&nbsp;(brackets and separating komma)
</td></tr><tr valign="TOP">
<td>C/C++ specific:</td><td> The entries to be read must be separated by whitespace (' ', '\n', or '\t'). Additionally, one (!) &quot;non-whitespace&quot; character is tolerated after each entry, if it follows directly after the last digit. After it, there must be one or more whitespace characters.
</td></tr><tr valign="TOP">
<td>Pascal/Delphi specific:</td><td> The entries to be read must be separated by whitespace (' ', #13, or #9).
<P>Whereas the C/C++ version of these functions follows the conventions of the C functions <i>strtod</i>, <i>strtol</i>, etc., the Pascal/Delphi version has to follow the rules applying to the Pascal/Delphi function <i>Read</i>. This makes the Pascal/Delphi version much less flexible than the C version:
<BR>- no separation characters allowed other than ' ' and #9,
<BR>- no automatic truncation of overflowing numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td><u>C/C++:</u>
<BR>Overflowing numbers are silently truncated to &#177;HUGE_VAL.
<BR><u>Pascal/Delphi:</u>
<BR>Overflowing numbers or numbers otherwise not conforming to the format requirements lead to an I/O error.
<P>CUDA versions only: <i>cudaM?_read_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as d_MA, i.e. ht*len. By avoiding the need of <i>cudaM?_read</i> to allocate its own buffer memory, <i>cudaM?_read_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#write">MF_write</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#nread">VF_nread</a>,&nbsp;&nbsp; <a href="#store">MF_store</a>,&nbsp;&nbsp; <a href="#recall">MF_recall</a>,&nbsp;&nbsp; <a href="#chap14">chapter&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="recall"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_recall</b></font>
</td><td width="33%"><font size="+1"><b>MD_recall</b></font></td>
<td><font size="+1"><b>ME_recall</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_recall</b></font></td>
<td width="33%"><font size="+1"><b>MCD_recall</b></font></td>
<td><font size="+1"><b>MCE_recall</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_recall</b></font></td><td width="20%"><font size="+1"><b>MBI_recall</b></font></td><td width="20%"><font size="+1"><b>MSI_recall</b></font></td><td width="20%"><font size="+1"><b>MLI_recall</b></font></td><td><font size="+1"><b>MQI_recall</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_recall</b></font></td><td width="20%"><font size="+1"><b>MUB_recall</b></font></td><td width="20%"><font size="+1"><b>MUS_recall</b></font></td><td width="20%"><font size="+1"><b>MUL_recall</b></font></td><td><font size="+1"><b>MUQ_recall</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Read a matrix in binary format from a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_recall( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, FILE *stream);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::recall( FILE *stream&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_recall( MA:fMatrix; ht,&nbsp;len:UIntSize; var Stream:FILE&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_recall( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, FILE *stream&nbsp;);
<BR>int cudaMF_recall_buf( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, FILE *stream, fVector&nbsp;h_Wk&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_recall( d_MA:fMatrix; ht,&nbsp;len:UIntSize; var&nbsp;Stream:File&nbsp;):&nbsp;IntBool;
<BR>function cudaMF_recall_buf( d_MA:fMatrix; ht,&nbsp;len:UIntSize; var&nbsp;Stream:File; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA of ht*len elements is read from stream in binary format. Normally, these functions are used to retrieve data stored by the respective function of the <I><a href="#store">MF_store</a></I> family.
<P>In C/C++, matrices are stored by rows, where as Pascal/Delphi and Fortran work with matrices stored by columns. This means that you will get the transpose of a matrix stored by a C/C++ program, if you read it with a Pascal/Delphi program, and <I>vice versa</I>. In this case, simply call<BR>
<font face="courier new">MF_transpose( MA, MA, ht, len&nbsp;);</font>.
<P>CUDA versions only: <i>cudaM?_recall_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as d_MA, i.e. ht*len. By avoiding the need of <i>cudaM?_recall</i> to allocate its own buffer memory, <i>cudaM?_recall_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#store">MF_store</a>,&nbsp;&nbsp; <a href="#chap14">chapter&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="rotate90"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_rotate90</b></font>
</td><td width="33%"><font size="+1"><b>MD_rotate90</b></font></td>
<td><font size="+1"><b>ME_rotate90</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_rotate90</b></font></td>
<td width="33%"><font size="+1"><b>MCD_rotate90</b></font></td>
<td><font size="+1"><b>MCE_rotate90</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_rotate90</b></font></td><td width="20%"><font size="+1"><b>MBI_rotate90</b></font></td><td width="20%"><font size="+1"><b>MSI_rotate90</b></font></td><td width="20%"><font size="+1"><b>MLI_rotate90</b></font></td><td><font size="+1"><b>MQI_rotate90</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_rotate90</b></font></td><td width="20%"><font size="+1"><b>MUB_rotate90</b></font></td><td width="20%"><font size="+1"><b>MUS_rotate90</b></font></td><td width="20%"><font size="+1"><b>MUL_rotate90</b></font></td><td><font size="+1"><b>MUQ_rotate90</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>clock-wise rotation of a matrix by 90&deg;</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_rotate90( fMatrix&nbsp;MRot, fMatrix&nbsp;MA, ui&nbsp;htRot, ui&nbsp;lenRot&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::rotate90( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_rotate90( MRot,&nbsp;MA:fMatrix; htRot,&nbsp;lenRot:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_rotate90( fMatrix&nbsp;d_MRot, fMatrix&nbsp;d_MA, ui&nbsp;htRot, ui&nbsp;lenRot&nbsp;);
<BR>void MFcu_rotate90( fMatrix&nbsp;h_MRot, fMatrix&nbsp;h_MA, ui&nbsp;htRot, ui&nbsp;lenRot&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_rotate90( d_MRot,&nbsp;MA:fMatrix; htRot,&nbsp;lenRot:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_rotate90( h_MRot,&nbsp;h_MA:fMatrix; htRot,&nbsp;lenRot:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MRot<sub>i,j</sub> = MA<sub>lenRot-j-1, i</sub>
<BR>The dimensions fed into this function, htRot and lenRot, refer to the rotated matrix rather than to the input matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#rotate180">MF_rotate180</a>,&nbsp;&nbsp; <a href="#rotate270">MF_rotate270</a>&nbsp;&nbsp; <a href="#transpose">MF_transpose</a>,&nbsp;&nbsp; <a href="#Rows_rev">MF_Rows_rev</a>&nbsp;&nbsp; <a href="#Cols_rev">MF_Cols_rev</a>&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="rotate180"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_rotate180</b></font>
</td><td width="33%"><font size="+1"><b>MD_rotate180</b></font></td>
<td><font size="+1"><b>ME_rotate180</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_rotate180</b></font></td>
<td width="33%"><font size="+1"><b>MCD_rotate180</b></font></td>
<td><font size="+1"><b>MCE_rotate180</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_rotate180</b></font></td><td width="20%"><font size="+1"><b>MBI_rotate180</b></font></td><td width="20%"><font size="+1"><b>MSI_rotate180</b></font></td><td width="20%"><font size="+1"><b>MLI_rotate180</b></font></td><td><font size="+1"><b>MQI_rotate180</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_rotate180</b></font></td><td width="20%"><font size="+1"><b>MUB_rotate180</b></font></td><td width="20%"><font size="+1"><b>MUS_rotate180</b></font></td><td width="20%"><font size="+1"><b>MUL_rotate180</b></font></td><td><font size="+1"><b>MUQ_rotate180</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>rotation of a matrix by 180&deg;</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_rotate180( fMatrix&nbsp;MRot, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::rotate180( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_rotate180( MRot,&nbsp;MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_rotate180( fMatrix&nbsp;d_MRot, fMatrix&nbsp;d_MA, ui&nbsp;htRot, ui&nbsp;lenRot&nbsp;);
<BR>void MFcu_rotate180( fMatrix&nbsp;h_MRot, fMatrix&nbsp;h_MA, ui&nbsp;htRot, ui&nbsp;lenRot&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_rotate180( d_MRot,&nbsp;MA:fMatrix; htRot,&nbsp;lenRot:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_rotate180( h_MRot,&nbsp;h_MA:fMatrix; htRot,&nbsp;lenRot:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MRot<sub>i,j</sub> = MA<sub>ht-i-1, len-j-1</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#rotate90">MF_rotate90</a>,&nbsp;&nbsp; <a href="#rotate270">MF_rotate270</a>&nbsp;&nbsp; <a href="#transpose">MF_transpose</a>,&nbsp;&nbsp; <a href="#Rows_rev">MF_Rows_rev</a>&nbsp;&nbsp; <a href="#Cols_rev">MF_Cols_rev</a>&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="rotate270"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_rotate270</b></font>
</td><td width="33%"><font size="+1"><b>MD_rotate270</b></font></td>
<td><font size="+1"><b>ME_rotate270</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_rotate270</b></font></td>
<td width="33%"><font size="+1"><b>MCD_rotate270</b></font></td>
<td><font size="+1"><b>MCE_rotate270</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_rotate270</b></font></td><td width="20%"><font size="+1"><b>MBI_rotate270</b></font></td><td width="20%"><font size="+1"><b>MSI_rotate270</b></font></td><td width="20%"><font size="+1"><b>MLI_rotate270</b></font></td><td><font size="+1"><b>MQI_rotate270</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_rotate270</b></font></td><td width="20%"><font size="+1"><b>MUB_rotate270</b></font></td><td width="20%"><font size="+1"><b>MUS_rotate270</b></font></td><td width="20%"><font size="+1"><b>MUL_rotate270</b></font></td><td><font size="+1"><b>MUQ_rotate270</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>clock-wise rotation of a matrix by 270&deg; (or counter-clockwise rotation by 90&deg;)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_rotate270( fMatrix&nbsp;MRot, fMatrix&nbsp;MA, ui&nbsp;htRot, ui&nbsp;lenRot&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::rotate270( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_rotate270( MRot,&nbsp;MA:fMatrix; htRot, lenRot:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_rotate270( fMatrix&nbsp;d_MRot, fMatrix&nbsp;d_MA, ui&nbsp;htRot, ui&nbsp;lenRot&nbsp;);
<BR>void MFcu_rotate270( fMatrix&nbsp;h_MRot, fMatrix&nbsp;h_MA, ui&nbsp;htRot, ui&nbsp;lenRot&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_rotate270( d_MRot,&nbsp;MA:fMatrix; htRot,&nbsp;lenRot:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_rotate270( h_MRot,&nbsp;h_MA:fMatrix; htRot,&nbsp;lenRot:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MRot<sub>i,j</sub> = MA<sub>j, htRot-i-1</sub>
<BR>The dimensions fed into this function, htRot and lenRot, refer to the rotated matrix rather than to the input matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#rotate90">MF_rotate90</a>,&nbsp;&nbsp; <a href="#rotate180">MF_rotate180</a>&nbsp;&nbsp; <a href="#transpose">MF_transpose</a>,&nbsp;&nbsp; <a href="#Rows_rev">MF_Rows_rev</a>&nbsp;&nbsp; <a href="#Cols_rev">MF_Cols_rev</a>&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_addC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_addC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_addC</b></font></td>
<td><font size="+1"><b>ME_Row_addC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_addC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_addC</b></font></td>
<td><font size="+1"><b>MCE_Row_addC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>add a constant to all elements of one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_addC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_addC( const&nbsp;ui&nbsp;iRow, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_addC( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_addC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);
<BR>int cusdMF_Row_addC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Row_addC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_addC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Row_addC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_addC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> += C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_addC">MF_Col_addC</a>,&nbsp;&nbsp; <a href="#Dia_addC">MF_Dia_addC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_addV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_addV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_addV</b></font></td>
<td><font size="+1"><b>ME_Row_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_addV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_addV</b></font></td>
<td><font size="+1"><b>MCE_Row_addV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise addition of one row and a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_addV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_addV( const&nbsp;ui&nbsp;iRow, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_addV( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_addV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Row_addV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_addV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_addV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> += X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_addV">MF_Col_addV</a>,&nbsp;&nbsp; <a href="#Dia_addV">MF_Dia_addV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_conj"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_conj</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_conj</b></font></td>
<td><font size="+1"><b>MCE_Row_conj</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>complex conjugate of all elements of one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_Row_conj( cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;complex&lt;T&gt;&gt;::Row_conj( const&nbsp;ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_Row_conj( MA:cfMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Row_conj( cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);
<BR>void MCFcu_Row_conj( cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Row_conj( d_MA:cfMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Row_conj( h_MA:cfMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = MA*<sub>iRow,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_neg">MF_Row_neg</a>, <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_delete"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_delete</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_delete</b></font></td>
<td><font size="+1"><b>ME_Row_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_delete</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_delete</b></font></td>
<td><font size="+1"><b>MCE_Row_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Row_delete</b></font></td><td width="20%"><font size="+1"><b>MBI_Row_delete</b></font></td><td width="20%"><font size="+1"><b>MSI_Row_delete</b></font></td><td width="20%"><font size="+1"><b>MLI_Row_delete</b></font></td><td><font size="+1"><b>MQI_Row_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Row_delete</b></font></td><td width="20%"><font size="+1"><b>MUB_Row_delete</b></font></td><td width="20%"><font size="+1"><b>MUS_Row_delete</b></font></td><td width="20%"><font size="+1"><b>MUL_Row_delete</b></font></td><td><font size="+1"><b>MUQ_Row_delete;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>delete one row from a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_delete( fMatrix&nbsp;MB, fMatrix&nbsp;MA, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_delete( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_delete( MB,&nbsp;MA:fMatrix; htA,&nbsp;lenA,&nbsp;iRow:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_delete( fMatrix&nbsp;d_MB, fMatrix&nbsp;d_MA, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;iRow&nbsp;);
<BR>void MFcu_Row_delete( fMatrix&nbsp;h_MB, fMatrix&nbsp;h_MA, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_delete( d_MB,&nbsp;d_MA:fMatrix; htA,&nbsp;lenA,&nbsp;iRow:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_delete( h_MB,&nbsp;h_MA:fMatrix; htA,&nbsp;lenA,&nbsp;iRow:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>i,j</sub> = MA<sub>i,j</sub>,&nbsp;&nbsp;i=0,...,iRow-1,&nbsp;&nbsp;j=0,...,len-1<BR>
MB<sub>i,j</sub> = MA<sub>i+1,j</sub>,&nbsp;&nbsp;i=iRow,...,htA-2,&nbsp;&nbsp;j=0,...,lenA-1<BR>
The parameters htA and lenA refer to the <U>input</U> matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_insert">MF_Row_insert</a>,&nbsp;&nbsp; <a href="#Col_delete">MF_Col_delete</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_divC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_divC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_divC</b></font></td>
<td><font size="+1"><b>ME_Row_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_divC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_divC</b></font></td>
<td><font size="+1"><b>MCE_Row_divC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>divide all elements of one row by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_divC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_divC( const&nbsp;ui&nbsp;iRow, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_divC( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_divC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);
<BR>int cusdMF_Row_divC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Row_divC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_divC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Row_divC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_divC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> /= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divC">MF_Col_divC</a>,&nbsp;&nbsp; <a href="#Dia_divC">MF_Dia_divC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_divrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_divrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_divrC</b></font></td>
<td><font size="+1"><b>ME_Row_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_divrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_divrC</b></font></td>
<td><font size="+1"><b>MCE_Row_divrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse division: divide a constant by all elements of one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_divrC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_divrC( const&nbsp;ui&nbsp;iRow, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_divrC( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_divrC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);
<BR>int cusdMF_Row_divrC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Row_divrC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_divrC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Row_divrC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_divrC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = C / MA<sub>iRow,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divrC">MF_Col_divrC</a>,&nbsp;&nbsp; <a href="#Dia_divrC">MF_Dia_divrC</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_divrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_divrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_divrV</b></font></td>
<td><font size="+1"><b>ME_Row_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_divrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_divrV</b></font></td>
<td><font size="+1"><b>MCE_Row_divrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise reverse division: divide a vector by one row of a matrix, storing the result back into the row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_divrV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_divrV( const&nbsp;ui&nbsp;iRow, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_divrV( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_divrV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Row_divrV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_divrV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_divrV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = X<sub>i</sub> / MA<sub>iRow,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divrV">MF_Col_divrV</a>,&nbsp;&nbsp; <a href="#Dia_divrV">MF_Dia_divrV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_divV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_divV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_divV</b></font></td>
<td><font size="+1"><b>ME_Row_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_divV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_divV</b></font></td>
<td><font size="+1"><b>MCE_Row_divV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise division of one row of a matrix by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_divV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_divV( const&nbsp;ui&nbsp;iRow, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_divV( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_divV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Row_divV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_divV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_divV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> /= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divV">MF_Col_divV</a>,&nbsp;&nbsp; <a href="#Dia_divV">MF_Dia_divV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_equ0"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_equ0</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_equ0</b></font></td>
<td><font size="+1"><b>ME_Row_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_equ0</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_equ0</b></font></td>
<td><font size="+1"><b>MCE_Row_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Row_equ0</b></font></td><td width="20%"><font size="+1"><b>MBI_Row_equ0</b></font></td><td width="20%"><font size="+1"><b>MSI_Row_equ0</b></font></td><td width="20%"><font size="+1"><b>MLI_Row_equ0</b></font></td><td><font size="+1"><b>MQI_Row_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Row_equ0</b></font></td><td width="20%"><font size="+1"><b>MUB_Row_equ0</b></font></td><td width="20%"><font size="+1"><b>MUS_Row_equ0</b></font></td><td width="20%"><font size="+1"><b>MUL_Row_equ0</b></font></td><td><font size="+1"><b>MUQ_Row_equ0;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize all elements of one row with zero</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_equ0( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_equ0( const&nbsp;ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_equ0( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_equ0( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);
<BR>void MFcu_Row_equ0( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_equ0( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_equ0( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = 0,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equ0">MF_Col_equ0</a>,&nbsp;&nbsp; <a href="#Dia_equ0">MF_Dia_equ0</a>,&nbsp;&nbsp; <a href="#Row_equC">MF_Row_equC</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_equC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_equC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_equC</b></font></td>
<td><font size="+1"><b>ME_Row_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_equC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_equC</b></font></td>
<td><font size="+1"><b>MCE_Row_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Row_equC</b></font></td><td width="20%"><font size="+1"><b>MBI_Row_equC</b></font></td><td width="20%"><font size="+1"><b>MSI_Row_equC</b></font></td><td width="20%"><font size="+1"><b>MLI_Row_equC</b></font></td><td><font size="+1"><b>MQI_Row_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Row_equC</b></font></td><td width="20%"><font size="+1"><b>MUB_Row_equC</b></font></td><td width="20%"><font size="+1"><b>MUS_Row_equC</b></font></td><td width="20%"><font size="+1"><b>MUL_Row_equC</b></font></td><td><font size="+1"><b>MUQ_Row_equC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize all elements of one row with a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_equC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_equC( const&nbsp;ui&nbsp;iRow, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_equC( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_equC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);
<BR>int cusdMF_Row_equC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Row_equC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_equC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Row_equC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_equC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equC">MF_Col_equC</a>,&nbsp;&nbsp; <a href="#Dia_equC">MF_Dia_equC</a>,&nbsp;&nbsp; <a href="#Row_equ0">MF_Row_equ0</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_equV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_equV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_equV</b></font></td>
<td><font size="+1"><b>ME_Row_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_equV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_equV</b></font></td>
<td><font size="+1"><b>MCE_Row_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Row_equV</b></font></td><td width="20%"><font size="+1"><b>MBI_Row_equV</b></font></td><td width="20%"><font size="+1"><b>MSI_Row_equV</b></font></td><td width="20%"><font size="+1"><b>MLI_Row_equV</b></font></td><td><font size="+1"><b>MQI_Row_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Row_equV</b></font></td><td width="20%"><font size="+1"><b>MUB_Row_equV</b></font></td><td width="20%"><font size="+1"><b>MUS_Row_equV</b></font></td><td width="20%"><font size="+1"><b>MUL_Row_equV</b></font></td><td><font size="+1"><b>MUQ_Row_equV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy a vector into one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_equV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_equV( const&nbsp;ui&nbsp;iRow, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_equV( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_equV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Row_equV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_equV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_equV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equV">MF_Col_equV</a>,&nbsp;&nbsp; <a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#Row_equC">MF_Row_equC</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_extract"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_extract</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_extract</b></font></td>
<td><font size="+1"><b>ME_Row_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_extract</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_extract</b></font></td>
<td><font size="+1"><b>MCE_Row_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Row_extract</b></font></td><td width="20%"><font size="+1"><b>MBI_Row_extract</b></font></td><td width="20%"><font size="+1"><b>MSI_Row_extract</b></font></td><td width="20%"><font size="+1"><b>MLI_Row_extract</b></font></td><td><font size="+1"><b>MQI_Row_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Row_extract</b></font></td><td width="20%"><font size="+1"><b>MUB_Row_extract</b></font></td><td width="20%"><font size="+1"><b>MUS_Row_extract</b></font></td><td width="20%"><font size="+1"><b>MUL_Row_extract</b></font></td><td><font size="+1"><b>MUQ_Row_extract</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy one row into a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_extract( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Row_extract( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_extract( Y:fVector; MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_extract( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);
<BR>void MFcu_Row_extract( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_extract( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_extract( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = MA<sub>iRow,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_equV">MF_Row_equV</a>,&nbsp;&nbsp; <a href="#Row_insert">MF_Row_insert</a>&nbsp;&nbsp;<a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_insert"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_insert</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_insert</b></font></td>
<td><font size="+1"><b>ME_Row_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_insert</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_insert</b></font></td>
<td><font size="+1"><b>MCE_Row_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Row_insert</b></font></td><td width="20%"><font size="+1"><b>MBI_Row_insert</b></font></td><td width="20%"><font size="+1"><b>MSI_Row_insert</b></font></td><td width="20%"><font size="+1"><b>MLI_Row_insert</b></font></td><td><font size="+1"><b>MQI_Row_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Row_insert</b></font></td><td width="20%"><font size="+1"><b>MUB_Row_insert</b></font></td><td width="20%"><font size="+1"><b>MUS_Row_insert</b></font></td><td width="20%"><font size="+1"><b>MUL_Row_insert</b></font></td><td><font size="+1"><b>MUQ_Row_insert</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>augment a matrix by insertion of one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_insert( fMatrix&nbsp;MB, fMatrix&nbsp;MA, ui&nbsp;htB, ui&nbsp;lenB, ui&nbsp;iRow, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_insert( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;ui&nbsp;iRow, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_insert( MB,&nbsp;MA:fMatrix; htB,&nbsp;lenB,&nbsp;iRow:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_insert( fMatrix&nbsp;d_MB, fMatrix&nbsp;d_MA, ui&nbsp;htB, ui&nbsp;lenB, ui&nbsp;iRow, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Row_insert( fMatrix&nbsp;h_MB, fMatrix&nbsp;h_MA, ui&nbsp;htB, ui&nbsp;lenB, ui&nbsp;iRow, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_insert( d_MB,&nbsp;d_MA:fMatrix; htB,&nbsp;lenB,&nbsp;iRow:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_insert( h_MB,&nbsp;h_MA:fMatrix; htB,&nbsp;lenB,&nbsp;iRow:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>i,j</sub> = MA<sub>i,j</sub>,&nbsp;&nbsp;i=0,...,iRow-1,&nbsp;&nbsp;j=0,...,len-1<BR>
MB<sub>iRow,j</sub> = X<sub>j</sub>,&nbsp;&nbsp;j=0,...,lenB-1<BR>
MB<sub>i,j</sub> = MA<sub>i-1,j</sub>,&nbsp;&nbsp;i=iRow,...,htB-1,&nbsp;&nbsp;j=0,...,lenB-1<BR>
The parameters htB and lenB refer to the <U>output</U> matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_delete">MF_Row_delete</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_mulC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_mulC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_mulC</b></font></td>
<td><font size="+1"><b>ME_Row_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_mulC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_mulC</b></font></td>
<td><font size="+1"><b>MCE_Row_mulC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply all elements of one row by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_mulC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_mulC( const&nbsp;ui&nbsp;iRow, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_mulC( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_mulC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);
<BR>int cusdMF_Row_mulC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Row_mulC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_mulC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Row_mulC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_mulC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> *= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_mulC">MF_Col_mulC</a>,&nbsp;&nbsp; <a href="#Dia_mulC">MF_Dia_mulC</a>,&nbsp;&nbsp; <a href="#Row_mulV">MF_Row_mulV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_mulV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_mulV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_mulV</b></font></td>
<td><font size="+1"><b>ME_Row_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_mulV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_mulV</b></font></td>
<td><font size="+1"><b>MCE_Row_mulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise multiplication of one row and a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_mulV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_mulV( const&nbsp;ui&nbsp;iRow, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_mulV( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_mulV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Row_mulV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_mulV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_mulV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> *= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_mulV">MF_Col_mulV</a>,&nbsp;&nbsp; <a href="#Dia_mulV">MF_Dia_mulV</a>,&nbsp;&nbsp; <a href="#Row_divV">MF_Row_divV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_neg"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_neg</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_neg</b></font></td>
<td><font size="+1"><b>ME_Row_neg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_neg</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_neg</b></font></td>
<td><font size="+1"><b>MCE_Row_neg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply all elements of one row by -1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_neg( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_neg( const&nbsp;ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_neg( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_neg( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);
<BR>void MFcu_Row_neg( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_neg( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_neg( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> *= -1,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_mulC">MF_Row_mulC</a>,&nbsp;&nbsp; <a href="#Col_neg">MF_Col_neg</a>,&nbsp;&nbsp; <a href="#Row_conj">MCF_Row_conj</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_subC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_subC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_subC</b></font></td>
<td><font size="+1"><b>ME_Row_subC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_subC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_subC</b></font></td>
<td><font size="+1"><b>MCE_Row_subC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract a constant from all elements of one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_subC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_subC( const&nbsp;ui&nbsp;iRow, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_subC( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_subC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);
<BR>int cusdMF_Row_subC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Row_subC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_subC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Row_subC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_subC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> -= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_subC">MF_Col_subC</a>,&nbsp;&nbsp; <a href="#Dia_subC">MF_Dia_subC</a>,&nbsp;&nbsp; <a href="#Row_subV">MF_Row_subV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_subrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_subrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_subrC</b></font></td>
<td><font size="+1"><b>ME_Row_subrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_subrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_subrC</b></font></td>
<td><font size="+1"><b>MCE_Row_subrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: a constant minus one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_subrC( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_subrC( const&nbsp;ui&nbsp;iRow, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_subrC( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_subrC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);
<BR>int cusdMF_Row_subrC( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Row_subrC( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_subrC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Row_subrC( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_subrC( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = C - MA<sub>iRow,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_subC">MF_Row_subC</a>,&nbsp;&nbsp; <a href="#Col_subrC">MF_Col_subrC</a>,&nbsp;&nbsp; <a href="#Dia_subrC">MF_Dia_subrC</a>,&nbsp;&nbsp; <a href="#Row_subV">MF_Row_subV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_subrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_subrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_subrV</b></font></td>
<td><font size="+1"><b>ME_Row_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_subrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_subrV</b></font></td>
<td><font size="+1"><b>MCE_Row_subrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise reverse subtraction: subtract one row from a vector, storing the result back into the row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_subrV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_subrV( const&nbsp;ui&nbsp;iRow, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_subrV( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_subrV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Row_subrV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_subrV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_subrV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = X<sub>i</sub> - MA<sub>iRow,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_subV">MF_Row_subV</a>,&nbsp;&nbsp; <a href="#Col_subrV">MF_Col_subrV</a>,&nbsp;&nbsp; <a href="#Dia_subrV">MF_Dia_subrV</a>,&nbsp;&nbsp; <a href="#Row_addV">MF_Row_addV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_subV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_subV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_subV</b></font></td>
<td><font size="+1"><b>ME_Row_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_subV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_subV</b></font></td>
<td><font size="+1"><b>MCE_Row_subV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise subtraction of a vector from one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_subV( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;X&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Row_subrV( const&nbsp;ui&nbsp;iRow, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_subV( MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; X:fVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Row_subV( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;d_X&nbsp;);
<BR>void MFcu_Row_subV( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, ui&nbsp;iRow, fVector&nbsp;h_X&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Row_subV( d_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; d_X:fVector&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Row_subV( h_MA:fMatrix; ht,&nbsp;len,&nbsp;iRow:UIntSize; h_X:fVector&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> -= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_subC">MF_Row_subC</a>,&nbsp;&nbsp; <a href="#Col_subV">MF_Col_subV</a>,&nbsp;&nbsp; <a href="#Dia_subV">MF_Dia_subV</a>,&nbsp;&nbsp; <a href="#Row_subrV">MF_Row_subrV</a>,&nbsp;&nbsp; <a href="#chap6">chapter&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_absmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_absmax</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_absmax</b></font></td>
<td><font size="+1"><b>ME_Rows_absmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_absmax</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_absmax</b></font></td>
<td><font size="+1"><b>MCE_Rows_absmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the absolute maxima of all individual rows in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_absmax( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Rows_absmax( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);<BR>
void vector&lt;T&gt;::Rows_absmax( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_absmax( Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_absmax( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMCF_Rows_absmax( fVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;)
<BR>void MFcu_Rows_absmax( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Rows_absmax( fVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_absmax( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMCF_Rows_absmax( d_Y:fVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_absmax( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);
<BR>procedure MCFcu_Rows_absmax( h_Y:fVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum absolute value of each row <I>i</I> is stored as the element Y<sub>i</sub> for i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_max">MF_Rows_max</a>,&nbsp;&nbsp; <a href="#Rows_absmin">MF_Rows_absmin</a>,&nbsp;&nbsp; <a href="#Cols_absmax">MF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Dia_absmax">MF_Dia_absmax</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_absmaxReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_absmaxReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Rows_absmaxReIm</b></font></td>
<td><font size="+1"><b>MCE_Rows_absmaxReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the largest absolute values of the real and imaginary parts of each row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_Rows_absmaxReIm( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt;&nbsp;&gt;::Rows_absmaxReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_Rows_absmaxReIm( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Rows_absmaxReIm( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Rows_absmaxReIm( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Rows_absmaxReIm( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Rows_absmaxReIm( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum absolute values of the real and imaginary parts of each row <I>i</I> are combined into the element Y<sub>i</sub> for i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmax">MCF_Rows_absmax</a>,&nbsp;&nbsp; <a href="#Rows_maxReIm">MCF_Rows_maxReIm</a>,&nbsp;&nbsp; <a href="#Cols_absmaxReIm">MCF_Cols_absmaxReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_absmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_absmin</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_absmin</b></font></td>
<td><font size="+1"><b>ME_Rows_absmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_absmin</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_absmin</b></font></td>
<td><font size="+1"><b>MCE_Rows_absmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the absolute minima of all individual rows in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_absmin( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Rows_absmin( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);<BR>
void vector&lt;T&gt;::Rows_absmin( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_absmin( Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_absmin( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMCF_Rows_absmin( fVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;)
<BR>void MFcu_Rows_absmin( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Rows_absmin( fVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_absmin( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMCF_Rows_absmin( d_Y:fVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_absmin( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);
<BR>procedure MCFcu_Rows_absmin( h_Y:fVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum absolute value of each row <I>i</I> is stored as the element Y<sub>i</sub> for i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_min">MF_Rows_min</a>,&nbsp;&nbsp; <a href="#Rows_absmax">MF_Rows_absmax</a>,&nbsp;&nbsp; <a href="#Cols_absmin">MF_Cols_absmin</a>,&nbsp;&nbsp; <a href="#Dia_absmin">MF_Dia_absmin</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_absminReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_absminReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Rows_absminReIm</b></font></td>
<td><font size="+1"><b>MCE_Rows_absminReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the largest absolute values of the real and imaginary parts of each row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_Rows_absminReIm( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt;&nbsp;&gt;::Rows_absminReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_Rows_absminReIm( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Rows_absminReIm( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Rows_absminReIm( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Rows_absminReIm( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Rows_absminReIm( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum absolute values of the real and imaginary parts of each row <I>i</I> are combined into the element Y<sub>i</sub> for i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmin">MCF_Rows_absmin</a>,&nbsp;&nbsp; <a href="#Rows_minReIm">MCF_Rows_minReIm</a>,&nbsp;&nbsp; <a href="#Cols_absminReIm">MCF_Cols_absminReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_add"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_add</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_add</b></font></td>
<td><font size="+1"><b>ME_Rows_add</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_add</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_add</b></font></td>
<td><font size="+1"><b>MCE_Rows_add</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one row the sum of itself and another row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_add( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned destRow, unsigned sourceRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_add( const&nbsp;unsigned&nbsp;destRow, const&nbsp;unsigned&nbsp;sourceRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_add( MA:fMatrix; ht,&nbsp;len,&nbsp;destRow, sourceRow:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_add( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destRow, unsigned&nbsp;sourceRow&nbsp;);
<BR>void MFcu_Rows_add( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destRow, unsigned&nbsp;sourceRow&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_add( d_MA:fMatrix; ht,&nbsp;len,&nbsp;destRow,&nbsp;sourceRow:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_add( h_MA:fMatrix; ht,&nbsp;len,&nbsp;destRow,&nbsp;sourceRow:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>destRow, j</sub> += MA<sub>sourceRow, j</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_sub">MF_Rows_sub</a>,&nbsp;&nbsp; <a href="#Rows_Cadd">MF_Rows_Cadd</a>,&nbsp;&nbsp; <a href="#Rows_lincomb">MF_Rows_lincomb</a>,&nbsp;&nbsp; <a href="#chap8">chapter&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_cabsmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_cabsmax</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Rows_cabsmax</b></font></td>
<td><font size="+1"><b>MCE_Rows_cabsmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex numbers of largest magnitude along rows and store them in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_Rows_cabsmax( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt; T&gt;::Rows_cabsmax( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_Rows_cabsmax( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Rows_cabsmax( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Rows_cabsmax( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Rows_cabsmax( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Rows_cabsmax( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Within each row i of MA, the complex number of largest magnitude, sqrt(Re<sup>2</sup>+Im<sup>2</sup>),  is found and stored as the element Y<sub>i</sub> for i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmax">MCF_Rows_absmax</a>,&nbsp;&nbsp; <a href="#Rows_cabsmin">MCF_Rows_cabsmin</a>,&nbsp;&nbsp; <a href="#Rows_sabsmax">MCF_Rows_sabsmax</a>,&nbsp;&nbsp; <a href="#Cols_cabsmax">MCF_Cols_cabsmax</a>,&nbsp;&nbsp; <a href="#Dia_cabsmax">MCF_Dia_cabsmax</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_cabsmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_cabsmin</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Rows_cabsmin</b></font></td>
<td><font size="+1"><b>MCE_Rows_cabsmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex numbers of smallest magnitude along rows and store them in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_Rows_cabsmin( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt; T&gt;::Rows_cabsmin( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_Rows_cabsmin( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Rows_cabsmin( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Rows_cabsmin( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Rows_cabsmin( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Rows_cabsmin( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Within each row i of MA, the complex number of smallest magnitude, sqrt(Re<sup>2</sup>+Im<sup>2</sup>),  is found and stored as the element Y<sub>i</sub> for i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmin">MCF_Rows_absmin</a>,&nbsp;&nbsp; <a href="#Rows_cabsmax">MCF_Rows_cabsmax</a>,&nbsp;&nbsp; <a href="#Rows_sabsmin">MCF_Rows_sabsmin</a>,&nbsp;&nbsp; <a href="#Cols_cabsmin">MCF_Cols_cabsmin</a>,&nbsp;&nbsp; <a href="#Dia_cabsmin">MCF_Dia_cabsmin</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_Cadd"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_Cadd</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_Cadd</b></font></td>
<td><font size="+1"><b>ME_Rows_Cadd</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_Cadd</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_Cadd</b></font></td>
<td><font size="+1"><b>MCE_Rows_Cadd</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one row the sum of itself and another row, scaled by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_Cadd( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned destRow, unsigned sourceRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_Cadd( const&nbsp;unsigned&nbsp;destRow, const&nbsp;unsigned&nbsp;sourceRow, const&nbsp;T&amp;&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_Cadd( MA:fMatrix; ht,&nbsp;len,&nbsp;destRow, sourceRow:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_Cadd( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destRow, unsigned&nbsp;sourceRow, float&nbsp;C&nbsp;);
<BR>int cusdMF_Rows_Cadd( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destRow, unsigned&nbsp;sourceRow, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_Rows_Cadd( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destRow, unsigned&nbsp;sourceRow, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_Cadd( d_MA:fMatrix; ht,&nbsp;len,&nbsp;destRow,&nbsp;sourceRow:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Rows_Cadd( d_MA:fMatrix; ht,&nbsp;len,&nbsp;destRow,&nbsp;sourceRow:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_Cadd( h_MA:fMatrix; ht,&nbsp;len,&nbsp;destRow,&nbsp;sourceRow:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>destRow, j</sub> += C *&nbsp;MA<sub>sourceRow, j</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_add">MF_Rows_add</a>,&nbsp;&nbsp; <a href="#Rows_lincomb">MF_Rows_lincomb</a>,&nbsp;&nbsp; <a href="#chap8">chapter&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Rows_distribution"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_distribution</b></font></td><td width="33%"><font size="+1"><b>MD_Rows_distribution</b></font></td><td><font size="+1"><b>ME_Rows_distribution</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Rows_distribution</b></font></td><td width="20%"><font size="+1"><b>MBI_Rows_distribution</b></font></td><td width="20%"><font size="+1"><b>MSI_Rows_distribution</b></font></td><td width="20%"><font size="+1"><b>MLI_Rows_distribution</b></font></td><td><font size="+1"><b>MQI_Rows_distribution</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Rows_distribution</b></font></td><td width="20%"><font size="+1"><b>MUB_Rows_distribution</b></font></td><td width="20%"><font size="+1"><b>MUS_Rows_distribution</b></font></td><td width="20%"><font size="+1"><b>MUL_Rows_distribution</b></font></td><td><font size="+1"><b>MUQ_Rows_distribution</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Histogram or Distribution function along rows</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;
<BR>void MF_Rows_distribution( uiMatrix MAbund, fVector&nbsp;Limits, ui&nbsp;nbins, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;mode&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void matrix&lt;ui&gt;::Rows_distribution( const&nbsp;vector&lt;T&gt;&amp;&nbsp;Limits, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, int&nbsp;mode=0&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>procedure MF_Rows_distribution( MAbund:uiMatrix; Limits:fVector; nbins:UIntSize; MA:fMatrix; ht,&nbsp;len:UIntSize; mode:Integer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_distribution( uiMatrix&nbsp;d_MAbund, fVector&nbsp;d_Limits, ui&nbsp;nbins, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;mode&nbsp;);
<BR>void MFcu_Rows_distribution( uiMatrix&nbsp;h_MAbund, fVector&nbsp;h_Limits, ui&nbsp;nbins, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;mode&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_distribution( d_MAbund:uiMatrix; d_Limits:fVector; nbins:UIntSize; d_MA:fMatrix; ht,&nbsp;len:UIntSize; mode:Integer&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_distribution( h_MAbund:uiMatrix; h_Limits:fVector; nbins:UIntSize; h_MA:fMatrix; ht,&nbsp;len:UIntSize; mode:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each row of MA, this function counts the number of elements falling into each of the intervals defined by Limits. The abundances thus determined are stored in the corresponding columns of MAbund.
<BR>nbins is the number of elements of Limits, i.e. the number of intervals. The size of MAbund is ht*nbins.
<P>Limits must be in ascending order. The spacing between the elements of Limits need not necessarily be constant.
<P>The parameter mode specifies how to interpret the values given in Limits.
<BR>mode &gt; 0: Limits contains the upper limits of the intervals
<BR>mode &lt; 0: Limits contains the lower limits of the intervals
<BR>mode = 0: Limits contains the mid-points of the intervals. An element of MA belongs to the Limits value closest to it. In case of exactly equal distances, the interval with the lower index is chosen.
<BR>The interval defined by Limits<sub>0</sub> extends down to -HUGE_VAL, the interval defined by Limits<sub>nbins-1</sub> reaches up to +HUGE_VAL.
<P>In contrast to <I><a href="FUNCREF.HTM#distribution">VF_distribution</a></I>, elements outside the intervals are not taken into account; their number is not returned.
<P>This function may be used for batch processing of several vectors of equal size. To this end, the vectors have to be copied into the rows of a matrix.</P>
<P>At present, these functions are available only in the 64-bit libraries.</P>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="FUNCREF.HTM#distribution">VF_distribution</a> &nbsp;&nbsp;<a href="#Cols_distribution">MF_Cols_distribution</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_exchange"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_exchange</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_exchange</b></font></td>
<td><font size="+1"><b>ME_Rows_exchange</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_exchange</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_exchange</b></font></td>
<td><font size="+1"><b>MCE_Rows_exchange</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Rows_exchange</b></font></td><td width="20%"><font size="+1"><b>MBI_Rows_exchange</b></font></td><td width="20%"><font size="+1"><b>MSI_Rows_exchange</b></font></td><td width="20%"><font size="+1"><b>MLI_Rows_exchange</b></font></td><td><font size="+1"><b>MQI_Rows_exchange</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Rows_exchange</b></font></td><td width="20%"><font size="+1"><b>MUB_Rows_exchange</b></font></td><td width="20%"><font size="+1"><b>MUS_Rows_exchange</b></font></td><td width="20%"><font size="+1"><b>MUL_Rows_exchange</b></font></td><td><font size="+1"><b>MUQ_Rows_exchange</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>exchange two rows</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_exchange( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned i1, unsigned i2&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_exchange( const&nbsp;unsigned&nbsp;i1, const&nbsp;unsigned&nbsp;i2&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_exchange( MA:fMatrix; ht,&nbsp;len,&nbsp;i1, i2:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_exchange( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;i1, unsigned&nbsp;i2&nbsp;);
<BR>void MFcu_Rows_exchange( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;i1, unsigned&nbsp;i2&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_exchange( d_MA:fMatrix; ht,&nbsp;len,&nbsp;i1,&nbsp;i2:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_exchange( h_MA:fMatrix; ht,&nbsp;len,&nbsp;i1,&nbsp;i2:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The elements of the rows i1 and i2 are exchanged.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_exchange">MF_Cols_exchange</a>,&nbsp;&nbsp; <a href="#chap8">chapter&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_FFT"></a><a name="Rows_FFTtoC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MD_Rows_FFT</b></font></td>
<td><font size="+1"><b>ME_Rows_FFT</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>MFb_Rows_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MDb_Rows_FFT</b></font></td>
<td><font size="+1"><b>MEb_Rows_FFT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_FFTtoC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_FFTtoC</b></font></td>
<td><font size="+1"><b>ME_Rows_FFTtoC</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>MFb_Rows_FFTtoC</b></font>
</td><td width="33%"><font size="+1"><b>MDb_Rows_FFTtoC</b></font></td>
<td><font size="+1"><b>MEb_Rows_FFTtoC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_FFT</b></font></td>
<td><font size="+1"><b>MCE_Rows_FFT</b></font></td></tr>
<tr valign="TOP">
<td width="33%"><font size="+1"><b>MCFb_Rows_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MCDb_Rows_FFT</b></font></td>
<td><font size="+1"><b>MCEb_Rows_FFT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Fast Fourier Transform along the rows</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_FFT( fMatrix&nbsp;Y, fMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MCF_Rows_FFT( cfMatrix&nbsp;Y, cfMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MF_Rows_FFTtoC( cfMatrix&nbsp;Y, fMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MFb_Rows_FFT( fMatrix&nbsp;Y, fMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir, fVector&nbsp;Buf&nbsp;);<BR>
void MCFb_Rows_FFT( cfMatrix&nbsp;Y, cfMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir, cfVector&nbsp;Buf&nbsp;);<BR>
void MFb_Rows_FFTtoC( cfMatrix&nbsp;Y, fMatrix&nbsp;X, ui&nbsp;ht, ui&nbsp;len, cfVector&nbsp;Buf&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_FFT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, int&nbsp;dir&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::FFT( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MX, int&nbsp;dir&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::FFTtoC( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX&nbsp;);<br>
void matrix&lt;T&gt;::b_Rows_FFT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, int&nbsp;dir, vector&lt;T&gt;&amp;&nbsp;Buf&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::b_Rows_FFT( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&nbsp;MX, int&nbsp;dir, vector&lt;complex&lt;T&gt;&nbsp;&gt;&amp;Buf&nbsp;);<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::b_Rows_FFTtoC( const&nbsp;matrix&lt;T&gt;&nbsp;MX, vector&lt;complex&lt;T&gt;&gt;&amp;&nbsp;Buf&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_FFT( MY,&nbsp;MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MCF_Rows_FFT( MY,&nbsp;MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MF_Rows_FFTtoC( MY:cfMatrix; MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<br>
procedure MFb_Rows_FFT( MY,&nbsp;MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer; Buf:fVector&nbsp;);<BR>
procedure MCFb_Rows_FFT( MY,&nbsp;MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer; Buf:cfVector&nbsp;);<BR>
procedure MFb_Rows_FFTtoC( MY:cfMatrix; MX:fMatrix; ht,&nbsp;len:UIntSize; Buf:cfVector&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMF_Rows_FFT( fMatrix&nbsp;d_Y, fMatrix&nbsp;d_X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
int cuda MCF_Rows_FFT( cfMatrix&nbsp;d_Y, cfMatrix&nbsp;d_X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
int cudaMF_Rows_FFTtoC( cfMatrix&nbsp;d_Y, fMatrix&nbsp;d_X, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MFcu_Rows_FFT( fMatrix&nbsp;h_Y, fMatrix&nbsp;h_X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MCFcu_Rows_FFT( cfMatrix&nbsp;h_Y, cfMatrix&nbsp;h_X, ui&nbsp;ht, ui&nbsp;len, int&nbsp;dir&nbsp;);<BR>
void MFcu_Rows_FFTtoC( cfMatrix&nbsp;h_Y, fMatrix&nbsp;h_X, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd, MCFstd;
<BR>function cudaMF_Rows_FFT( d_MY,&nbsp;d_MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;):&nbsp;IntBool;<BR>
function cudaMCF_Rows_FFT( d_MY,&nbsp;d_MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;):&nbsp;IntBool;<BR>
function cudaMF_Rows_FFTtoC( d_MY:cfMatrix; d_MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_FFT( h_MY,&nbsp;h_MX:fMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MCFcu_Rows_FFT( h_MY,&nbsp;h_MX:cfMatrix; ht,&nbsp;len:UIntSize; dir:Integer&nbsp;);<BR>
procedure MFcu_Rows_FFTtoC( h_MY:cfMatrix; h_MX:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The one-dimensional Fourier transform of all rows of MX is calculated and stored in the corresponding rows of MY. The forward transform is obtained by setting dir = 1, the inverse (or backward) transform by setting dir = -1. By convention, the inverse transform involves scaling the result by the factor <I>1.0/len</I> (so as to ensure that the result of one forward and one backward transform yields &#x2013; within round-off error &#x2013; the original matrix). Since it is sometimes desirable to skip this implicit scaling, <I>MF_Rows_FFT</I> offers the possibility to do so: specify dir = -2 in this case.
<BR>A Fast Fourier Transform algorithm is used that requires <i>len</i> to be a power of 2. &nbsp;<i>ht</i>&nbsp;may be set arbitrarily, but the function will be most efficient if <i>ht</i> is a multiple of 4.
<BR>Complex version: Both MX and the output MY are complex matrices.
<BR>Real-to-complex version: The input matrix MX is real. The output matrix MY is complex. As this function can only perform a forward transform, no argument &quot;dir&quot; is needed.
<BR>Purely real version: For the forward transform, MX is a real matrix. The output MY is also defined as fMatrix, although it consists of complex numbers. The reason is that the symmetry properties of FFT allow to store the result in a packed format, fitting into the same memory space as the input matrix. The order of each row of MY is indicated in the following table. U means the uncompressed result, N is <i>len</i>.
<table border width="100%">
<tr valign="TOP">
<td>MY<sub>i,0</sub></td><td>MY<sub>i,1</sub></td><td>MY<sub>i,2</sub>
</td><td>MY<sub>i,3</sub></td><td>&nbsp;&nbsp;.....&nbsp;&nbsp;
</td><td>MY<sub>i,N-2</sub></td><td>MY<sub>i,N-1</sub></td></tr>
<tr valign="TOP">
<td>U<sub>i,0</sub>.Re</td><td>U<sub>i,N/2</sub>.Re</td><td>U<sub>i,1</sub>.Re
</td><td>U<sub>i,1</sub>.Im</td><td>&nbsp;&nbsp;.....&nbsp;&nbsp;
</td><td>U<sub>i,N/2-1</sub>.Re</td><td>U<sub>i,N/2-1</sub>.Im</td></tr></table>
&nbsp;
<BR>This storage scheme implies that, for Pascal/Delphi (where matrices are stored in column-major order), the real and imaginary parts of any element are not adjacent in memory . 
<BR>For inverse real-matrix Rows_FFT, the input matrix has to be of this packed-complex format, and you get a real matrix. If you prefer to get the result of forward FFT in true complex format, use <I>MF_Rows_FFTtoC</I>.
<P><i>MFb_Rows_FFT, MFb_Rows_FFTtoC</i> and <i>MCFb_Rows_FFT</i> take a buffer vector <i>Buf</i> as an additional argument. They are slightly more efficient than the un-buffered versions. <i>Buf</i> must have (at least) the same size as X and Y (i.e., Buf.size &gt;= ht*len).
<P>For historical reasons, there exist special versions with the prefixes <I>VFp_, &nbsp;VFs_</I> and <I>VFl_</I>. They are deprecated and may be removed in future versions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If <i>len</i> is not a power of 2, the program is aborted with the error message &quot;Size must be an integer power of 2&quot;.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_FFT">MF_Cols_FFT</a>,&nbsp;&nbsp; <a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#chap12">chapter&nbsp;12</a>,&nbsp;&nbsp; <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8 of HANDBOOK.HTM</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_lincomb"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_lincomb</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_lincomb</b></font></td>
<td><font size="+1"><b>ME_Rows_lincomb</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_lincomb</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_lincomb</b></font></td>
<td><font size="+1"><b>MCE_Rows_lincomb</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>linear combination of two rows</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_lincomb( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned destRow, float&nbsp;destC, unsigned srceRow, float&nbsp;srceC&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_lincomb( const&nbsp;unsigned&nbsp;destRow, const&nbsp;T&amp;&nbsp;destC, const&nbsp;unsigned&nbsp;sourceRow, const&nbsp;T&amp;&nbsp;srceC&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_lincomb( MA:fMatrix; ht,&nbsp;len:UIntSize; destRow:UIntSize; destC:Single;
srceRow:UIntSize; srceC:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_lincomb( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destRow, float&nbsp;destC, unsigned&nbsp;srceRow, float&nbsp;srceC&nbsp;);
<BR>int cusdMF_Rows_lincomb( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destRow, float&nbsp;
d_destC, unsigned&nbsp;srceRow, float&nbsp;*d_srceC&nbsp;);
<BR>void MFcu_Rows_lincomb( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destRow, float&nbsp;destC, unsigned&nbsp;srceRow, float&nbsp;srceC&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_lincomb( d_MA:fMatrix; ht,&nbsp;len:UIntSize; destRow:UIntSize; destC:Single; srceRow:UIntSize; srceC:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMF_Rows_lincomb( d_MA:fMatrix; ht,&nbsp;len:UIntSize; destRow:UIntSize; d_destC:PSingle; srceRow:UIntSize; d_srceC:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_lincomb( h_MA:fMatrix; ht,&nbsp;len:UIntSize; destRow:UIntSize; destC:Single; srceRow:UIntSize; srceC:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>destRow, j</sub> = destC *&nbsp;MA<sub>destRow, j</sub>+ srceC *&nbsp;MA<sub>srceRow, j</sub>,&nbsp;&nbsp;j=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_add">MF_Rows_add</a>,&nbsp;&nbsp; <a href="#Rows_Cadd">MF_Rows_Cadd</a>,&nbsp;&nbsp; <a href="#chap8">chapter&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_max"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_max</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_max</b></font></td>
<td><font size="+1"><b>ME_Rows_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Rows_max</b></font></td><td width="20%"><font size="+1"><b>MBI_Rows_max</b></font></td><td width="20%"><font size="+1"><b>MSI_Rows_max</b></font></td><td width="20%"><font size="+1"><b>MLI_Rows_max</b></font></td><td><font size="+1"><b>MQI_Rows_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Rows_max</b></font></td><td width="20%"><font size="+1"><b>MUB_Rows_max</b></font></td><td width="20%"><font size="+1"><b>MUS_Rows_max</b></font></td><td width="20%"><font size="+1"><b>MUL_Rows_max</b></font></td><td><font size="+1"><b>MUQ_Rows_max</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the maxima of all individual rows in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_max( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Rows_max( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_max( Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_max( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Rows_max( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_max( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_max( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum value of each row <I>i</I> is stored as the element Y<sub>i</sub> for i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmax">MF_Rows_absmax</a>,&nbsp;&nbsp; <a href="#Rows_min">MF_Rows_min</a>,&nbsp;&nbsp; <a href="#Cols_max">MF_Cols_max</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_maxReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_maxReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Rows_maxReIm</b></font></td>
<td><font size="+1"><b>MCE_Rows_maxReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the largest values of the real and imaginary parts of each row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_Rows_maxReIm( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt;&nbsp;&gt;::Rows_maxReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_Rows_maxReIm( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Rows_maxReIm( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Rows_maxReIm( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Rows_maxReIm( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Rows_maxReIm( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum values of the real and imaginary parts of each row <I>i</I> are combined into the element Y<sub>i</sub> for i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmax">MCF_Rows_absmax</a>,&nbsp;&nbsp; <a href="#Rows_minReIm">MCF_Rows_minReIm</a>,&nbsp;&nbsp; <a href="#Cols_maxReIm">MCF_Cols_maxReIm</a>,&nbsp;&nbsp; <a href="#Rows_absmaxReIm">MCF_Rows_absmaxReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_min"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_min</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_min</b></font></td>
<td><font size="+1"><b>ME_Rows_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Rows_min</b></font></td><td width="20%"><font size="+1"><b>MBI_Rows_min</b></font></td><td width="20%"><font size="+1"><b>MSI_Rows_min</b></font></td><td width="20%"><font size="+1"><b>MLI_Rows_min</b></font></td><td><font size="+1"><b>MQI_Rows_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Rows_min</b></font></td><td width="20%"><font size="+1"><b>MUB_Rows_min</b></font></td><td width="20%"><font size="+1"><b>MUS_Rows_min</b></font></td><td width="20%"><font size="+1"><b>MUL_Rows_min</b></font></td><td><font size="+1"><b>MUQ_Rows_min</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the minima of all individual rows in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_min( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Rows_min( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_min( Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_min( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Rows_min( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_min( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_min( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The smallest or most negative element of each row <I>i</I> is stored as the element Y<sub>i</sub> for i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmin">MF_Rows_absmin</a>,&nbsp;&nbsp; <a href="#Rows_max">MF_Rows_max</a>,&nbsp;&nbsp; <a href="#Cols_min">MF_Cols_min</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_minReIm"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_minReIm</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Rows_minReIm</b></font></td>
<td><font size="+1"><b>MCE_Rows_minReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the smallest values of the real and imaginary parts of each row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_Rows_minReIm( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt;&nbsp;&gt;::Rows_minReIm( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_Rows_minReIm( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Rows_minReIm( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Rows_minReIm( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Rows_minReIm( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Rows_minReIm( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum values of the real and imaginary parts of each row <I>i</I> are combined into the element Y<sub>i</sub> for i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmin">MCF_Rows_absmin</a>,&nbsp;&nbsp; <a href="#Rows_maxReIm">MCF_Rows_maxReIm</a>,&nbsp;&nbsp; <a href="#Cols_minReIm">MCF_Cols_minReIm</a>,&nbsp;&nbsp; <a href="#Rows_absminReIm">MCF_Rows_absminReIm</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_prod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_prod</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_prod</b></font></td>
<td><font size="+1"><b>ME_Rows_prod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_prod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_prod</b></font></td>
<td><font size="+1"><b>MCE_Rows_prod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>products over all elements of each individual row, stored in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_prod(fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Rows_prod( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_prod(Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_prod( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Rows_prod( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_prod( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_prod( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = prod( MA<sub>i,j</sub>, j=0,...,len-1),&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_runprod">MF_Rows_runprod</a>,&nbsp;&nbsp; <a href="#Rows_sum">MF_Rows_sum</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_reflect"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_reflect</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_reflect</b></font></td>
<td><font size="+1"><b>ME_Rows_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_reflect</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_reflect</b></font></td>
<td><font size="+1"><b>MCE_Rows_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Rows_reflect</b></font></td><td width="20%"><font size="+1"><b>MBI_Rows_reflect</b></font></td><td width="20%"><font size="+1"><b>MSI_Rows_reflect</b></font></td><td width="20%"><font size="+1"><b>MLI_Rows_reflect</b></font></td><td><font size="+1"><b>MQI_Rows_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Rows_reflect</b></font></td><td width="20%"><font size="+1"><b>MUB_Rows_reflect</b></font></td><td width="20%"><font size="+1"><b>MUS_Rows_reflect</b></font></td><td width="20%"><font size="+1"><b>MUL_Rows_reflect</b></font></td><td><font size="+1"><b>MUQ_Rows_reflect</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Derive the second halves of all rows from their first halves by reflection at the vertical line through the center of the matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_reflect( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_reflect(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_reflect( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_reflect( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Rows_reflect( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_reflect( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_reflect( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i, len-j-1</sub> = MA<sub>i, j</sub>,&nbsp;&nbsp;i=0,...,ht-1;&nbsp;&nbsp;j=0,...,(len-1)/2;</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_rotate">MF_Rows_rotate</a>,&nbsp;&nbsp; <a href="#Cols_reflect">MF_Cols_reflect</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_rev"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_rev</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_rev</b></font></td>
<td><font size="+1"><b>ME_Rows_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_rev</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_rev</b></font></td>
<td><font size="+1"><b>MCE_Rows_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Rows_rev</b></font></td><td width="20%"><font size="+1"><b>MBI_Rows_rev</b></font></td><td width="20%"><font size="+1"><b>MSI_Rows_rev</b></font></td><td width="20%"><font size="+1"><b>MLI_Rows_rev</b></font></td><td><font size="+1"><b>MQI_Rows_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Rows_rev</b></font></td><td width="20%"><font size="+1"><b>MUB_Rows_rev</b></font></td><td width="20%"><font size="+1"><b>MUS_Rows_rev</b></font></td><td width="20%"><font size="+1"><b>MUL_Rows_rev</b></font></td><td><font size="+1"><b>MUQ_Rows_rev</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse the element ordering along rows. This corresponds to a relection of the matrix at the X axis.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_rev( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_rev(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_rev( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_rev( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Rows_rev( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_rev( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_rev( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i, j</sub> = MA<sub>i, len-j-1</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="Cols_rev">MF_Cols_rev</a>,&nbsp;&nbsp; <a href="#Rows_reflect">MF_Rows_reflect</a>,&nbsp;&nbsp; <a href="#rotate90">MF_rotate90</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a>
</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_rotate"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_rotate</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_rotate</b></font></td>
<td><font size="+1"><b>ME_Rows_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_rotate</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_rotate</b></font></td>
<td><font size="+1"><b>MCE_Rows_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Rows_rotate</b></font></td><td width="20%"><font size="+1"><b>MBI_Rows_rotate</b></font></td><td width="20%"><font size="+1"><b>MSI_Rows_rotate</b></font></td><td width="20%"><font size="+1"><b>MLI_Rows_rotate</b></font></td><td><font size="+1"><b>MQI_Rows_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Rows_rotate</b></font></td><td width="20%"><font size="+1"><b>MUB_Rows_rotate</b></font></td><td width="20%"><font size="+1"><b>MUS_Rows_rotate</b></font></td><td width="20%"><font size="+1"><b>MUL_Rows_rotate</b></font></td><td><font size="+1"><b>MUQ_Rows_rotate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>rotate all rows by a specified number of positions; thereby, whole columns are moved</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_rotate( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_rotate( const int&nbsp;pos&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_rotate( MA:fMatrix; ht,&nbsp;len:UIntSize; pos:Integer&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_rotate( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;pos&nbsp;);
<BR>void MFcu_Rows_rotate( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;pos&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_rotate( d_MA:fMatrix; ht,&nbsp;len:UIntSize; pos:Integer&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_rotate( h_MA:fMatrix; ht,&nbsp;len:UIntSize; pos:Integer&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = MA<sub>i, len-pos+j</sub>,&nbsp;&nbsp;&nbsp;j=0,..,pos-1
<BR>MA<sub>i,j</sub> = MA<sub>i, j-pos</sub>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j=pos,...,len-1
<BR>MA<sub>i,j</sub> = MA<sub>i-pos, j</sub>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=pos,...,ht-1
<P>This function is rather inefficient, as it needs to internally allocate and de-allocate work-space each time it is called. If your application contains frequent calls to this function, we recommend to allocate some matrix MBuf as buffer memory and replace the calls to <i>MF_Rows_rotate</i> by calls to <i><a href="#Rows_rotate_buf">MF_Rows_rotate_buf</a></i>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_reflect">MF_Rows_reflect</a>,&nbsp;&nbsp; <a href="#Cols_rotate">MF_Cols_rotate</a>,&nbsp;&nbsp; <a href="#Rows_rotate_buf">MF_Rows_rotate_buf</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_rotate_buf"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_rotate_buf</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_rotate_buf</b></font></td>
<td><font size="+1"><b>ME_Rows_rotate_buf</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_rotate_buf</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_rotate_buf</b></font></td>
<td><font size="+1"><b>MCE_Rows_rotate_buf</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Rows_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MBI_Rows_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MSI_Rows_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MLI_Rows_rotate_buf</b></font></td><td><font size="+1"><b>MQI_Rows_rotate_buf</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Rows_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MUB_Rows_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MUS_Rows_rotate_buf</b></font></td><td width="20%"><font size="+1"><b>MUL_Rows_rotate_buf</b></font></td><td><font size="+1"><b>MUQ_Rows_rotate_buf</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>efficient row rotation (moving of whole rows), using specified buffer memory</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_rotate_buf( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;pos, fMatrix&nbsp;MBuf&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_rotate_buf( const int&nbsp;pos, const&nbsp;matrix&lt;T&gt;&nbsp;MBuf&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_rotate_buf( MA:fMatrix; ht,&nbsp;len:UIntSize; pos:Integer; MBuf:fMatrix&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_rotate_buf( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, int&nbsp;pos, fMatrix&nbsp;d_MBuf&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_rotate_buf( d_MA:fMatrix; ht,&nbsp;len:UIntSize; pos:Integer; d_MBuf:fMatrix&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = MA<sub>i, len-pos+j</sub>,&nbsp;&nbsp;&nbsp;j=0,..,pos-1
<BR>MA<sub>i,j</sub> = MA<sub>i, j-pos</sub>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j=pos,...,len-1
<BR>MA<sub>i,j</sub> = MA<sub>i-pos, j</sub>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=pos,...,ht-1
<P>This function is a more efficient variant of  <i><a href="#Rows_rotate">MF_Rows_rotate</a></i>. Instead of internally allocating the necessary work-space, it takes the matrix MBuf as buffer memory. MBuf must be a matrix generated by the <i>OptiVec</i> memory management functions (<i><a href="#matrix">MF_matrix</a></i> etc.). The size (i.e., the number of elements, ht*len) of MBuf must be at least the same size as MA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_rotate">MF_Rows_rotate</a>,&nbsp;&nbsp; <a href="#Cols_rotate_buf">MF_Cols_rotate_buf</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_runprod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_runprod</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_runprod</b></font></td>
<td><font size="+1"><b>ME_Rows_runprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_runprod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_runprod</b></font></td>
<td><font size="+1"><b>MCE_Rows_runprod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>running product over row elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_runprod( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_runprod(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_runprod( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_runprod( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Rows_runprod( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_runprod( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_runprod( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For all rows separately, each element is the product of itself and all preceding elements. This function should be used with care: overflow is easily reached, and underflow may lead to all elements from a certain position on being zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_prod">MF_Rows_prod</a>,&nbsp;&nbsp; <a href="#Cols_runprod">MF_Cols_runprod</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_runsum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_runsum</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_runsum</b></font></td>
<td><font size="+1"><b>ME_Rows_runsum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_runsum</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_runsum</b></font></td>
<td><font size="+1"><b>MCE_Rows_runsum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>running sum over row elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_runsum( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_runsum(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_runsum( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_runsum( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Rows_runsum( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_runsum( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_runsum( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For all rows separately, each element is the sum of itself and all preceding elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_sum">MF_Rows_sum</a>,&nbsp;&nbsp; <a href="#Cols_runsum">MF_Cols_runsum</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_sabsmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_sabsmax</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Rows_sabsmax</b></font></td>
<td><font size="+1"><b>MCE_Rows_sabsmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex numbers of largest sum |Re|&nbsp;+&nbsp;|Im|  along rows and store them in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_Rows_sabsmax( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt; T&gt;::Rows_sabsmax( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_Rows_sabsmax( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Rows_sabsmax( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Rows_sabsmax( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Rows_sabsmax( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Rows_sabsmax( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Within each row i of MA, the complex number with the largest sum, |Re|&nbsp;+&nbsp;|Im|,  is found and stored as the element Y<sub>i</sub> for i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmax">MCF_Rows_absmax</a>,&nbsp;&nbsp; <a href="#Rows_sabsmin">MCF_Rows_sabsmin</a>,&nbsp;&nbsp; <a href="#Cols_sabsmax">MCF_Cols_sabsmax</a>,&nbsp;&nbsp; <a href="#Dia_sabsmax">MCF_Dia_sabsmax</a>,&nbsp;&nbsp; <a href="#Rows_cabsmax">MCF_Rows_cabsmax</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_sabsmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_sabsmin</b></font>
</td><td width="33%"><font size="+1"><b>MCD_Rows_sabsmin</b></font></td>
<td><font size="+1"><b>MCE_Rows_sabsmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex numbers of largest sum |Re|&nbsp;+&nbsp;|Im|  along rows and store them in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_Rows_sabsmin( cfVector&nbsp;Y, cfMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;complex&lt;T&gt; T&gt;::Rows_sabsmin( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_Rows_sabsmin( Y:cfVector; MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_Rows_sabsmin( cfVector&nbsp;d_Y, cfMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MCFcu_Rows_sabsmin( cfVector&nbsp;h_Y, cfMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_Rows_sabsmin( d_Y:cfVector; d_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCFcu_Rows_sabsmin( h_Y:cfVector; h_MA:cfMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Within each row i of MA, the complex number with the largest sum, |Re|&nbsp;+&nbsp;|Im|,  is found and stored as the element Y<sub>i</sub> for i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmin">MCF_Rows_absmin</a>,&nbsp;&nbsp; <a href="#Rows_cabsmin">MCF_Rows_cabsmin</a>,&nbsp;&nbsp; <a href="#Rows_sabsmax">MCF_Rows_sabsmax</a>,&nbsp;&nbsp; <a href="#Cols_sabsmin">MCF_Cols_sabsmin</a>,&nbsp;&nbsp; <a href="#Dia_sabsmin">MCF_Dia_sabsmin</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_sub"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_sub</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_sub</b></font></td>
<td><font size="+1"><b>ME_Rows_sub</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_sub</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_sub</b></font></td>
<td><font size="+1"><b>MCE_Rows_sub</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one row the difference of itself and another row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_sub( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned destRow, unsigned sourceRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Rows_sub( const&nbsp;unsigned&nbsp;destRow, const&nbsp;unsigned&nbsp;sourceRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_sub( MA:fMatrix; ht,&nbsp;len,&nbsp;destRow, sourceRow:UIntSize;&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_sub( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destRow, unsigned&nbsp;sourceRow&nbsp;);
<BR>void MFcu_Rows_sub( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;destRow, unsigned&nbsp;sourceRow&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_sub( d_MA:fMatrix; ht,&nbsp;len,&nbsp;destRow,&nbsp;sourceRow:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_sub( h_MA:fMatrix; ht,&nbsp;len,&nbsp;destRow,&nbsp;sourceRow:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>destRow, j</sub> -= MA<sub>sourceRow, j</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_add">MF_Rows_add</a>,&nbsp;&nbsp; <a href="#Rows_Cadd">MF_Rows_Cadd</a>,&nbsp;&nbsp; <a href="#chap8">chapter&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_sum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_sum</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_sum</b></font></td>
<td><font size="+1"><b>ME_Rows_sum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_sum</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_sum</b></font></td>
<td><font size="+1"><b>MCE_Rows_sum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>sums over all elements of each individual row, stored in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_sum( fVector&nbsp;Y, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::Rows_sum( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_sum( Y:fVector; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Rows_sum( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Rows_sum( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Rows_sum( d_Y:fVector; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Rows_sum( h_Y:fVector; h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = sum( MA<sub>i,j</sub>, j=0,...,len-1),&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_runsum">MF_Rows_runsum</a>,&nbsp;&nbsp; <a href="#Rows_prod">MF_Rows_prod</a>,&nbsp;&nbsp; <a href="#chap7">chapter&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="safeSolve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_safeSolve</b></font>
</td><td width="33%"><font size="+1"><b>MD_safeSolve</b></font></td>
<td><font size="+1"><b>ME_safeSolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>solve a linear system MA *&nbsp;X = B; in case the system is singular, get one solution out of the infinite solution space</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_safeSolve( fVector&nbsp;X, fMatrix&nbsp;MA, fVector&nbsp;B, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::safeSolve( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;vector&lt;T&gt;&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_safeSolve( X:fVector; MA:fMatrix; B:fVector; len:UIntSize&nbsp;):Integer;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_safeSolve</I> is similar to <I><a href="#solve">MF_solve</a></I> with the difference that, in case there is no unique solution of the linear system (i.e., LU decomposition fails), singular value decomposition is employed to obtain at least one solution out of the infinite solution space. Recall that the problem with singular linear systems is not that they don't have a solution, but rather that they are under-determined and have infinitely many solutions. In other words, one or more elements of the solution vector can be chosen arbitrarily. This is what <I>MF_safeSolve</I> does, with the additional constraint that the &quot;smallest&quot; solution vector in the least-squares sense is determined.
<P>A return value of 0 indicates success via LUD, 1 signals success via SVD, and -1 is returned in the very rare case that even SVD fails.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#solve">MF_solve</a>,&nbsp;&nbsp; <a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setDensityBounds"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="90%"><font size="+1"><b>M_setDensityBounds</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculate a color scale for color density plots</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void M_setDensityBounds( extended zmin, extended zmax, COLORREF&nbsp;mincolor, COLORREF&nbsp;maxcolor&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure M_setDensityBounds( zmin, zmax: Extended; mincolor, maxcolor: COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A color scale is calculated between the colors <I>mincolor</I> and <I>maxcolor</I>, corresponding to <I>zmin</I> and <I>zmax</I>. In any following <I><a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a></I> or <I><a href="#zDataDensityMap">MF_zDataDensityMap</a></I> plot, the <I>z</I> values will be translated into colors by interpolation between the extreme values set by <I>M_setDensityBounds</I>. You will rarely call this function directly. It is internally called by all functions of the <I><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a></I> and <I><a href="#zAutoDensityMap">MF_zAutoDensityMap</a></I> families.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setDensityMapBounds">M_setDensityMapBounds</a>,&nbsp;&nbsp; <a href="#findDensityMapBounds">M_findDensityMapBounds</a>,&nbsp;&nbsp; <a href="#chap15">chapter&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setDensityMapBounds"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="90%"><font size="+1"><b>M_setDensityMapBounds</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Set a color scale and draw an X-Y coordinate system for matrix color-density plots</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void M_setDensityMapBounds( extended xmin, extended xmax, extended ymin, extended ymax, extended zmin, extended zmax, COLORREF&nbsp;mincolor, COLORREF&nbsp;maxcolor&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure M_setDensityMapBounds( xmin, xmax, ymin, ymax, zmin, zmax: Extended; mincolor, maxcolor: COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Similarly to the function <I><a href="FUNCREF.HTM#drawAxes">V_drawAxes</a></I> for X-Y vector plots, this function calculates a color scale from the parameters mincolor, maxcolor, zmin and zmax, and prepares an X-Y coordinate system with the <I>x</I> and <I>y</I> ranges specified by <I>xmin, xmax, ymin</I>, and <I>ymax</I> for color-density plots of matrices. Unlike <I><a href="#findDensityMapBounds">M_findDensityMapBounds</a></I>, no adjustment of the <I>x</I> and <I>y</I> ranges is made. 
<P>The user will rarely call this function himself. It is internally called by all functions of the <I><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a></I> and <I><a href="#zAutoDensityMap">MF_zAutoDensityMap</a></I> families.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>,&nbsp;&nbsp; <a href="#zAutoDensityMap">MF_zAutoDensityMap</a>,&nbsp;&nbsp; <a href="#chap15">chapter&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setElement"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_setElement</b></font>
</td><td width="33%"><font size="+1"><b>MD_setElement</b></font></td>
<td><font size="+1"><b>ME_setElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_setElement</b></font></td>
<td width="33%"><font size="+1"><b>MCD_setElement</b></font></td>
<td><font size="+1"><b>MCE_setElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_setElement</b></font></td><td width="20%"><font size="+1"><b>MBI_setElement</b></font></td><td width="20%"><font size="+1"><b>MSI_setElement</b></font></td><td width="20%"><font size="+1"><b>MLI_setElement</b></font></td><td><font size="+1"><b>MQI_setElement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_setElement</b></font></td><td width="20%"><font size="+1"><b>MUB_setElement</b></font></td><td width="20%"><font size="+1"><b>MUS_setElement</b></font></td><td width="20%"><font size="+1"><b>MUL_setElement</b></font></td><td><font size="+1"><b>MUQ_setElement</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Write access to a matrix element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void&nbsp;MF_setElement( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::setElement( const&nbsp;unsigned&nbsp;m, const&nbsp;unsigned&nbsp;n, const&nbsp;T&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_setElement( MA:fMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>void&nbsp;cudaMF_setElement( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n, float&nbsp;C&nbsp;);
<BR>void&nbsp;cusdMF_setElement( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, unsigned&nbsp;m, unsigned&nbsp;n, float&nbsp;*d_C&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>procedure cudaMF_setElement( d_MA:fMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize; C:Single&nbsp;);<BR>
<BR>procedure cusdMF_setElement( d_MA:fMatrix; ht,&nbsp;len,&nbsp;m, n:UIntSize; d_C:PSingle&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The element MA<sub>m,n</sub> is overwritten with the value C.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#getElement">MF_getElement</a>,&nbsp;&nbsp; <a href="#Pelement">MF_Pelement</a>,&nbsp;&nbsp; <a href="#chap2">chapter&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setLinfitNeglect"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setLinfitNeglect</b></font>
</td><td width="33%"><font size="+1"><b>VD_setLinfitNeglect</b></font></td>
<td><font size="+1"><b>VE_setLinfitNeglect</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>define significance threshold for data fitting to linear models</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_setLinfitNeglect( float&nbsp;Thresh&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::setLinfitNeglect( const&nbsp;T&amp;&nbsp;Thresh&nbsp;);<BR>
void matrix&lt;T&gt;::setLinfitNeglect( const&nbsp;T&amp;&nbsp;Thresh&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_setLinfitNeglect( Thresh:Single&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>As described in connection with <I><a href="#linfit">VF_linfit</a></I>, this function allows to define a significance threshold below which fit parameters <I>a<sub>i</sub></I> are neglected. The default of this threshold is 4*FLT_EPSILON,&nbsp;&nbsp;8*DLB_EPSILON,&nbsp;&nbsp;or 16*LDBL_EPSILON. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#getLinfitNeglect">VF_getLinfitNeglect</a>,&nbsp;&nbsp; <a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="#chap13">chapter&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setNonlinfitOptions"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setNonlinfitOptions</b></font>
</td><td width="33%"><font size="+1"><b>VD_setNonlinfitOptions</b></font></td>
<td><font size="+1"><b>VE_setNonlinfitOptions</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>set options for the nonlinear fitting routines</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_setNonlinfitOptions( VF_NONLINFITOPTIONS *Options&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_setNonlinfitOptions( Options: VF_NONLINFITOPTIONS&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The nonlinear fitting routines like <I><a href="#nonlinfit">VF_nonlinfit</a></I> offer the user a lot of different options, packed into a structure <I><a href="#chap13_3NONLINFITOPTIONS">VF_NONLINFITOPTIONS</a></I> (<I>VD_NONLINFITOPTIONS</I> and <I>VE_NONLINFITOPTIONS</I> for the higher accuracy data-types). These options may be set by the function <I>V_setNonlinfitOptions</I>. To retrieve current settings, use <I><a href="#getNonlinfitOptions">V_getNonlinfitOptions</a></I>. The options set with this function are valid for <B>all</B> fitting-functions of the same accuracy level. Thus, e.g., <I>VD_setNonlinfitOptions</I> sets the options governing <I><a href="#nonlinfit">VD_nonlinfit</a></I>,&nbsp;&nbsp;<I><a href="#multiNonlinfit">VD_multiNonlinfit</a></I>,&nbsp;&nbsp;<I><a href="#Mnonlinfit">MD_nonlinfit</a></I>,&nbsp;&nbsp;<I><a href="#MmultiNonlinfit">MD_multiNonlinfit</a></I> and their siblings with data-weighting (&quot;wW&quot; versions).</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">VD_NONLINFITOPTIONS Opt;
<BR>VD_getNonlinfitOptions( &amp;Opt&nbsp;);
<BR>Opt.FigureOfMerit = 0; // choose least-square fitting
<BR>Opt.AbsTolChi = 1.e-6;
<BR>Opt.FracTolChi = 1.e-3; // make the fit fast, but not very accurate
<BR>Opt.LevelOfMethod = 3; // choose alternating Levenberg-Marquardt and Downhill-Simplex runs
<BR>VD_setNonlinfitOptions( &amp;Opt&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>Example Pascal/Delphi</td><td><font face="courier new">Opt: VD_NONLINFITOPTIONS;
<BR>VD_getNonlinfitOptions(Opt&nbsp;);
<BR>Opt.FigureOfMerit := 0; (*&nbsp;choose least-square fitting *)
<BR>Opt.AbsTolChi := 1.e-6;
<BR>Opt.FracTolChi := 1.e-3; (*&nbsp;make the fit fast, but not very accurate *)
<BR>Opt.LevelOfMethod := 3; (*&nbsp;choose alternating Levenberg-Marquardt and Downhill-Simplex runs *)
<BR>VD_setNonlinfitOptions(Opt&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13_3">chapter&nbsp;13.3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setWriteFormat"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_setWriteFormat</b></font>
</td><td width="33%"><font size="+1"><b>MD_setWriteFormat</b></font></td>
<td><font size="+1"><b>ME_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_setWriteFormat</b></font></td>
<td width="33%"><font size="+1"><b>MCD_setWriteFormat</b></font></td>
<td><font size="+1"><b>MCE_setWriteFormat</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Definition of the format to be used by <I><a href="#write">M?_write</a></I>: C/C++ only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_setWriteFormat( char *FormatString&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::setWriteFormat( char *FormatString&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td>This function does not exist.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions are identical to the <I><a href="FUNCREF.TXT#setWriteformat">VF_setWriteFormat</a></I> family. 
<BR>The number format with which the <I><a href="#write">M?_write</a></I> functions print matrix elements into a stream can be adjusted by means of this function. When defining a write format, one should always be aware of the restrictions imposed by the read functions (not all formats you can write will be read correcly, see <I><a href="#read">MF_read</a></I>).
<P><I>MF_setWriteFormat</I> should not be used for the definition of whitespace between the columns. This is the task of <I><a href="#setWriteSeparate">MF_setWriteSeparate</a></I>.
<P>For details about the formats used for each of the various data types, please refer to the following table. The last column of this table gives the maximum length of the format string.
<BR>&nbsp;<table border width="100%">
<tr valign="top"><td>Version</td><td>Standard Format</td><td>Alternative Example</td><td>max. length</td></tr>
<tr valign="top"><td><i>MF_</i></td><td>&quot;% 11.8e&quot;</td><td>&quot;% 8.4f&quot;</td><td>16</td></tr>
<tr valign="top"><td><i>MD_</i></td><td>&quot;% 19.16le&quot;</td><td>&quot;% 16.8lf&quot;</td><td>16</td></tr>
<tr valign="top"><td><i>ME_</i></td><td>&quot;% 22.19Le&quot;</td><td>&quot;% 22.19LG&quot;</td><td>16</td></tr>
<tr valign="top"><td><i>MCF_</i></td><td>&quot;% 11.8e, % 11.8e&quot;</td><td>&quot;{% 8.4f, % 8.4f}&quot;</td><td>32</td></tr>
<tr valign="top"><td><i>MCD_</i></td><td>&quot;% 19.16le, % 19.16le&quot;</td><td>&quot;{% 19.16lE % 19.16lE}&quot;</td><td>32</td></tr>
<tr valign="top"><td><i>MCE_</i></td><td>&quot;% 22.19Le, % 22.19Le&quot;</td><td>&quot;{% 22.19Lg % 22.19Lg}&quot;</td><td>32</td></tr>
</table>
</td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Format strings longer than the maximum length specified in the above table lead to a program abort with the error message &quot;Invalid Parameter(s)&quot;.
<BR>The contents of the format string is not checked. So you have to be very careful to specify a format which is valid for the respective data type.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setWriteSeparate">MF_setWriteSeparate</a>,&nbsp;&nbsp; <a href="#write">MF_write</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#write">VF_write</a>,&nbsp;&nbsp; <a href="#read">MF_read</a>,&nbsp;&nbsp; <a href="#chap14">chapter&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setWriteSeparate"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_setWriteSeparate</b></font>
</td><td width="33%"><font size="+1"><b>MD_setWriteSeparate</b></font></td>
<td><font size="+1"><b>ME_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_setWriteSeparate</b></font></td>
<td width="33%"><font size="+1"><b>MCD_setWriteSeparate</b></font></td>
<td><font size="+1"><b>MCE_setWriteSeparate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>define a character string used to separate columns in the <a href="#write">M?_write</a> functions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_setWriteSeparate( char *SepString&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::setWriteSeparate( char *SepString&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_setWriteSeparate( SepString:PChar&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions are identical to the functions of the <I><a href="FUNCREF.HTM#setNWriteSeparate">VF_setNWriteSeparate</a></I> family. They are used to define the character string to be inserted between the columns of a table written by <I><a href="#write">MF_write</a></I>. <I>MF_setWriteSeparate</I> does not influence the end of each line which is always a line-feed character ('\n' for C/C++ and #13 for Pascal/Delphi).
<BR>SepString may contain up to twelve characters. The default setting is a single tab character (&quot;\t&quot; for C/C++ and #9 for Pascal/Delphi).
</td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>In the case of SepString longer than twelve characters, the program is aborted with the error message &quot;Invalid Parameter(s)&quot;.
<BR>The contents of SepString is not checked.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setWriteFormat">MF_setWriteFormat</a>,&nbsp;&nbsp; <a href="#write">MF_write</a>,&nbsp;&nbsp; <a href="#read">MF_read</a>,&nbsp;&nbsp; <a href="#chap14">chapter&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="solve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_solve</b></font>
</td><td width="33%"><font size="+1"><b>MD_solve</b></font></td>
<td><font size="+1"><b>ME_solve</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_solve</b></font></td>
<td width="33%"><font size="+1"><b>MCD_solve</b></font></td>
<td><font size="+1"><b>MCE_solve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>solve a linear system</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_solve( fVector&nbsp;X, fMatrix&nbsp;MA, fVector&nbsp;B, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::solve( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;vector&lt;T&gt;&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_solve( X:fVector; MA:fMatrix; B:fVector; len:UIntSize&nbsp;): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function solves the system MA *&nbsp;X = B of simultaneous linear equations, using LU decomposition. It works well in all cases where there is one unique solution. If successful, it returns FALSE (0).
<BR>If, on the other hand, the system is ill-determined, which happens in all cases where one or more of the equations are linear combinations of other equations of the same system, the resulting matrix becomes singular and the function fails with an error message, returning TRUE (1).
<BR>To avoid outright failure in an application where ill-determined matrices might occur, you should use
<I><a href="#LUDsetEdit">MF_LUDsetEdit</a></I> to define a minimum &quot;pivot&quot; for the LU decomposition process. If you do so, <I>MF_solve</I> will always yield a &quot;more or less&quot; meaningful solution and returns always FALSE (0). Then, a call to <I><a href="#LUDresult">MF_LUDresult</a></I> will tell you if pivot-editing has actually been necessary.
<BR>Alternatively, you might switch to <I><a href="#safeSolve">MF_safeSolve</a></I> or <I><a href="#solveBySVD">MF_solveBySVD</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if the linear system could by solved; TRUE (1) in the case of a singular system without pivot-editing</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#LUdecompose">MF_LUdecompose</a>,&nbsp;&nbsp; <a href="#inv">MF_inv</a>,&nbsp;&nbsp; <a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="solveBySVD"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_solveBySVD</b></font>
</td><td width="33%"><font size="+1"><b>MD_solveBySVD</b></font></td>
<td><font size="+1"><b>ME_solveBySVD</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>solve a possibly over- or underdetermined linear system by singular value decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_solveBySVD( fVector&nbsp;X, fMatrix&nbsp;MA, fVector&nbsp;B, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::solveBySVD( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;vector&lt;T&gt;&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_solveBySVD( X:fVector; MA:fMatrix; B:fVector; htA, lenA:UIntSize&nbsp;): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The system MA *&nbsp;X = B of simultaneous linear equations is solved for X, using Singular Value Decomposition. Here, underdetermined systems do not lead to an error. Rather, you get one particular solution out of the solution space. If you have more equations than unknowns, i.e., in the case of an overdetermined system, the solution vector contains a least-square &quot;compromise&quot; between the equations.
<BR>The function should always return FALSE (0). Only in the very rare case of SVD failure, TRUE (1) is returned. The length of the desired solution vector, sizX must be equal to the width of the input matrix, lenA, whereas the length of the right-hand-side vector, sizB must be equal to htA.
<P>The threshold for singular-value editing should be set using <I><a href="#SVDsetEdit">MF_SVDsetEdit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>usually FALSE (0); only in the very rare case of failure, TRUE (1)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#SVdecompose">MF_SVdecompose</a>,&nbsp;&nbsp; <a href="#solve">MF_solve</a>,&nbsp;&nbsp; <a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="spectrum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_spectrum</b></font>
</td><td width="33%"><font size="+1"><b>MD_spectrum</b></font></td>
<td><font size="+1"><b>ME_spectrum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>spatial frequency spectrum</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_spectrum( fMatrix&nbsp;Spec, ui&nbsp;htSpec, ui&nbsp;lenSpec, fMatrix&nbsp;X, ui&nbsp;htX, ui&nbsp;lenX, fMatrix&nbsp;Win&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::sprectrum( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MX, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MWin&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_spectrum( MSpec:fMatrix; htSpec,&nbsp;lenSpec:UIntSize; MX:fMatrix; htX,&nbsp;lenX:UIntSize; MWin:fMatrix&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int&nbsp;cudaMF_spectrum( fMatrix&nbsp;d_Spec, ui&nbsp;htSpec, ui&nbsp;lenSpec, fMatrix&nbsp;d_X, ui&nbsp;htX, ui&nbsp;lenX, fMatrix&nbsp;d_Win&nbsp;);
<BR>void MFcu_spectrum( fMatrix&nbsp;h_Spec, ui&nbsp;htSpec, ui&nbsp;lenSpec, fMatrix&nbsp;h_X, ui&nbsp;htX, ui&nbsp;lenX, fMatrix&nbsp;h_Win&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_spectrum( d_MSpec:fMatrix; htSpec,&nbsp;lenSpec:UIntSize; d_MX:fMatrix; htX,&nbsp;lenX:UIntSize; d_MWin:fMatrix&nbsp;):&nbsp;IntBool;<BR>
<BR>procedure MFcu_spectrum( h_MSpec:fMatrix; htSpec,&nbsp;lenSpec:UIntSize; h_MX:fMatrix; htX,&nbsp;lenX:UIntSize; h_MWin:fMatrix&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The data set MX is analyzed for the mean square amplitude of its spatial frequency spectrum. The result is stored in MSpc.
<BR>Internally, the spectrum is calculated by dividing the input data into overlapping segments, similarly to the one-dimensional case described for <I><a href="FUNCREF.HTM#spectrum">VF_spectrum</a></I>.
<BR>MWin is a window that is applied to the data segments. Three functions are available that give suitable
Windows: <I><a href="#Welch">MF_Welch</a></I>,&nbsp;&nbsp; <I><a href="#Parzen">MF_Parzen</a></I>, and <I><a href="#Hann">MF_Hann</a></I>. A square window is available by setting all matrix elements equal to 1.0 (<font face="courier new">MF_equC( MWin, htWin, lenWin, 1.0&nbsp;);</font>&nbsp;), but this is not recommended.
<BR>htSpec and lenSpec must be integer powers of 2.
<BR>MSpec has [htSpec+1][lenSpec+1] elements (!), and htX &gt;= n*htSpec, lenX &gt;= n*lenSpec, htWin = 2*htSpec, lenWin = 2*lenSpec.
<P>About special versions with the prefixes <i>MFs_</i> and <I>MFl_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8 of HANDBOOK.HTM.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either htSpec or lenSpec is not a power of 2, <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I> (on which <I>MF_spectrum</I> relies) complains &quot;Size must be an integer power of 2&quot; and the program is aborted. If MSpc overwrites MX or MWin, an error message &quot;Vectors/matrices must not be identical&quot; is generated and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">MF_convolve</a>,&nbsp;&nbsp; <a href="#autocorr">MF_autocorr</a>,&nbsp;&nbsp; <a href="#xcorr">MF_xcorr</a>,&nbsp;&nbsp; <a href="#filter">MF_filter</a>,&nbsp;&nbsp; <a href="#chap12">chapter&nbsp;12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="sqrt"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFsym_sqrt</b></font>
</td><td width="33%"><font size="+1"><b>MDsym_sqrt</b></font></td>
<td><font size="+1"><b>MEsym_sqrt</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square root of a symmetric, positive definite matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MFsym_sqrt( fMatrix&nbsp;MB, fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::sqrt( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MFsym_sqrt( MB,&nbsp;MA:fMatrix; len:UIntSize&nbsp;):IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The square-root of a symmetric, positive definite matrix is calculated, so that MB *&nbsp;MB = MA is satisfied. Please note that non-symmetric matrices or matrices which are not positive definite may or may not have existing square-roots, too. The present algorithm, however, is restricted to the most simple case where a square-root always exists. It uses eigenvalues and eigenvectors and fails whenever a negative eigenvalue is encountered, indicating an input matrix which is not positive definite. In the latter case, an error message is displayed and the result is calculated with zero substituted for the negative eigenvalue. This result may still be useful, namely if the negative eigenvalue is very small.  
<P>A return value of FALSE or 0 indicates success, whereas a non-zero return value indicates that the input matrix did not meet the condition of being symmetric and positive definite.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if the matrix square-root could be calculated; otherwise TRUE (1)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#eigenvalues">MF_eigenvalues</a>,&nbsp;&nbsp; <a href="#chap11">chapter&nbsp;11</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="store"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_store</b></font>
</td><td width="33%"><font size="+1"><b>MD_store</b></font></td>
<td><font size="+1"><b>ME_store</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_store</b></font></td>
<td width="33%"><font size="+1"><b>MCD_store</b></font></td>
<td><font size="+1"><b>MCE_store</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_store</b></font></td><td width="20%"><font size="+1"><b>MBI_store</b></font></td><td width="20%"><font size="+1"><b>MSI_store</b></font></td><td width="20%"><font size="+1"><b>MLI_store</b></font></td><td><font size="+1"><b>MQI_store</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_store</b></font></td><td width="20%"><font size="+1"><b>MUB_store</b></font></td><td width="20%"><font size="+1"><b>MUS_store</b></font></td><td width="20%"><font size="+1"><b>MUL_store</b></font></td><td><font size="+1"><b>MUQ_store</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store a matrix in binary format into a stream</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_store( FILE *stream, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMF_store_buf( FILE *stream, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;h_Wk&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_store( var&nbsp;Stream:File; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMF_store_buf( var&nbsp;Stream:File; d_MA:fMatrix; ht,&nbsp;len:UIntSize; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_store( FILE *stream, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::store( FILE *stream&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_store( var Stream:FILE; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA of ht*len elements is written to <I>stream</I> in binary format. The stream must be already open for binary write operations.
<P>CUDA versions only: <i>cudaM?_store_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as d_MA, i.e. ht*len. By avoiding the need of <i>cudaM?_store</i> to allocate its own buffer memory, <i>cudaM?_store_buf</i> is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#recall">MF_recall</a>,&nbsp;&nbsp; <a href="#chap14">chapter&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="subM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_subM</b></font>
</td><td width="33%"><font size="+1"><b>MD_subM</b></font></td>
<td><font size="+1"><b>ME_subM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFs_subM</b></font></td>
<td width="33%"><font size="+1"><b>MDs_subM</b></font></td>
<td><font size="+1"><b>MEs_subM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_subM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_subM</b></font></td>
<td><font size="+1"><b>MCE_subM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise subtraction of two matrices</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_subM( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MFs_subM( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::subM( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB);<BR>
void matrix&lt;T&gt;::s_subM( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_subM( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<BR>
procedure MFs_subM( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_subM( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMFs_subM( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMFs_subM( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_subM( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFs_subM( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_subM( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMFs_subM( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMFs_subM( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MF_subM( h_MC, h_MA, h_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);
<BR>procedure MFs_subM( h_MC, h_MA, h_MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: MC<sub>ij</sub> = MA<sub>ij</sub> - MB<sub>ij</sub>
<BR>scaled version: MC<sub>ij</sub> = C *&nbsp;(MA<sub>ij</sub> - MB<sub>ij</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#subMT">MF_subMT</a>,&nbsp;&nbsp; <a href="#addM">MF_addM</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="subMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_subMT</b></font>
</td><td width="33%"><font size="+1"><b>MD_subMT</b></font></td>
<td><font size="+1"><b>ME_subMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFs_subMT</b></font></td>
<td width="33%"><font size="+1"><b>MDs_subMT</b></font></td>
<td><font size="+1"><b>MEs_subMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_subMT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_subMT</b></font></td>
<td><font size="+1"><b>MCE_subMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract the transpose of one matrix from another matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_subMT( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MFs_subMT( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::subMT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB);<BR>
void matrix&lt;T&gt;::s_subMT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_subMT( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<BR>
procedure MFs_subMT( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_subMT( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMFs_subMT( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMFs_subMT( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_subMT( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFs_subMT( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_subMT( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMFs_subMT( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMFs_subMT( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MF_subMT( h_MC, h_MA, h_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);
<BR>procedure MFs_subMT( h_MC, h_MA, h_MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: MC<sub>i,j</sub> = MA<sub>i,j</sub> - MB<sup>T</sup><sub>j,i</sub>
<BR>scaled version: MC<sub>i,j</sub> = C *&nbsp;(MA<sub>i,j</sub> - MB<sup>T</sup><sub>j,i</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#subM">MF_subM</a>,&nbsp;&nbsp; <a href="#addM">MF_addM</a>,&nbsp;&nbsp; <a href="subrMT">MF_subrMT</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="subrMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_subrMT</b></font>
</td><td width="33%"><font size="+1"><b>MD_subrMT</b></font></td>
<td><font size="+1"><b>ME_subrMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFs_subrMT</b></font></td>
<td width="33%"><font size="+1"><b>MDs_subrMT</b></font></td>
<td><font size="+1"><b>MEs_subrMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_subrMT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_subrMT</b></font></td>
<td><font size="+1"><b>MCE_subrMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: subtract one matrix from the transpose of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_subrMT( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);<BR>
void MFs_subrMT( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::subrMT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB);<BR>
void matrix&lt;T&gt;::s_subrMT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA,  const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB, const&nbsp;T&amp;&nbsp;C);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_subrMT( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);<BR>
procedure MFs_subrMT( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_subrMT( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMFs_subrMT( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);
<BR>int cusdMFs_subrMT( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;*d_C&nbsp;);
<BR>void MFcu_subrMT( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFs_subrMT( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len, float&nbsp;C&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_subrMT( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMFs_subrMT( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;):&nbsp;IntBool;
<BR>function cusdMFs_subrMT( d_MC, d_MA, d_MB:fMatrix; ht,&nbsp;len:UIntSize; d_C:PSingle&nbsp;):&nbsp;IntBool;
<BR>procedure MF_subrMT( h_MC, h_MA, h_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);
<BR>procedure MFs_subrMT( h_MC, h_MA, h_MB:fMatrix; ht,&nbsp;len:UIntSize; C:Single&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: MC<sub>i,j</sub> = MB<sup>T</sup><sub>j,i</sub> - MA<sub>i,j</sub>
<BR>scaled version: MC<sub>i,j</sub> = C *&nbsp;(MB<sup>T</sup><sub>j,i</sub> - MA<sub>i,j</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#addM">MF_addM</a>,&nbsp;&nbsp; <a href="subMT">MF_subMT</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="submatrix"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_submatrix</b></font>
</td><td width="33%"><font size="+1"><b>MD_submatrix</b></font></td>
<td><font size="+1"><b>ME_submatrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_submatrix</b></font></td>
<td width="33%"><font size="+1"><b>MCD_submatrix</b></font></td>
<td><font size="+1"><b>MCE_submatrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_submatrix</b></font></td><td width="20%"><font size="+1"><b>MBI_submatrix</b></font></td><td width="20%"><font size="+1"><b>MSI_submatrix</b></font></td><td width="20%"><font size="+1"><b>MLI_submatrix</b></font></td><td><font size="+1"><b>MQI_submatrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_submatrix</b></font></td><td width="20%"><font size="+1"><b>MUB_submatrix</b></font></td><td width="20%"><font size="+1"><b>MUS_submatrix</b></font></td><td width="20%"><font size="+1"><b>MUL_submatrix</b></font></td><td><font size="+1"><b>MUQ_submatrix</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>extract a submatrix from a (larger) matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_submatrix( fMatrix&nbsp;MSub, ui&nbsp;subHt, ui&nbsp;subLen, fMatrix&nbsp;MSrce, ui&nbsp;srceHt, ui&nbsp;srceLen, ui&nbsp;firstRowInCol, ui&nbsp;sampInCol, ui&nbsp;firstColInRow, ui&nbsp;sampInRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::submatrix( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MSrce, const&nbsp;ui&nbsp;firstRowInCol, const&nbsp;ui&nbsp;sampInCol, const&nbsp;ui&nbsp;firstColInRow, const&nbsp;ui&nbsp;sampInRow&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_submatrix( MSub:fMatrix; subHt,&nbsp;subLen:UIntSize; MSrce:fMatrix; srceHt,&nbsp;srceLen:UIntSize; firstRowInCol,&nbsp;sampInCol,&nbsp;firstColInRow,&nbsp;sampInRow:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_submatrix( fMatrix&nbsp;d_MSub, ui&nbsp;subHt, ui&nbsp;subLen, fMatrix&nbsp;d_MSrce, ui&nbsp;srceHt, ui&nbsp;srceLen, ui&nbsp;firstRowInCol, ui&nbsp;sampInCol, ui&nbsp;firstColInRow, ui&nbsp;sampInRow&nbsp;);
<BR>void MFcu_submatrix( fMatrix&nbsp;h_MSub, ui&nbsp;subHt, ui&nbsp;subLen, fMatrix&nbsp;h_MSrce, ui&nbsp;srceHt, ui&nbsp;srceLen, ui&nbsp;firstRowInCol, ui&nbsp;sampInCol, ui&nbsp;firstColInRow, ui&nbsp;sampInRow&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_submatrix( d_MSub:fMatrix; subHt,&nbsp;subLen:UIntSize; d_MSrce:fMatrix; srceHt,&nbsp;srceLen:UIntSize; firstRowInCol,&nbsp;sampInCol,&nbsp;firstColInRow,&nbsp;sampInRow:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_submatrix( h_MSub:fMatrix; subHt,&nbsp;subLen:UIntSize; h_MSrce:fMatrix; srceHt,&nbsp;srceLen:UIntSize; firstRowInCol,&nbsp;sampInCol&nbsp; firstColInRow,&nbsp;sampInRow:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MSub<sub>i, j</sub> = MSrce<sub>i*sampInCol+firstRowInCol, j*sampInRow+firstColInRow</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="FUNCREF.HTM#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#Row_extract">MF_Row_extract</a>,&nbsp;&nbsp; <a href="#submatrix_equM">MF_submatrix_equM</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="submatrix_equM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_submatrix_equM</b></font>
</td><td width="33%"><font size="+1"><b>MD_submatrix_equM</b></font></td>
<td><font size="+1"><b>ME_submatrix_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_submatrix_equM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_submatrix_equM</b></font></td>
<td><font size="+1"><b>MCE_submatrix_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_submatrix_equM</b></font></td><td width="20%"><font size="+1"><b>MBI_submatrix_equM</b></font></td><td width="20%"><font size="+1"><b>MSI_submatrix_equM</b></font></td><td width="20%"><font size="+1"><b>MLI_submatrix_equM</b></font></td><td><font size="+1"><b>MQI_submatrix_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_submatrix_equM</b></font></td><td width="20%"><font size="+1"><b>MUB_submatrix_equM</b></font></td><td width="20%"><font size="+1"><b>MUS_submatrix_equM</b></font></td><td width="20%"><font size="+1"><b>MUL_submatrix_equM</b></font></td><td><font size="+1"><b>MUQ_submatrix_equM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>distribute the elements of a matrix to a submatrix of another (larger) matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_submatrix_equM( fMatrix&nbsp;MDest, unsigned destHt, unsigned destLen, ui&nbsp;firstRowInCol, ui&nbsp;sampInCol, ui&nbsp;firstColInRow, ui&nbsp;sampInRow, fMatrix&nbsp;MSrce, ui&nbsp;srceHt, ui&nbsp;srceLen&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::submatrix_equM( const&nbsp;ui&nbsp;firstRowInCol, const&nbsp;ui&nbsp;sampInCol, const&nbsp;ui&nbsp;firstColInRow, const&nbsp;ui&nbsp;sampInRow, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MSrce &nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_submatrix_equM( MDest:fMatrix; destHt,&nbsp;destLen, firstRowInCol,&nbsp;sampInCol, firstColInRow,&nbsp;sampInRow:UIntSize; MSrce:fMatrix; srceHt,&nbsp;srceLen:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_submatrix_equM( fMatrix&nbsp;d_MDest, unsigned&nbsp;destHt, unsigned&nbsp;destLen, ui&nbsp;firstRowInCol, ui&nbsp;sampInCol, ui&nbsp;firstColInRow, ui&nbsp;sampInRow, fMatrix&nbsp;d_MSrce, ui&nbsp;srceHt, ui&nbsp;srceLen&nbsp;);
<BR>void MFcu_submatrix_equM( fMatrix&nbsp;h_MDest, unsigned&nbsp;destHt, unsigned&nbsp;destLen, ui&nbsp;firstRowInCol, ui&nbsp;sampInCol, ui&nbsp;firstColInRow, ui&nbsp;sampInRow, fMatrix&nbsp;h_MSrce, ui&nbsp;srceHt, ui&nbsp;srceLen&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_submatrix_equM( d_MDest:fMatrix; destHt,&nbsp;destLen, firstRowInCol,&nbsp;sampInCol, firstColInRow,&nbsp;sampInRow:UIntSize; d_MSrce:fMatrix; srceHt,&nbsp;srceLen:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_submatrix_equM( h_MDest:fMatrix; destHt,&nbsp;destLen, firstRowInCol,&nbsp;sampInCol, firstColInRow,&nbsp;sampInRow:UIntSize; h_MSrce:fMatrix; srceHt,&nbsp;srceLen:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MDest<sub>i*sampInCol+firstRowInCol, j*sampInRow+firstColInRow</sub> = MSrce<sub>i, j</sub>
<BR>This function does the inverse of <I><a href="#submatrix">MF_submatrix</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="FUNCREF.HTM#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#Row_equV">MF_Row_equV</a>,&nbsp;&nbsp; <a href="#submatrix">MF_submatrix</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="SVdecompose"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_SVdecompose</b></font>
</td><td width="33%"><font size="+1"><b>MD_SVdecompose</b></font></td>
<td><font size="+1"><b>ME_SVdecompose</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Singular Value Decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_SVdecompose( fMatrix&nbsp;U, fMatrix&nbsp;V, fVector&nbsp;W, fMatrix&nbsp;MA, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
int matrix&lt;T&gt;::SVdecompose( matrix&lt;T&gt; MV,  vector&lt;T&gt; W, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);<BR>
int matrix&lt;T&gt;::SVdecompose( matrix&lt;T&gt;*&nbsp;MV,  vector&lt;T&gt;*&nbsp;W, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_SVdecompose( MU, MV:fMatrix; W:fVector; MA:fMatrix; htA, lenA:UIntSize&nbsp;): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA of dimensions [ht, len] is decomposed into a product<BR>
MA = MU *&nbsp;MW *&nbsp;MV<sup>T</sup>,<BR>
where MU has the dimensions [max(ht,len), len]. MW is a diagonal matrix with all elements positive or zero. Actually, only the diagonal of this matrix is stored in the vector W of size [len], MV, finally, is a square matrix [len, len]. Both MU and MV are orthogonal: 
<BR>MU<sup>T</sup> *&nbsp;MU = MV<sup>T</sup> *&nbsp;MV = (1).
Due to these orthogonality relations, the solution of a linear system MA *&nbsp;X = B is straightforward, once MA has been singular-value decomposed:
<BR>X = MV *&nbsp;W<sup>-1</sup> *&nbsp;MU<sup>T</sup>
<BR>(This equation must be evaluated from right to left.) As MU and MV are orthogonal, only W must explicitly be inverted. This, however, is easy, as W is diagonal, and the inverse of a diagonal matrix consists of the inverse of the diagonal elements. This is the important point which makes SVD so useful, because it provides both a diagnose and a cure for singularities. If any element of W is very small compared to the largest element, this corresponds to a singularity (at least in the numerical sense, where dividing by extremely small numbers is almost as bad as dividing by zero). A singularity means that the underlying linear system is under-determined. This, in turn, means that one can arbitrarily choose one particular solution. Specifically, one may choose W<sup>-1</sup><sub>ii</sub> = 0 for very small W<sub>ii</sub>, which is one of the rare cases where it makes sense to set the result of a division by (near-)zero to zero instead of infinity. This reduction of the dimension by &quot;Singular Value editing&quot; is the crucial point in all functions relying on SVD, like <I><a href="#SVsolve">MF_SVsolve</a></I>,&nbsp;&nbsp;<I><a href="#safeSolve">MF_safeSolve</a></I>),&nbsp;&nbsp;<I><a href="#linfit">VF_linfit</a></I> and others. The editing threshold is set by <I><a href="#SVDsetEdit">MF_SVDsetEdit</a></I>.
<P>The singular values are stored in W in arbitrary order. For some applications, like visual inspection of the singular values, dimension reduction, calculation of the rank of a matrix, etc., it is desirable to bring the singular values into descending order, re-ordering also the right and left singular vectors (stored in the matrices MU and MV) accordingly. This is done by calling <I><a href="#SVsort">MF_SVsort</a></I>.
<P>If you compare results of <I>MF_SVdecompose</I> with SVD-routines of other vendors, please note the following points:
<OL><LI><I>MF_SVdecompose</I> itself does not perform a dimension reduction (replacement of small singular values by 0), but leaves this step to following functions or to manual inspection by the user. 
<LI>Singular values can be permutated, if the same permutation is also applied to the corresponding columns of both MU and MV. Often, this property in of SVD is exploited to bring the singular values into a certain (for example, into descending) order. As the price for this increased beauty is an increased work-load, <I>MF_SVdecompose</I> itself keeps the singular values in arbitrary order. Only if really needed, the task of sorting may be performed by calling the separate function <I><a href="#SVsort">MF_SVsort</a></I> after <i>MF_SVdecompose</i>, as described above.
<LI>The sign of a singular value may be exchanged if the corresponding column of MV is also multiplied by -1. <I>MF_SVdecompose</I> uses this property to make all non-vanishing singular values positive.</OL></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Verifying SVD results</td><td>The following routine demonstrates SV decomposition and the verification of its results.
<P><font face="courier new">#include &lt;VDstd.h&gt;<br>
#include &lt;MDstd.h&gt;<br>
#include &lt;conio.h&gt;<br>
void SVDtest( void )<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned ht=386, len=52,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// choose any values<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxhtlen, sizeA, sizeV;<br>
&nbsp;&nbsp;&nbsp;&nbsp;dMatrix MA, MU, MV, MOne, MA2, MUV2, MDiffA, MDiffOne;<br>
&nbsp;&nbsp;&nbsp;&nbsp;dVector&nbsp;W;<br>
&nbsp;&nbsp;&nbsp;&nbsp;double  err;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;maxhtlen = (ht &gt;= len ? ht : len);<br>
&nbsp;&nbsp;&nbsp;&nbsp;sizeA = ht*len;<br>
&nbsp;&nbsp;&nbsp;&nbsp;sizeV = len*len;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;MA  = MD_matrix( ht, len );&nbsp;&nbsp;&nbsp;// input matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;MU  = MD_matrix( maxhtlen, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;MV  = MD_matrix( len, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;W   = VD_vector( len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;MOne = MD_matrix( len, len );&nbsp;&nbsp; // unity matrix for comparison<br>
&nbsp;&nbsp;&nbsp;&nbsp;MD_equ1( MOne, len );<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;MA2  = MD_matrix( maxhtlen, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// will be filled with MU*W*MVT to compare with input matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// leading dimension maxhtlen is needed for under-determined matrices<br>
&nbsp;&nbsp;&nbsp;&nbsp;MUV2 = MD_matrix( len, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// will be filled with MUT*MU, MVT*MV, MV*MVT for comparison with MOne <br>
&nbsp;&nbsp;&nbsp;&nbsp;MDiffA = MD_matrix( ht, len );&nbsp;&nbsp;// will hold temporary result<br>
&nbsp;&nbsp;&nbsp;&nbsp;MDiffOne = MD_matrix( len, len );&nbsp;&nbsp;// will hold temporary result<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;MD_random( MA, ht,&nbsp;len,&nbsp;1, -1., +1. );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fill MA with random numbers between -1 and +1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// alternatively generate or read in any other test matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;MD_SVdecompose( MU, MV, W, MA, ht, len );<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp; check if MA = MU*W*MVT, evaluating from right to left : */<br>
&nbsp;&nbsp;&nbsp;&nbsp;MDdia_mulMT( MUV2, W, MV, len, len );   // use MUV2 to store W *&nbsp;MVT<br>
&nbsp;&nbsp;&nbsp;&nbsp;MD_mulM( MA2, MU, MUV2, maxhtlen, len, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;MD_subM( MDiffA, MA, MA2, ht, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// for under-determined matrices, just ignore the rows from ht to maxhtlen-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;err = VD_absmax( MDiffA[0], sizeA ); <br>
&nbsp;&nbsp;&nbsp;&nbsp;printf( "SVDtest: check the SVD routine of OptiVec\n\n"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"In the following tests in double precision,\n"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"errors of up to a few times 1.e-14 are okay\n"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"for matrices on the order of 100x100 to 1000x1000 elements:\n\n"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"max. error of matrix reconstruction MA = MU*W*MVT: %lg", err );<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;check if MU is orthogonal, i.e. MUT*MU = (1):  */<br>
&nbsp;&nbsp;&nbsp;&nbsp;MD_TmulM( MUV2, MU, MU, maxhtlen, len, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;MD_subM( MDiffOne, MUV2, MOne, len, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;err = VD_absmax( MDiffOne[0], sizeV ); <br>
&nbsp;&nbsp;&nbsp;&nbsp;printf( "\nmax. error of MUT*MU = (1): %lg", err );<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;check if MV is orthogonal, i.e. MVT*MV = (1):  */<br>
&nbsp;&nbsp;&nbsp;&nbsp;MD_TmulM( MUV2, MV, MV, len, len, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;MD_subM( MDiffOne, MUV2, MOne, len, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;err = VD_absmax( MDiffOne[0], sizeV ); <br>
&nbsp;&nbsp;&nbsp;&nbsp;printf( "\nmax. error of MVT*MV = (1): %lg", err );<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;check if MV is also orthonormal, i.e. MV*MVT = (1):  */<br>
&nbsp;&nbsp;&nbsp;&nbsp;MD_mulMT( MUV2, MV, MV, len, len, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;MD_subM( MDiffOne, MUV2, MOne, len, len );<br>
&nbsp;&nbsp;&nbsp;&nbsp;err = VD_absmax( MDiffOne[0], sizeV ); <br>
&nbsp;&nbsp;&nbsp;&nbsp;printf( "\nmax. error of MV*MVT = (1): %lg", err );<br>
&nbsp;&nbsp;&nbsp;&nbsp;printf( "\n\nHit any key to end SVDtest" ); _getch();<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;M_nfree( 8, MA, MU, MV, MOne, MA2, MUV2, MDiffA, MDiffOne );<br>
&nbsp;&nbsp;&nbsp;&nbsp;V_free( W );<br>
}</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#SVsolve">MF_SVsort</a>,&nbsp;&nbsp; <a href="#SVsolve">MF_SVsolve</a>,&nbsp;&nbsp; <a href="#safeSolve">MF_safeSolve</a>,&nbsp;&nbsp; <a href="#solveBySVD">MF_solveBySVD</a>,&nbsp;&nbsp; <a href="#chap10">chapter10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="SVDgetEdit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_SVDgetEdit</b></font>
</td><td width="33%"><font size="+1"><b>MD_SVDgetEdit</b></font></td>
<td><font size="+1"><b>ME_SVDgetEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>retrieve current editing threshold for Singular Value backsubstitution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float&nbsp;MF_SVDgetEdit( void&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
T matrix&lt;T&gt;::SVDgetEdit(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_SVDgetEdit: Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function returns the current Singular Value editing threshold. The SV editing threshold may be modified by <I><a href="#SVDsetEdit">MF_SVDsetEdit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>current SV editing threshold</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#SVdecompose">MF_SVdecompose</a>,&nbsp;&nbsp; <a href="#SVsolve">MF_SVsolve</a>,&nbsp;&nbsp; <a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="SVDsetEdit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_SVDsetEdit</b></font>
</td><td width="33%"><font size="+1"><b>MD_SVDsetEdit</b></font></td>
<td><font size="+1"><b>ME_SVDsetEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>set the Singular Value editing threshold</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_SVDsetEdit( float&nbsp;Thresh&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::SVDsetEdit( const&nbsp;T&amp;&nbsp;Thresh&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_SVDsetEdit( Thresh:Single&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>As described in connection with <I><a href="#SVdecompose">MF_SVdecompose</a></I> and <I><a href="#SVsolve">MF_SVsolve</a></I>, the crucial point in using functions which rely on Singular Value Decomposition is the Singular Value editing step. By default, the SV editing threshold is 4*FLT_EPSILON,&nbsp;&nbsp;8*DBL_EPSILON, or 16*LDBL_EPSILON. You may change these values by calling <I>MF_SVDsetEdit</I>. To retrieve the current SV editing threshold, call <I><a href="#SVDgetEdit">MF_SVDgetEdit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#SVdecompose">MF_SVdecompose</a>,&nbsp;&nbsp; <a href="#SVsolve">MF_SVsolve</a>,&nbsp;&nbsp; <a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="SVsolve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_SVsolve</b></font>
</td><td width="33%"><font size="+1"><b>MD_SVsolve</b></font></td>
<td><font size="+1"><b>ME_SVsolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>solve a system of linear equations, given its Singular Value decomposed form</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_SVsolve( fVector&nbsp;X, fMatrix&nbsp;MU, fMatrix&nbsp;MV, fVector&nbsp;W, fVector&nbsp;B, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::SVsolve( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MU, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MV, const&nbsp;vector&lt;T&gt;&amp;&nbsp;W, const&nbsp;vector&lt;T&gt;&amp;&nbsp;B&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_SVsolve( X:fVector; MU, MV:fMatrix; W, B:fVector; htA, lenA:UIntSize&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_SVsolve</I> solves an SV-decomposed set of linear equations; sometimes this process is also called Singular Value Backsubstitution. In this function, at first W is edited such that elements smaller than a threshold are set to zero. Then, in the backsubstitution process, which involves divisions by the elements of W, any divisions by W<sub>i</sub> = 0 are replaced by setting the result to 0. You can choose the editing threshold by calling <I><a href="#SVDsetEdit">MF_SVDsetEdit</a></I>. If you prefer to inspect and edit W yourself before calling <I><a href="#SVsolve">MF_SVsolve</a></I>, you can call <I><a href="#SVDsetEdit">MF_SVDsetEdit</a></I> with the argument 0.0, thereby switching off the automatic SV editing.
<P>The parameters htA and lenA refer to the original matrix MA as fed into <I><a href="#SVdecompose">MF_SVdecompose</a></I>.  The actual dimensions of the vectors and matrices entered into <I>MF_SVsolve</I> are:<BR>
sizeB = htA;<BR>
sizeX = htU = max( lenA, htA&nbsp;); <BR>
sizeW = lenU = htV = lenV = lenA; </td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#SVdecompose">MF_SVdecompose</a>,&nbsp;&nbsp; <a href="#solveBySVD">MF_solveBySVD</a>,&nbsp;&nbsp; <a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="SVsort"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_SVsort</b></font>
</td><td width="33%"><font size="+1"><b>MD_SVsort</b></font></td>
<td><font size="+1"><b>ME_SVsort</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>sort singular values obtained from <a href="#SVdecompose">MF_SVdecompose</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_SVsort( fMatrix&nbsp;MUout, fMatrix&nbsp;MVout, fVector&nbsp;Wout, fMatrix&nbsp;MUraw, fMatrix&nbsp;MVraw, fVector&nbsp;Wraw, ui&nbsp;htU, ui&nbsp;lenU&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::SVsort( matrix&lt;T&gt; MVout,  vector&lt;T&gt; Wout, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MUraw, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MVraw, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Wraw&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_SVsort( MUraw, MVraw:fMatrix; Wraw:fVector; MUraw, MVraw:fMatrix; Wraw:fVector; htU, lenU:UIntSize&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_SVsort</I> brings the vector W, containing the unordered singular values, as obtained from <a href="#SVdecompose">MF_SVdecompose</a>, into descending order. Simultaneously, columns of both matrices MV and MU are interchanged accordingly. The "raw" input data are MUraw, MVraw, and Wraw, while the ordered data on output are MUout, MVout, Wout. MUout may or may not overwrite MUraw; the same holds for the pairs MVout / MVraw and Wout / Wraw. 
<P>The parameters htU and lenU refer to the matrix MU. They relate to the dimensions of the original matrix MA, fed into <I><a href="#SVdecompose">MF_SVdecompose</a></I>, as:<BR>
htU = max( lenA, htA&nbsp;); <BR>
lenU = lenA; </td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#SVdecompose">MF_SVdecompose</a>,&nbsp;&nbsp; <a href="#solveBySVD">MF_solveBySVD</a>,&nbsp;&nbsp; <a href="#chap10">chapter&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="TmulM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_TmulM</b></font>
</td><td width="33%"><font size="+1"><b>MD_TmulM</b></font></td>
<td><font size="+1"><b>ME_TmulM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_TmulM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_TmulM</b></font></td>
<td><font size="+1"><b>MCE_TmulM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply the transpose of one matrix by another matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_TmulM( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::TmulM( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_TmulM( MC,&nbsp;MA,&nbsp;MB:fMatrix; htA,&nbsp;lenA,&nbsp;lenB:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_TmulM( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);
<BR>void MFcu_TmulM( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;lenB&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_TmulM( d_MC,&nbsp;d_MA,&nbsp;d_MB:fMatrix; htA,&nbsp;lenA,&nbsp;lenB:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_TmulM( h_MC,&nbsp;h_MA,&nbsp;h_MB:fMatrix; htA,&nbsp;lenA,&nbsp;lenB:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA<sup>T</sup> *&nbsp;MB
<BR>htA,&nbsp;lenA,&nbsp;and lenB must be specified; the other dimensions are implicitly given as: htB = htA, lenC = lenB, htC = lenA. htA and lenA refer to the original, un-transposed input matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulM">MF_mulM</a>,&nbsp;&nbsp; <a href="#mulMT">MF_mulMT</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="TmulMdia"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_TmulMdia</b></font>
</td><td width="33%"><font size="+1"><b>MD_TmulMdia</b></font></td>
<td><font size="+1"><b>ME_TmulMdia</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_TmulMdia</b></font></td>
<td width="33%"><font size="+1"><b>MCD_TmulMdia</b></font></td>
<td><font size="+1"><b>MCE_TmulMdia</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply the transpose of a general matrix by a diagonal matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_TmulMdia( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fVector&nbsp;MBDia, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::mulMdia( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;vector&lt;T&gt;&amp;&nbsp;MBDia,&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_TmulMdia( MC,&nbsp;MA:fMatrix; MBDia:fVector; htA,&nbsp;lenA:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_TmulMdia( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fVector&nbsp;d_MBDia, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);
<BR>void MFcu_TmulMdia( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fVector&nbsp;h_MBDia, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_TmulMdia( d_MC,&nbsp;d_MA:fMatrix; d_MBDia:fVector; htA,&nbsp;lenA:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_TmulMdia( h_MC,&nbsp;h_MA:fMatrix; h_MBDia:fVector; htA,&nbsp;lenA:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA<sup>T</sup> *&nbsp;MBDia
<BR>htA and lenA must be specified. They refer to the original, un-transposed input matrix. Implicitly, sizB = htA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#dia_mulM">MFdia_mulM</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="TmulMH"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_TmulMH</b></font></td>
<td width="33%"><font size="+1"><b>MCD_TmulMH</b></font></td>
<td><font size="+1"><b>MCE_TmulMH</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply the transpose of one matrix by the hermitian conjugate of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_TmulMH( cfMatrix&nbsp;MC, cfMatrix&nbsp;MA, cfMatrix&nbsp;MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;complex&lt;T&gt;&nbsp;&gt;::TmulMH( const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA, const&nbsp;matrix&lt;complex&lt;T&gt;&nbsp;&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_TmulMH( MC,&nbsp;MA,&nbsp;MB:cfMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMCFstd.h&gt;
<BR>int cudaMCF_TmulMH( cfMatrix&nbsp;d_MC, cfMatrix&nbsp;d_MA, cfMatrix&nbsp;d_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);
<BR>void MCFcu_TmulMH( cfMatrix&nbsp;h_MC, cfMatrix&nbsp;h_MA, cfMatrix&nbsp;h_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MCFstd;
<BR>function cudaMCF_TmulMH( d_MC,&nbsp;d_MA,&nbsp;d_MB:cfMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MCF_TmulMH( h_MC,&nbsp;h_MA,&nbsp;h_MB:cfMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA<sup>T</sup> *&nbsp;MB<sup>T*</sup>
<BR>htA,&nbsp;lenA,&nbsp;and htB must be specified; the other dimensions are implicitly given as: lenB = htA, lenC = htB, htC = lenA. All dimensions refer to the original, un-transposed input matrices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulM">MF_mulM</a>,&nbsp;&nbsp; <a href="#TmulM">MF_TmulM</a>,&nbsp;&nbsp; <a href="#mulMH">MCF_mulMH</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="TmulMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_TmulMT</b></font>
</td><td width="33%"><font size="+1"><b>MD_TmulMT</b></font></td>
<td><font size="+1"><b>ME_TmulMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_TmulMT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_TmulMT</b></font></td>
<td><font size="+1"><b>MCE_TmulMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply the transpose of one matrix by the transpose of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_TmulMT( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::TmulMT( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_TmulMT( MC,&nbsp;MA,&nbsp;MB:fMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_TmulMT( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);
<BR>void MFcu_TmulMT( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;htA, ui&nbsp;lenA, ui&nbsp;htB&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_TmulMT( d_MC,&nbsp;d_MA,&nbsp;d_MB:fMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_TmulMT( h_MC,&nbsp;h_MA,&nbsp;h_MB:fMatrix; htA,&nbsp;lenA,&nbsp;htB:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA<sup>T</sup> *&nbsp;MB<sup>T</sup>
<BR>htA,&nbsp;lenA,&nbsp;and htB must be specified; the other dimensions are implicitly given as: lenB = htA, lenC = htB, htC = lenA. All dimensions refer to the original, un-transposed input matrices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulM">MF_mulM</a>,&nbsp;&nbsp; <a href="#TmulM">MF_TmulM</a>,&nbsp;&nbsp; <a href="#mulMT">MF_mulMT</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="TmulV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_TmulV</b></font>
</td><td width="33%"><font size="+1"><b>MD_TmulV</b></font></td>
<td><font size="+1"><b>ME_TmulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_TmulV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_TmulV</b></font></td>
<td><font size="+1"><b>MCE_TmulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply the transpose of a matrix by a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_TmulV( fVector&nbsp;Y, fMatrix&nbsp;MA, fVector&nbsp;X, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void vector&lt;T&gt;::TmulV( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;vector&lt;T&gt;&amp;&nbsp;X &nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_TmulV( Y:fVector; MA:fMatrix; X:fVector; htA, lenA:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_TmulV( fVector&nbsp;d_Y, fMatrix&nbsp;d_MA, fVector&nbsp;d_X, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);
<BR>void MFcu_TmulV( fVector&nbsp;h_Y, fMatrix&nbsp;h_MA, fVector&nbsp;h_X, ui&nbsp;htA, ui&nbsp;lenA&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_TmulV( d_Y:fVector; d_MA:fMatrix; d_X:fVector; htA,&nbsp;lenA:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_TmulV( h_Y:fVector; h_MA:fMatrix; h_X:fVector; htA,&nbsp;lenA:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y = MA<sup>T</sup> *&nbsp;X
<BR>The dimensions htA and lenA refer to the original (rather than the intermediate transposed) matrix MA; the dimensions of X and Y are implicitly given by the matrix dimensions: sizX = htA, sizY = lenA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulV">MF_mulV</a>,&nbsp;&nbsp; <a href="#VmulM">VF_mulM</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="transpose"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_transpose</b></font>
</td><td width="33%"><font size="+1"><b>MD_transpose</b></font></td>
<td><font size="+1"><b>ME_transpose</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_transpose</b></font></td>
<td width="33%"><font size="+1"><b>MCD_transpose</b></font></td>
<td><font size="+1"><b>MCE_transpose</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_transpose</b></font></td><td width="20%"><font size="+1"><b>MBI_transpose</b></font></td><td width="20%"><font size="+1"><b>MSI_transpose</b></font></td><td width="20%"><font size="+1"><b>MLI_transpose</b></font></td><td><font size="+1"><b>MQI_transpose</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_transpose</b></font></td><td width="20%"><font size="+1"><b>MUB_transpose</b></font></td><td width="20%"><font size="+1"><b>MUS_transpose</b></font></td><td width="20%"><font size="+1"><b>MUL_transpose</b></font></td><td><font size="+1"><b>MUQ_transpose</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>transpose of a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_transpose( fMatrix&nbsp;MTr, fMatrix&nbsp;MA, ui&nbsp;htTr, ui&nbsp;lenTr&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::transpose( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_transpose( MTr, MA:fMatrix; htTr, lenTr:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_transpose( fMatrix&nbsp;d_MTr, fMatrix&nbsp;d_MA, ui&nbsp;htTr, ui&nbsp;lenTr&nbsp;);
<BR>void MFcu_transpose( fMatrix&nbsp;h_MTr, fMatrix&nbsp;h_MA, ui&nbsp;htTr, ui&nbsp;lenTr&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_transpose( d_MTr,&nbsp;d_MA:fMatrix; htTr, lenTr:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_transpose( h_MTr,&nbsp;h_MA:fMatrix; htTr, lenTr:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MTr<sub>i,j</sub> = MA<sub>j,i</sub>
<BR>The dimensions fed into this function, htTr and lenTr, refer to the transposed matrix rather than to the input matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#hermconj">MCF_hermconj</a>,&nbsp;&nbsp; <a href="#mulMT">MF_mulMT</a>,&nbsp;&nbsp; <a href="#chap9">chapter&nbsp;9</a>,&nbsp;&nbsp; <a href="#chap5">chapter&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Trd_equM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Trd_equM</b></font>
</td><td width="33%"><font size="+1"><b>MD_Trd_equM</b></font></td>
<td><font size="+1"><b>ME_Trd_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Trd_equM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Trd_equM</b></font></td>
<td><font size="+1"><b>MCE_Trd_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Trd_equM</b></font></td><td width="20%"><font size="+1"><b>MBI_Trd_equM</b></font></td><td width="20%"><font size="+1"><b>MSI_Trd_equM</b></font></td><td width="20%"><font size="+1"><b>MLI_Trd_equM</b></font></td><td><font size="+1"><b>MQI_Trd_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Trd_equM</b></font></td><td width="20%"><font size="+1"><b>MUB_Trd_equM</b></font></td><td width="20%"><font size="+1"><b>MUS_Trd_equM</b></font></td><td width="20%"><font size="+1"><b>MUL_Trd_equM</b></font></td><td><font size="+1"><b>MUQ_Trd_equM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize the tridiagonal part of a matrix with the three vectors contained in a compacted tradiagonal matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Trd_equM( fMatrix&nbsp;MA, fMatrix&nbsp;Trd, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Trd_equM( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MTrd&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Trd_equM( MA, MTrd:fMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Trd_equM( fMatrix&nbsp;d_MA, fMatrix&nbsp;Trd, ui&nbsp;len&nbsp;);
<BR>void MFcu_Trd_equM( fMatrix&nbsp;h_MA, fMatrix&nbsp;Trd, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Trd_equM( d_MA,&nbsp;d_MTrd:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Trd_equM( h_MA,&nbsp;h_MTrd:fMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Row 0 of MTrd is copied into the first diagonal above the main diagonal of the square matrix MA. Row 1 of MTrd goes into the main diagonal of MA, and Row 2 of MTrd into the first diagonal below the main diagonal of MA. See <a href="#chap1_2">chapter&nbsp;1.2</a> for details about the storing of tridiagonal matrices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#Trd_extract">MF_Trd_extract</a>,&nbsp;&nbsp; <a href="#chap2">chapter&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Trd_extract"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Trd_extract</b></font>
</td><td width="33%"><font size="+1"><b>MD_Trd_extract</b></font></td>
<td><font size="+1"><b>ME_Trd_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Trd_extract</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Trd_extract</b></font></td>
<td><font size="+1"><b>MCE_Trd_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_Trd_extract</b></font></td><td width="20%"><font size="+1"><b>MBI_Trd_extract</b></font></td><td width="20%"><font size="+1"><b>MSI_Trd_extract</b></font></td><td width="20%"><font size="+1"><b>MLI_Trd_extract</b></font></td><td><font size="+1"><b>MQI_Trd_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_Trd_extract</b></font></td><td width="20%"><font size="+1"><b>MUB_Trd_extract</b></font></td><td width="20%"><font size="+1"><b>MUS_Trd_extract</b></font></td><td width="20%"><font size="+1"><b>MUL_Trd_extract</b></font></td><td><font size="+1"><b>MUQ_Trd_extract</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>extract the tridiagonal part from a general matrix and store it into a compacted tridiagonal matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Trd_extract( fMatrix&nbsp;MTrd, fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Trd_estract( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Trd_extract( MTrd,&nbsp;MA:fMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Trd_extract( fMatrix&nbsp;d_MTrd, fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>void MFcu_Trd_extract( fMatrix&nbsp;h_MTrd, fMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Trd_extract( d_MTrd,&nbsp;d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Trd_extract( h_MTrd,&nbsp;h_MA:fMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The first diagonal above the main diagonal of the square matrix MA is copied into Row 0 of MTrd. The main diagonal of MA goes into Row1 of MTrd, and the first diagonal below the main diagonal of MA is copied into Row 2 of MTrd. See <a href="#chap1_2">chapter&nbsp;1.2</a> for details about the storing of tridiagonal matrices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_extract">MF_Dia_extract</a>,&nbsp;&nbsp; <a href="#Trd_equM">MF_Trd_equM</a>,&nbsp;&nbsp; <a href="#chap2">chapter&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="UequL"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_UequL</b></font>
</td><td width="33%"><font size="+1"><b>MD_UequL</b></font></td>
<td><font size="+1"><b>ME_UequL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_UequL</b></font></td>
<td width="33%"><font size="+1"><b>MCD_UequL</b></font></td>
<td><font size="+1"><b>MCE_UequL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_UequL</b></font></td><td width="20%"><font size="+1"><b>MBI_UequL</b></font></td><td width="20%"><font size="+1"><b>MSI_UequL</b></font></td><td width="20%"><font size="+1"><b>MLI_UequL</b></font></td><td><font size="+1"><b>MQI_UequL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_UequL</b></font></td><td width="20%"><font size="+1"><b>MUB_UequL</b></font></td><td width="20%"><font size="+1"><b>MUS_UequL</b></font></td><td width="20%"><font size="+1"><b>MUL_UequL</b></font></td><td><font size="+1"><b>MUQ_UequL</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy lower-diagonal elements into upper-diagonal by index-reflection, so as to get a symmetric matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_UequL( fMatrix&nbsp;MA, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::UequL(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_UequL( MA:fMatrix; len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_UequL( fMatrix&nbsp;d_MA, ui&nbsp;len&nbsp;);
<BR>void MFcu_UequL( fMatrix&nbsp;h_MA, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_UequL( d_MA:fMatrix; len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_UequL( h_MA:fMatrix; len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = MA<sub>j,i</sub>,&nbsp;&nbsp;i &lt; j</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#LequU">MF_LequU</a>,&nbsp;&nbsp; <a href="#chap3">chapter&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Welch"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Welch</b></font>
</td><td width="33%"><font size="+1"><b>MD_Welch</b></font></td>
<td><font size="+1"><b>ME_Welch</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>two-dimensional Welch window for use in spatial frequency analysis</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Welch( fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::Welch(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Welch( MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_Welch( fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_Welch( fMatrix&nbsp;h_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font>
</td></tr><tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_Welch( d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_Welch( h_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = (1 - ( (i - 0.5*(ht - 1)) / (0.5*(ht + 1))&nbsp;)<sup>2</sup>) *&nbsp;(1 - ( (j - 0.5*(len - 1)) / (0.5*(len + 1))&nbsp;)<sup>2</sup>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Parzen">MF_Parzen</a>,&nbsp;&nbsp; <a href="#Hann">MF_Hann</a>,&nbsp;&nbsp; <a href="#spectrum">MF_spectrum</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="write"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_write</b></font>
</td><td width="33%"><font size="+1"><b>MD_write</b></font></td>
<td><font size="+1"><b>ME_write</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_write</b></font></td>
<td width="33%"><font size="+1"><b>MCD_write</b></font></td>
<td><font size="+1"><b>MCE_write</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_write</b></font></td><td width="20%"><font size="+1"><b>MBI_write</b></font></td><td width="20%"><font size="+1"><b>MSI_write</b></font></td><td width="20%"><font size="+1"><b>MLI_write</b></font></td><td><font size="+1"><b>MQI_write</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_write</b></font></td><td width="20%"><font size="+1"><b>MUB_write</b></font></td><td width="20%"><font size="+1"><b>MUS_write</b></font></td><td width="20%"><font size="+1"><b>MUL_write</b></font></td><td><font size="+1"><b>MUQ_write</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>write a matrix in ASCII format into a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_write( FILE *stream, fMatrix&nbsp;MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::write( FILE *stream &nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
&nbsp;&nbsp;procedure MF_write( var Stream:TextFile; MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_write( FILE *stream, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>int cudaMF_write_buf( FILE *stream, fMatrix&nbsp;d_MA, ui&nbsp;ht, ui&nbsp;len, fVector&nbsp;h_Wk&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_write( var&nbsp;Stream:TextFile; d_MA:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>function cudaMF_write_buf( var&nbsp;Stream:TextFile; d_MA:fMatrix; ht,&nbsp;len:UIntSize; h_Wk:fVector&nbsp;):&nbsp;IntBool;</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA with <I>len</I> columns and <I>ht</I> rows is written to <I>stream</I> in ASCII format. <I>stream</I> must already be open for write operations in text format.
<P>The number format and the separation between columns may be specified using <I><a href="#setWriteFormat">MF_setWriteFormat</a></I> (C/C++ only) and <I><a href="#setWriteSeparate">MF_setWriteSeparate</a></I>, respectively. See these functions for details.
<P>Storing data in ASCII format is useful if the data have to be readable by human eyes, or if they are to be exported into other programs which are not able to read machine-format numbers. If avoidable, these functions should not be used for the storage of intermediate results that later have again to be read in. Instead, the function pairs of the <I><a href="#store">MF_store</a></I> / <I><a href="#recall">MF_recall</a></I> family are recommended for the following reasons: conversion into ASCII format is slow, may lead to round-off errors, and requires much more disk memory than storage in machine format.
<P>CUDA versions only: <i>cudaM?_write_buf</i> takes a host vector <i>h_Wk</i> as additional argument. The latter serves as buffer memory and needs to be (at least) of the same size as d_MA, i.e. ht*len. By avoiding the need of <i>cudaM?_write</i> to allocate its own buffer memory, <i>cudaM?_write_buf</i> is slightly faster.
</td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setWriteFormat">MF_setWriteFormat</a>,&nbsp;&nbsp; <a href="#setWriteSeparate">MF_setWriteSeparate</a>,&nbsp;&nbsp; <a href="#read">MF_read</a>,&nbsp;&nbsp; <a href="#store">MF_store</a>,&nbsp;&nbsp; <a href="#print">MF_print</a>,&nbsp;&nbsp; <a href="#chap14">chapter&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="xcorr"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_xcorr</b></font>
</td><td width="33%"><font size="+1"><b>MD_xcorr</b></font></td>
<td><font size="+1"><b>ME_xcorr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>spatial cross-correlation function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_xcorr( fMatrix&nbsp;MC, fMatrix&nbsp;MA, fMatrix&nbsp;MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::xcorr( const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MA, const&nbsp;matrix&lt;T&gt;&amp;&nbsp;MB&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_xcorr( MC,&nbsp;MA,&nbsp;MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">CUDA function C/C++</td><td><font face="courier new">#include &lt;cudaMFstd.h&gt;
<BR>int cudaMF_xcorr( fMatrix&nbsp;d_MC, fMatrix&nbsp;d_MA, fMatrix&nbsp;d_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);
<BR>void MFcu_xcorr( fMatrix&nbsp;h_MC, fMatrix&nbsp;h_MA, fMatrix&nbsp;h_MB, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP">
<td>CUDA function Pascal/Delphi</td><td><font face="courier new">uses MFstd;
<BR>function cudaMF_xcorr( d_MC,&nbsp;d_MA,&nbsp;d_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;):&nbsp;IntBool;
<BR>procedure MFcu_xcorr( h_MC,&nbsp;h_MA,&nbsp;h_MB:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font>
</td></tr></table></td></tr>

<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The spatial cross-correlation function (SCCF) of MA and MB is calculated and stored in MC in wrap-around order in both dimensions: The row elements MC<sub>i,0</sub> to MC<sub>i,len/2-1</sub> contain the SCCF for zero and positive x lags. Beginning with the most negative lag in MC<sub>i,len/2+1</sub>, the elements up to MC<sub>i,len-1</sub> contain the SCCF for negative lags. Since this function assumes MA and MB to be periodic, the SCCF for the most positive lag is identical to the SCCF for the most negative lag. This element is stored as MC<sub>i,len/2</sub>.
<BR>Similarly, the column elements MC<sub>0,j</sub> to MC<sub>len/2-1,j</sub> contain the SCCF for zero and positive y lags. Beginning with the most negative lag in MC<sub>len/2+1,j</sub>, the elements up to MC<sub>len-1,j</sub> contain the SCCF for negative lags.
<BR>To get the SCCF into normal order, you may call
<BR><font face="courier new"> <a href="#Rows_rotate">MF_Rows_rotate</a>( MC, ht,&nbsp;len,&nbsp;len/2&nbsp;);
<BR><a href="#Cols_rotate">MF_Cols_rotate</a>( MC, ht,&nbsp;len,&nbsp;ht/2&nbsp;);</font>
<BR>After that, the zero point is at the position MC<sub>ht/2,len/2</sub>.
<BR>In case MA or MB are non-periodic, you should avoid end effects by the methods described in connection with <I><a href="#convolve">MF_convolve</a></I>.
<BR>All three matrices involved have the same dimensions. Both <I>ht</I> and <I>len</I> must be integer powers of 2.
<BR>About special versions with the prefixes <I>MFl_</I> and <I>MFs_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8 of HANDBOOK.HTM</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either len or ht is not a power of 2, <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I> (on which <I>MF_xcorr</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#autocorr">MF_autocorr</a>,&nbsp;&nbsp; <a href="#chap12">chapter&nbsp;12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="xyzAutoDensityMap"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_xyzAutoDensityMap</b></font>
</td><td width="33%"><font size="+1"><b>MD_xyzAutoDensityMap</b></font></td>
<td><font size="+1"><b>ME_xyzAutoDensityMap</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_xyzAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MBI_xyzAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MSI_xyzAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MLI_xyzAutoDensityMap</b></font></td><td><font size="+1"><b>MQI_xyzAutoDensityMap</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_xyzAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUB_xyzAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUS_xyzAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUL_xyzAutoDensityMap</b></font></td><td><font size="+1"><b>MUQ_xyzAutoDensityMap</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>draw an X-Y coordinate system and plot a color-density map for z = f( x, y&nbsp;) into it</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void MF_xyzAutoDensityMap( fVector&nbsp;X, fVector&nbsp;Y, fMatrix&nbsp;Z, ui&nbsp;ht, ui&nbsp;len, COLORREF&nbsp;mincolor, COLORREF&nbsp;maxcolor&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::xyzAutoDensityMap( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y, COLORREF&nbsp;mincolor, COLORREF&nbsp;maxcolor&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure MF_xyzAutoDensityMap( X,&nbsp;Y:fVector; MZ:fMatrix; ht,&nbsp;len:UIntSize; mincolor, maxcolor: COLORREF&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian coordinate system is drawn with automatic scaling of the axes and the matrix MZ is plotted as a color-density map against the vectors X and Y. Prior to calling <I>MF_xyzAutoDensityMap</I>, the plotting routines have to be initialized by <I><a href="FUNCREF.HTM#initGraph">V_initGraph</a></I> (for DOS programs) or <I><a href="FUNCREF.HTM#initPlot">V_initPlot</a></I> (DOS or Windows programs).
<P>The font of the axis tick labels is the actual text font. In DOS programs (Borland C++ or Pascal), it may be changed by calling <I>settextstyle</I> before calling <I>MF_xyzAutoDensityMap</I>. In Windows programs (both 16-bit and 32-bit), the font of the current device context is used.
<P>All MZ values will be translated into colors by linear interpolation between the parameters <I>mincolor</I> and <I>maxcolor</I>.
<BR><U>DOS:</U>&nbsp;&nbsp; The data type COLORREF is <B>unsigned</B>. See the Borland C++ or TurboPascal function <i>setcolor</i> for a description of the colors available in the various graphics modes. 
<BR><U>Windows:</U> The data type COLORREF is <B>unsigned long</B>. The colors BLACK, BLUE, GREEN, CYAN, RED, MAGENTA, BROWN, LIGHTGRAY, DARKGRAY, LIGHTBLUE, LIGHTGREEN, LIGHTCYAN, LIGHTRED, LIGHTMAGENTA, YELLOW, and WHITE are defined in &lt;Vgraph.h&gt; (or the unit Vgraph) by analogy with the COLORS defined for DOS in &lt;graphics.h&gt; (or the unit Graph) for the BGI routines. Thereby, portability between DOS and Windows programs is improved. For programs designed to run exclusively under Windows, it is nevertheless recommended to use fine-tuned colors defined by the RGB macro, instead of the predefined colors.
<P>If you wish to define the boudaries of the coordinate system differently, instead of relying on the automatic range detection and scaling, you may call first <I><a href="#setDensityMapBounds">M_setDensityMapBounds</a></I> or (for preserved automatic scaling, but with arbitrary x and y ranges) <I><a href="#findDensityMapBounds">MF_findDensityMapBounds</a></I>. Subsequently, call <I><a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a></I> instead of <I>MF_xyzAutoDensityMap</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#zAutoDensityMap">MF_zAutoDensityMap</a>,&nbsp;&nbsp; <a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#chap15">chapter&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="xyzDataDensityMap"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_xyzDataDensityMap</b></font>
</td><td width="33%"><font size="+1"><b>MD_xyzDataDensityMap</b></font></td>
<td><font size="+1"><b>ME_xyzDataDensityMap</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_xyzDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MBI_xyzDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MSI_xyzDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MLI_xyzDataDensityMap</b></font></td><td><font size="+1"><b>MQI_xyzDataDensityMap</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_xyzDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUB_xyzDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUS_xyzDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUL_xyzDataDensityMap</b></font></td><td><font size="+1"><b>MUQ_xyzDataDensityMap</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>plot a color density map z = f( x, y&nbsp;) into an existing coordinate system with a previously defined color scale</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void MF_xyzDataDensityMap( fVector&nbsp;X, fVector&nbsp;Y, fMatrix&nbsp;Z, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::xyzDataDensityMap( const&nbsp;vector&lt;T&gt;&amp;&nbsp;X, const&nbsp;vector&lt;T&gt;&amp;&nbsp;Y&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure MF_xyzDataDensityMap( X,&nbsp;Y:fVector; MZ:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MZ is plotted against the vectors X and Y into a coordinate system which has to be created by a previous call to <I><a href="#setDensityMapBounds">MF_setDensityMapBounds</a></I> or (for automatic scaling) <I><a href="#findDensityMapBounds">MF_findDensityMapBounds</a></I>. To perform the plot with automatic range checking and axis scaling, call <I><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a></I> instead.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#zDataDensityMap">MF_zDataDensityMap</a>,&nbsp;&nbsp; <a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>,&nbsp;&nbsp; <a href="#chap15">chapter&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="zAutoDensityMap"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_zAutoDensityMap</b></font>
</td><td width="33%"><font size="+1"><b>MD_zAutoDensityMap</b></font></td>
<td><font size="+1"><b>ME_zAutoDensityMap</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_zAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MBI_zAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MSI_zAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MLI_zAutoDensityMap</b></font></td><td><font size="+1"><b>MQI_zAutoDensityMap</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_zAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUB_zAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUS_zAutoDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUL_zAutoDensityMap</b></font></td><td><font size="+1"><b>MUQ_zAutoDensityMap</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>plot a color density map of a matrix against the indices over its dimensions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void MF_zAutoDensityMap( fMatrix&nbsp;Z, ui&nbsp;ht, ui&nbsp;len, COLORREF&nbsp;mincolor, COLORREF&nbsp;maxcolor&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::zAutoDensityMap( COLORREF&nbsp;mincolor, COLORREF&nbsp;maxcolor&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure MF_xyzDataDensityMap( X,&nbsp;Y:fVector; MZ:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function is similar to <I><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a></I>, but here MZ is plotted against the indices of its dimensions instead of explicit X and Y values.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>,&nbsp;&nbsp; <a href="#chap15">chapter&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="zDataDensityMap"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_zDataDensityMap</b></font>
</td><td width="33%"><font size="+1"><b>MD_zDataDensityMap</b></font></td>
<td><font size="+1"><b>ME_zDataDensityMap</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_zDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MBI_zDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MSI_zDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MLI_zDataDensityMap</b></font></td><td><font size="+1"><b>MQI_zDataDensityMap</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_zDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUB_zDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUS_zDataDensityMap</b></font></td><td width="20%"><font size="+1"><b>MUL_zDataDensityMap</b></font></td><td><font size="+1"><b>MUQ_zDataDensityMap</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>plot a color-density map of a matrix into an existing coordinate system whose axes comprise the range of the indices of the matrix dimensions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void MF_zDataDensityMap( fMatrix&nbsp;Z, ui&nbsp;ht, ui&nbsp;len&nbsp;);</font></td></tr>
<tr valign="TOP"><td>C++ MatObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;<BR>
void matrix&lt;T&gt;::zDataDensityMap(&nbsp;);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure MF_zDataDensityMap( MZ:fMatrix; ht,&nbsp;len:UIntSize&nbsp;);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function is similar to <I><a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a></I>, but here MZ is plotted against the indices of its dimensions instead of explicit X and Y values.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a>,&nbsp;&nbsp; <a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>,&nbsp;&nbsp; <a href="#chap15">chapter&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="2DArrayToMatrix"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_2DArrayToMatrix</b></font>
</td><td width="33%"><font size="+1"><b>MD_2DArrayToMatrix</b></font></td>
<td><font size="+1"><b>ME_2DArrayToMatrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_2DArrayToMatrix</b></font></td>
<td width="33%"><font size="+1"><b>MCD_2DArrayToMatrix</b></font></td>
<td><font size="+1"><b>MCE_2DArrayToMatrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MI_2DArrayToMatrix</b></font></td><td width="20%"><font size="+1"><b>MBI_2DArrayToMatrix</b></font></td><td width="20%"><font size="+1"><b>MSI_2DArrayToMatrix</b></font></td><td width="20%"><font size="+1"><b>MLI_2DArrayToMatrix</b></font></td><td><font size="+1"><b>MQI_2DArrayToMatrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>MU_2DArrayToMatrix</b></font></td><td width="20%"><font size="+1"><b>MUB_2DArrayToMatrix</b></font></td><td width="20%"><font size="+1"><b>MUS_2DArrayToMatrix</b></font></td><td width="20%"><font size="+1"><b>MUL_2DArrayToMatrix</b></font></td><td><font size="+1"><b>&nbsp;</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>convert 2D-array of Delphi 4 or higher into <I>OptiVec</I> matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td>N.A.</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd, VecLib;<BR>
type  fArray  = array of Single;<BR>
type  f2DArray  = array of fArray;<BR>
procedure    MF_2DArrayToMatrix( MF:fMatrix; DelphiArr:f2DArray; ht,len:UIntSize);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function converts two-dimensional Delphi arrays into <I>OptiVec</I> matrices. Note that, unlike static Pascal/Delphi matrices, the dynamic matrices of Delphi cannot directly be passed to <I>OptiVec</I> functions, but have to be converted first.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#MatrixTo2DArray">MF_MatrixTo2DArray</a>,&nbsp;&nbsp; <a href="#chap1_4">chapter&nbsp;1.4</a></td></tr></table></td></tr>
</table>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<BR>&nbsp;<BR><HR width="100%"><H1>E N D </H1>
Copyright for <i>OptiVec</i> software and documentation
<BR>&copy; 1996-2017 <I>OptiCode</I> - Dr. Martin Sander Software Dev.
<BR>All rights reserved!
</body>
</html>
